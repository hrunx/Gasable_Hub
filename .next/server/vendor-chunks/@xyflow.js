"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   MiniMapNode: () => (/* binding */ MiniMapNode),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,MiniMapNode,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error001']();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig['node.a11yDescription.default'] : ariaLabelConfig['node.a11yDescription.keyboardDisabled']\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig['edge.a11yDescription.default']\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = 'top-left', children, className, style, ...rest }, ref)=>{\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: style,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = 'Panel';\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'autoPanOnNodeFocus',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'connectionDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance',\n    'ariaLabelConfig'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'ariaLabelConfig') store.setState({\n                    ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n                });\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewQueued: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOptions: fieldValue\n                });\n                else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"])/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.replace('+', '\\n').replace('\\n\\n', '\\n+').split('\\n')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target ?? defaultDoc;\n            const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            const target = event.composedPath?.()?.[0] || event.target;\n                            const isInteractiveElement = target?.nodeName === 'BUTTON' || target?.nodeName === 'A';\n                            if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                                event.preventDefault();\n                            }\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, options);\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        return store.getState().setCenter(x, y, options);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration,\n                            ease: options?.ease,\n                            interpolate: options?.interpolate\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {})=>{\n                        const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        const _snapGrid = options.snapGrid ?? snapGrid;\n                        const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === 'width') {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === 'height') {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setSerial({\n                        \"useQueue.useState\": (n)=>n + BigInt(1)\n                    }[\"useQueue.useState\"])\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();\n            /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            const changes = getElementsDiffChanges({\n                items: next,\n                lookup: nodeLookup\n            });\n            if (hasDefaultNodes) {\n                setNodes(next);\n            }\n            // We only want to fire onNodesChange if there are changes to the nodes\n            if (changes.length > 0) {\n                onNodesChange?.(changes);\n            } else if (fitViewQueued) {\n                // If there are no changes to the nodes, we still need to call setNodes\n                // to trigger a re-render and fitView.\n                window.requestAnimationFrame({\n                    \"BatchProvider.useCallback[nodeQueueHandler]\": ()=>{\n                        const { fitViewQueued, nodes, setNodes } = store.getState();\n                        if (fitViewQueued) {\n                            setNodes(nodes);\n                        }\n                    }\n                }[\"BatchProvider.useCallback[nodeQueueHandler]\"]);\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        ...nodeToUse,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                /**\n             * Partial is defined as \"the 2 nodes/areas are intersecting partially\".\n             * If a is contained in b or b is contained in a, they are both\n             * considered fully intersecting.\n             */ getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodeConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                fitView: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async (options)=>{\n                        // We either create a new Promise or reuse the existing one\n                        // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                        const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                        // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                        store.setState({\n                            fitViewQueued: true,\n                            fitViewOptions: options,\n                            fitViewResolver\n                        });\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                        return fitViewResolver.promise;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current || !(domNode.current.checkVisibility?.() ?? true)) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib,\n        connectionInProgress: s.connection.inProgress\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib, connectionInProgress } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange,\n                connectionInProgress\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange,\n        connectionInProgress\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                handleDomNode: event.currentTarget,\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed,\n                dragThreshold: currentStore.connectionDragThreshold\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = nodeTypes?.['default'] || builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig['node.a11yDescription.ariaLiveMessage']({\n                    direction: event.key.replace('Arrow', '').toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(':focus-visible')) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? 'group' : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, its designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when youre dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs  and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once  instead of once per node.\n             * - Any operations that youd normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized  so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrow\",\n        style: style,\n        strokeLinecap: \"round\",\n        fill: \"none\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color,\n            fill: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrowclosed\",\n        style: style,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    'react-flow__edge-path',\n                    props.className\n                ])\n            }),\n            interactionWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }) : null,\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset,\n            stepPosition: pathOptions?.stepPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        const _onConnectStart = (_event, params)=>{\n            setReconnecting(true);\n            onReconnectStart?.(event, edge, oppositeHandle.type);\n            onConnectStart?.(_event, params);\n        };\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart: _onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle,\n            dragThreshold: store.getState().connectionDragThreshold,\n            handleDomNode: event.currentTarget\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = edgeTypes?.['default'] || builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? 'group' : 'img'),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: width ?? 0,\n        height: height ?? 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        connectionDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                minZoom,\n                maxZoom,\n                fitViewOptions,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, onScroll, ariaLabelConfig, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ReactFlow.useCallback[wrapperOnScroll]\": (e)=>{\n            e.currentTarget.scrollTo({\n                top: 0,\n                left: 0,\n                behavior: 'instant'\n            });\n            onScroll?.(e);\n        }\n    }[\"ReactFlow.useCallback[wrapperOnScroll]\"], [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    connectionDragThreshold: connectionDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn('[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections');\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : ''}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error014']();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useNodeConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ''}`)\n    }[\"useNodeConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeConnections.useEffect\": ()=>{\n            // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useNodeConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useNodeConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useNodeConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components its important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig['controls.ariaLabel'],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig['controls.zoomIn.ariaLabel'],\n                        \"aria-label\": ariaLabelConfig['controls.zoomIn.ariaLabel'],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig['controls.zoomOut.ariaLabel'],\n                        \"aria-label\": ariaLabelConfig['controls.zoomOut.ariaLabel'],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig['controls.fitView.ariaLabel'],\n                \"aria-label\": ariaLabelConfig['controls.fitView.ariaLabel'],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig['controls.interactive.ariaLabel'],\n                \"aria-label\": ariaLabelConfig['controls.interactive.ariaLabel'],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, its designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const { internals } = s.nodeLookup.get(id);\n            const node = internals.userNode;\n            const { x, y } = internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 1, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig['minimap.ariaLabel'];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'number' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: 'right',\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: 'bottom-right'\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin,\n                                paneDomNode: domNode\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width ?? 0;\n                                const height = change.height ?? node.measured.height ?? 0;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const setAttributes = !resizeDirection ? true : resizeDirection === 'horizontal' ? 'width' : 'height';\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ({ width, height })=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false,\n                                dimensions: {\n                                    width,\n                                    height\n                                }\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                resizeDirection,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? 'backgroundColor' : 'borderColor']: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZzhCQUN3RDtBQUNnRjtBQUM5RztBQUNrc0M7QUFDMTRCO0FBQy9QO0FBQ3pDO0FBQ0Q7QUFFekMsTUFBTTZGLDZCQUFlMUYsb0RBQWFBLENBQUM7QUFDbkMsTUFBTTJGLGFBQWFELGFBQWFFLFFBQVE7QUFFeEMsTUFBTUMsc0JBQXNCbEYseURBQWEsQ0FBQyxXQUFXO0FBQ3JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU21GLFNBQVNDLFFBQVEsRUFBRUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRaEcsaURBQVVBLENBQUN5RjtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU9QLDJFQUFzQkEsQ0FBQ1csT0FBT0YsVUFBVUM7QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRztJQUNMLE1BQU1GLFFBQVFoRyxpREFBVUEsQ0FBQ3lGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBTzNGLDhDQUFPQTsrQkFBQyxJQUFPO2dCQUNsQmtHLFVBQVVILE1BQU1HLFFBQVE7Z0JBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO2dCQUN4QkMsV0FBV0wsTUFBTUssU0FBUztZQUM5Qjs4QkFBSTtRQUFDTDtLQUFNO0FBQ2Y7QUFFQSxNQUFNTSxRQUFRO0lBQUVDLFNBQVM7QUFBTztBQUNoQyxNQUFNQyxnQkFBZ0I7SUFDbEJDLFVBQVU7SUFDVkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVEsQ0FBQztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxN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dGhDLE1BQU0sQ0FBQyxDQUFDdWhDLEtBQUtybkMsT0FBUyxHQUFHcW5DLE1BQU1ybkMsS0FBS3BCLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJMG9DLElBQUk7WUFBSXpvQyxVQUFVQTtRQUFTO0lBQUc7QUFDclA7QUFFNnFCIiwic291cmNlcyI6WyIvVXNlcnMvaHJuL0Rlc2t0b3AvZ2FzYWJsZV9tY3Avbm9kZV9tb2R1bGVzL0B4eWZsb3cvcmVhY3QvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IGpzeHMsIEZyYWdtZW50LCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlcywgbWVyZ2VBcmlhTGFiZWxDb25maWcsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCB3aXRoUmVzb2x2ZXJzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGdldERpbWVuc2lvbnMsIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgYXJlU2V0c0VxdWFsLCBYWURyYWcsIHNuYXBQb3NpdGlvbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBQb3NpdGlvbiwgQ29ubmVjdGlvbk1vZGUsIGlzTW91c2VFdmVudCwgWFlIYW5kbGUsIGdldEhvc3RGb3JFbGVtZW50LCBhZGRFZGdlLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBpc051bWVyaWMsIG5vZGVIYXNEaW1lbnNpb25zLCBnZXROb2RlRGltZW5zaW9ucywgZWxlbWVudFNlbGVjdGlvbktleXMsIGlzRWRnZVZpc2libGUsIE1hcmtlclR5cGUsIGNyZWF0ZU1hcmtlcklkcywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0QmV6aWVyUGF0aCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldE1hcmtlcklkLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBDb25uZWN0aW9uTGluZVR5cGUsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIGFkb3B0VXNlck5vZGVzLCBpbml0aWFsQ29ubmVjdGlvbiwgZGV2V2FybiwgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgdXBkYXRlTm9kZUludGVybmFscywgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIGhhbmRsZUV4cGFuZFBhcmVudCwgcGFuQnksIGZpdFZpZXdwb3J0LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBhZGRFZGdlLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0RWRnZUNlbnRlciwgZ2V0SW5jb21lcnMsIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHJlY29ubmVjdEVkZ2UgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuLCBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIkMSA9IFN0b3JlQ29udGV4dC5Qcm92aWRlcjtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbi8qKlxuICogVGhpcyBob29rIGNhbiBiZSB1c2VkIHRvIHN1YnNjcmliZSB0byBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBSZWFjdCBGbG93XG4gKiBjb21wb25lbnQuIFRoZSBgdXNlU3RvcmVgIGhvb2sgaXMgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgW1p1c3RhbmRdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZClcbiAqIHN0YXRlIG1hbmFnZW1lbnQgbGlicmFyeSwgc28geW91IHNob3VsZCBjaGVjayBvdXQgdGhlaXIgZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzZWxlY3RvciAtIEEgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2xpY2Ugb2YgdGhlIGZsb3cncyBpbnRlcm5hbCBzdGF0ZS5cbiAqIEV4dHJhY3Rpbmcgb3IgdHJhbnNmb3JtaW5nIGp1c3QgdGhlIHN0YXRlIHlvdSBuZWVkIGlzIGEgZ29vZCBwcmFjdGljZSB0byBhdm9pZCB1bm5lY2Vzc2FyeVxuICogcmUtcmVuZGVycy5cbiAqIEBwYXJhbSBlcXVhbGl0eUZuIC0gQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCB2YWx1ZS4gVGhpcyBpcyBpbmNyZWRpYmx5IHVzZWZ1bFxuICogZm9yIHByZXZlbnRpbmcgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy4gR29vZCBzZW5zaWJsZSBkZWZhdWx0cyBhcmUgdXNpbmcgYE9iamVjdC5pc2Agb3IgaW1wb3J0aW5nXG4gKiBgenVzdGFuZC9zaGFsbG93YCwgYnV0IHlvdSBjYW4gYmUgYXMgZ3JhbnVsYXIgYXMgeW91IGxpa2UuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgc3RhdGUgc2xpY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBub2RlcyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUubm9kZXMpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuLyoqXG4gKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBhY2Nlc3MgdGhlIHN0b3JlIGRpcmVjdGx5LiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgc3RvcmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIG9uIGRlbWFuZCB0byBhY2Nlc3MgdGhlIHN0YXRlIG9yIGRpc3BhdGNoIGFjdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIHN0b3JlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmVBcGkoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgIH0pLCBbc3RvcmVdKTtcbn1cblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBhcmlhTGl2ZVNlbGVjdG9yID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuY29uc3QgYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IgPSAocykgPT4gcy5hcmlhTGFiZWxDb25maWc7XG5mdW5jdGlvbiBBcmlhTGl2ZU1lc3NhZ2UoeyByZklkIH0pIHtcbiAgICBjb25zdCBhcmlhTGl2ZU1lc3NhZ2UgPSB1c2VTdG9yZShhcmlhTGl2ZVNlbGVjdG9yKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0xJVkVfTUVTU0FHRX0tJHtyZklkfWAsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIsIHN0eWxlOiBhcmlhTGl2ZVN0eWxlLCBjaGlsZHJlbjogYXJpYUxpdmVNZXNzYWdlIH0pKTtcbn1cbmZ1bmN0aW9uIEExMXlEZXNjcmlwdGlvbnMoeyByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBhcmlhTGFiZWxDb25maWcgPSB1c2VTdG9yZShhcmlhTGFiZWxDb25maWdTZWxlY3Rvcik7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGRpc2FibGVLZXlib2FyZEExMXlcbiAgICAgICAgICAgICAgICAgICAgPyBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnXVxuICAgICAgICAgICAgICAgICAgICA6IGFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24ua2V5Ym9hcmREaXNhYmxlZCddIH0pLCBqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogYXJpYUxhYmVsQ29uZmlnWydlZGdlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0J10gfSksICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGpzeChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KV0gfSkpO1xufVxuXG4vKipcbiAqIFRoZSBgPFBhbmVsIC8+YCBjb21wb25lbnQgaGVscHMgeW91IHBvc2l0aW9uIGNvbnRlbnQgYWJvdmUgdGhlIHZpZXdwb3J0LlxuICogSXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbYDxNaW5pTWFwIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9taW5pbWFwKVxuICogYW5kIFtgPENvbnRyb2xzIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9scykgY29tcG9uZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIEJhY2tncm91bmQsIFBhbmVsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbXX0gZml0Vmlldz5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLWxlZnRcIj50b3AtbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1jZW50ZXJcIj50b3AtY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLXJpZ2h0XCI+dG9wLXJpZ2h0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLWxlZnRcIj5ib3R0b20tbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1jZW50ZXJcIj5ib3R0b20tY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLXJpZ2h0XCI+Ym90dG9tLXJpZ2h0PC9QYW5lbD5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IFBhbmVsID0gZm9yd2FyZFJlZigoeyBwb3NpdGlvbiA9ICd0b3AtbGVmdCcsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCAuLi5yZXN0IH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lbCcsIGNsYXNzTmFtZSwgLi4ucG9zaXRpb25DbGFzc2VzXSksIHN0eWxlOiBzdHlsZSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59KTtcblBhbmVsLmRpc3BsYXlOYW1lID0gJ1BhbmVsJztcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBwcm9PcHRpb25zLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnIH0pIHtcbiAgICBpZiAocHJvT3B0aW9ucz8uaGlkZUF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hdHRyaWJ1dGlvblwiLCBcImRhdGEtbWVzc2FnZVwiOiBcIlBsZWFzZSBvbmx5IGhpZGUgdGhpcyBhdHRyaWJ1dGlvbiB3aGVuIHlvdSBhcmUgc3Vic2NyaWJlZCB0byBSZWFjdCBGbG93IFBybzogaHR0cHM6Ly9wcm8ucmVhY3RmbG93LmRldlwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGhyZWY6IFwiaHR0cHM6Ly9yZWFjdGZsb3cuZGV2XCIsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiwgXCJhcmlhLWxhYmVsXCI6IFwiUmVhY3QgRmxvdyBhdHRyaWJ1dGlvblwiLCBjaGlsZHJlbjogXCJSZWFjdCBGbG93XCIgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRtID0gKHMpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gW107XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLnB1c2gobm9kZS5pbnRlcm5hbHMudXNlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgZWRnZV0gb2Ygcy5lZGdlTG9va3VwKSB7XG4gICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9O1xufTtcbmNvbnN0IHNlbGVjdElkID0gKG9iaikgPT4gb2JqLmlkO1xuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoc2hhbGxvdyhhLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCkpICYmXG4gICAgICAgIHNoYWxsb3coYS5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpKSk7XG59XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcklubmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRtLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZm9yRWFjaCgoZm4pID0+IGZuKHBhcmFtcykpO1xuICAgIH0sIFtzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzLCBvblNlbGVjdGlvbkNoYW5nZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM7XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IHVzZVN0b3JlKGNoYW5nZVNlbGVjdG9yKTtcbiAgICBpZiAob25TZWxlY3Rpb25DaGFuZ2UgfHwgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycykge1xuICAgICAgICByZXR1cm4ganN4KFNlbGVjdGlvbkxpc3RlbmVySW5uZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZGVmYXVsdE5vZGVPcmlnaW4gPSBbMCwgMF07XG5jb25zdCBkZWZhdWx0Vmlld3BvcnQgPSB7IHg6IDAsIHk6IDAsIHpvb206IDEgfTtcblxuLypcbiAqIFRoaXMgY29tcG9uZW50IGhlbHBzIHVzIHRvIHVwZGF0ZSB0aGUgc3RvcmUgd2l0aCB0aGUgdmFsdWVzIGNvbWluZyBmcm9tIHRoZSB1c2VyLlxuICogV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB2YWx1ZXMgd2UgY2FuIHVwZGF0ZSBkaXJlY3RseSB3aXRoIGB1c2VEaXJlY3RTdG9yZVVwZGF0ZXJgIChsaWtlIGBzbmFwR3JpZGApXG4gKiBhbmQgdmFsdWVzIHRoYXQgaGF2ZSBhIGRlZGljYXRlZCBzZXR0ZXIgZnVuY3Rpb24gaW4gdGhlIHN0b3JlIChsaWtlIGBzZXROb2Rlc2ApLlxuICovXG4vLyBUaGVzZSBmaWVsZHMgZXhpc3QgaW4gdGhlIGdsb2JhbCBzdG9yZSwgYW5kIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVwIHRvIGRhdGVcbmNvbnN0IHJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2sgPSBbXG4gICAgJ25vZGVzJyxcbiAgICAnZWRnZXMnLFxuICAgICdkZWZhdWx0Tm9kZXMnLFxuICAgICdkZWZhdWx0RWRnZXMnLFxuICAgICdvbkNvbm5lY3QnLFxuICAgICdvbkNvbm5lY3RTdGFydCcsXG4gICAgJ29uQ29ubmVjdEVuZCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0U3RhcnQnLFxuICAgICdvbkNsaWNrQ29ubmVjdEVuZCcsXG4gICAgJ25vZGVzRHJhZ2dhYmxlJyxcbiAgICAnYXV0b1Bhbk9uTm9kZUZvY3VzJyxcbiAgICAnbm9kZXNDb25uZWN0YWJsZScsXG4gICAgJ25vZGVzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc1JlY29ubmVjdGFibGUnLFxuICAgICdlbGV2YXRlTm9kZXNPblNlbGVjdCcsXG4gICAgJ2VsZXZhdGVFZGdlc09uU2VsZWN0JyxcbiAgICAnbWluWm9vbScsXG4gICAgJ21heFpvb20nLFxuICAgICdub2RlRXh0ZW50JyxcbiAgICAnb25Ob2Rlc0NoYW5nZScsXG4gICAgJ29uRWRnZXNDaGFuZ2UnLFxuICAgICdlbGVtZW50c1NlbGVjdGFibGUnLFxuICAgICdjb25uZWN0aW9uTW9kZScsXG4gICAgJ3NuYXBHcmlkJyxcbiAgICAnc25hcFRvR3JpZCcsXG4gICAgJ3RyYW5zbGF0ZUV4dGVudCcsXG4gICAgJ2Nvbm5lY3RPbkNsaWNrJyxcbiAgICAnZGVmYXVsdEVkZ2VPcHRpb25zJyxcbiAgICAnZml0VmlldycsXG4gICAgJ2ZpdFZpZXdPcHRpb25zJyxcbiAgICAnb25Ob2Rlc0RlbGV0ZScsXG4gICAgJ29uRWRnZXNEZWxldGUnLFxuICAgICdvbkRlbGV0ZScsXG4gICAgJ29uTm9kZURyYWcnLFxuICAgICdvbk5vZGVEcmFnU3RhcnQnLFxuICAgICdvbk5vZGVEcmFnU3RvcCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZycsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0YXJ0JyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RvcCcsXG4gICAgJ29uTW92ZVN0YXJ0JyxcbiAgICAnb25Nb3ZlJyxcbiAgICAnb25Nb3ZlRW5kJyxcbiAgICAnbm9QYW5DbGFzc05hbWUnLFxuICAgICdub2RlT3JpZ2luJyxcbiAgICAnYXV0b1Bhbk9uQ29ubmVjdCcsXG4gICAgJ2F1dG9QYW5Pbk5vZGVEcmFnJyxcbiAgICAnb25FcnJvcicsXG4gICAgJ2Nvbm5lY3Rpb25SYWRpdXMnLFxuICAgICdpc1ZhbGlkQ29ubmVjdGlvbicsXG4gICAgJ3NlbGVjdE5vZGVzT25EcmFnJyxcbiAgICAnbm9kZURyYWdUaHJlc2hvbGQnLFxuICAgICdjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCcsXG4gICAgJ29uQmVmb3JlRGVsZXRlJyxcbiAgICAnZGVidWcnLFxuICAgICdhdXRvUGFuU3BlZWQnLFxuICAgICdwYW5lQ2xpY2tEaXN0YW5jZScsXG4gICAgJ2FyaWFMYWJlbENvbmZpZycsXG5dO1xuLy8gcmZJZCBkb2Vzbid0IGV4aXN0IGluIFJlYWN0Rmxvd1Byb3BzLCBidXQgaXQncyBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB3YW50IHRvIHVwZGF0ZVxuY29uc3QgZmllbGRzVG9UcmFjayA9IFsuLi5yZWFjdEZsb3dGaWVsZHNUb1RyYWNrLCAncmZJZCddO1xuY29uc3Qgc2VsZWN0b3IkbCA9IChzKSA9PiAoe1xuICAgIHNldE5vZGVzOiBzLnNldE5vZGVzLFxuICAgIHNldEVkZ2VzOiBzLnNldEVkZ2VzLFxuICAgIHNldE1pblpvb206IHMuc2V0TWluWm9vbSxcbiAgICBzZXRNYXhab29tOiBzLnNldE1heFpvb20sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiBzLnNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICBzZXROb2RlRXh0ZW50OiBzLnNldE5vZGVFeHRlbnQsXG4gICAgcmVzZXQ6IHMucmVzZXQsXG4gICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IHMuc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsXG4gICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IHMuc2V0UGFuZUNsaWNrRGlzdGFuY2UsXG59KTtcbmNvbnN0IGluaXRQcmV2VmFsdWVzID0ge1xuICAgIC8qXG4gICAgICogdGhlc2UgYXJlIHZhbHVlcyB0aGF0IGFyZSBhbHNvIHBhc3NlZCBkaXJlY3RseSB0byBvdGhlciBjb21wb25lbnRzXG4gICAgICogdGhhbiB0aGUgU3RvcmVVcGRhdGVyLiBXZSBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2V0U3RvcmUgY2FsbHNcbiAgICAgKiBieSBzZXR0aW5nIHRoZSBzYW1lIHZhbHVlcyBoZXJlIGFzIHByZXYgZmllbGRzLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZU9yaWdpbjogZGVmYXVsdE5vZGVPcmlnaW4sXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgIHJmSWQ6ICcxJyxcbiAgICBwYW5lQ2xpY2tEaXN0YW5jZTogMCxcbn07XG5mdW5jdGlvbiBTdG9yZVVwZGF0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0TWluWm9vbSwgc2V0TWF4Wm9vbSwgc2V0VHJhbnNsYXRlRXh0ZW50LCBzZXROb2RlRXh0ZW50LCByZXNldCwgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldFBhbmVDbGlja0Rpc3RhbmNlLCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKHByb3BzLmRlZmF1bHROb2RlcywgcHJvcHMuZGVmYXVsdEVkZ2VzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzZXQgdGhlIHN0b3JlIHdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXMgZmllbGRzXG4gICAgICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gaW5pdFByZXZWYWx1ZXM7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBwcmV2aW91c0ZpZWxkcyA9IHVzZVJlZihpbml0UHJldlZhbHVlcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZmllbGRzVG9UcmFjaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHByb3BzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkVmFsdWUgPSBwcmV2aW91c0ZpZWxkcy5jdXJyZW50W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gcHJldmlvdXNGaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tmaWVsZE5hbWVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBoYW5kbGluZyB3aXRoIGRlZGljYXRlZCBzZXR0ZXJzIGZvciBzb21lIGZpZWxkc1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVzJylcbiAgICAgICAgICAgICAgICBzZXROb2RlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2VkZ2VzJylcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21pblpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1pblpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtYXhab29tJylcbiAgICAgICAgICAgICAgICBzZXRNYXhab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHJhbnNsYXRlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdub2RlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXROb2RlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAncGFuZUNsaWNrRGlzdGFuY2UnKVxuICAgICAgICAgICAgICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnYXJpYUxhYmVsQ29uZmlnJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGFyaWFMYWJlbENvbmZpZzogbWVyZ2VBcmlhTGFiZWxDb25maWcoZmllbGRWYWx1ZSkgfSk7XG4gICAgICAgICAgICAvLyBSZW5hbWVkIGZpZWxkc1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0VmlldycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0Vmlld09wdGlvbnMnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09wdGlvbnM6IGZpZWxkVmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBwcm9wcztcbiAgICB9LCBcbiAgICAvLyBPbmx5IHJlLXJ1biB0aGUgZWZmZWN0IGlmIG9uZSBvZiB0aGUgZmllbGRzIHdlIHRyYWNrIGNoYW5nZXNcbiAgICBmaWVsZHNUb1RyYWNrLm1hcCgoZmllbGROYW1lKSA9PiBwcm9wc1tmaWVsZE5hbWVdKSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1lZGlhUXVlcnkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG59XG4vKipcbiAqIEhvb2sgZm9yIHJlY2VpdmluZyB0aGUgY3VycmVudCBjb2xvciBtb2RlIGNsYXNzICdkYXJrJyBvciAnbGlnaHQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbG9yTW9kZSAtIFRoZSBjb2xvciBtb2RlIHRvIHVzZSAoJ2RhcmsnLCAnbGlnaHQnIG9yICdzeXN0ZW0nKVxuICovXG5mdW5jdGlvbiB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpIHtcbiAgICBjb25zdCBbY29sb3JNb2RlQ2xhc3MsIHNldENvbG9yTW9kZUNsYXNzXSA9IHVzZVN0YXRlKGNvbG9yTW9kZSA9PT0gJ3N5c3RlbScgPyBudWxsIDogY29sb3JNb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29sb3JNb2RlICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgc2V0Q29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gZ2V0TWVkaWFRdWVyeSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb2xvck1vZGVDbGFzcyA9ICgpID0+IHNldENvbG9yTW9kZUNsYXNzKG1lZGlhUXVlcnk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgdXBkYXRlQ29sb3JNb2RlQ2xhc3MoKTtcbiAgICAgICAgbWVkaWFRdWVyeT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjb2xvck1vZGVdKTtcbiAgICByZXR1cm4gY29sb3JNb2RlQ2xhc3MgIT09IG51bGwgPyBjb2xvck1vZGVDbGFzcyA6IGdldE1lZGlhUXVlcnkoKT8ubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cbmNvbnN0IGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBzcGVjaWZpYyBrZXkgY29kZXMgYW5kIHRlbGxzIHlvdSB3aGV0aGVyIHRoZXkgYXJlXG4gKiBjdXJyZW50bHkgcHJlc3NlZCBvciBub3QuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VLZXlQcmVzcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IHNwYWNlUHJlc3NlZCA9IHVzZUtleVByZXNzKCdTcGFjZScpO1xuICogIGNvbnN0IGNtZEFuZFNQcmVzc2VkID0gdXNlS2V5UHJlc3MoWydNZXRhK3MnLCAnU3RyZytzJ10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICB7c3BhY2VQcmVzc2VkICYmIDxwPlNwYWNlIHByZXNzZWQhPC9wPn1cbiAqICAgICB7Y21kQW5kU1ByZXNzZWQgJiYgPHA+Q21kICsgUyBwcmVzc2VkITwvcD59XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VLZXlQcmVzcyhcbi8qKlxuICogVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgc3BlY2lmaWVzIHdoaWNoIGtleShzKSBzaG91bGQgdHJpZ2dlclxuICogYW4gYWN0aW9uLlxuICpcbiAqIEEgKipzdHJpbmcqKiBjYW4gcmVwcmVzZW50OlxuICogLSBBICoqc2luZ2xlIGtleSoqLCBlLmcuIGAnYSdgXG4gKiAtIEEgKiprZXkgY29tYmluYXRpb24qKiwgdXNpbmcgYCcrJ2AgdG8gc2VwYXJhdGUga2V5cywgZS5nLiBgJ2ErZCdgXG4gKlxuICogQW4gICoqYXJyYXkgb2Ygc3RyaW5ncyoqIHJlcHJlc2VudHMgKiptdWx0aXBsZSBwb3NzaWJsZSBrZXkgaW5wdXRzKiouIEZvciBleGFtcGxlLCBgWydhJywgJ2QrcyddYFxuICogbWVhbnMgdGhlIHVzZXIgY2FuIHByZXNzIGVpdGhlciB0aGUgc2luZ2xlIGtleSBgJ2EnYCBvciB0aGUgY29tYmluYXRpb24gb2YgYCdkJ2AgYW5kIGAncydgLlxuICogQGRlZmF1bHQgbnVsbFxuICovXG5rZXlDb2RlID0gbnVsbCwgb3B0aW9ucyA9IHsgdGFyZ2V0OiBkZWZhdWx0RG9jLCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogdHJ1ZSB9KSB7XG4gICAgY29uc3QgW2tleVByZXNzZWQsIHNldEtleVByZXNzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaWYgYSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZCBpbiBvcmRlciB0byB0cmFjayBpdFxuICAgIGNvbnN0IG1vZGlmaWVyUHJlc3NlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciB0aGUgcHJlc3NlZCBrZXlzIGluIG9yZGVyIHRvIHN1cHBvcnQgY29tYmluYXRpb25zXG4gICAgY29uc3QgcHJlc3NlZEtleXMgPSB1c2VSZWYobmV3IFNldChbXSkpO1xuICAgIC8qXG4gICAgICoga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAgKiBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgICogdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgICAqIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgICAqIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAgKiB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgICAqL1xuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2UgZmlyc3QgcmVwbGFjZSBhbGwgJysnIHdpdGggJ1xcbicgIHdoaWNoIHdlIHdpbGwgdXNlIHRvIHNwbGl0IHRoZSBrZXlzIG9uXG4gICAgICAgICAgICAgICAgICogdGhlbiB3ZSByZXBsYWNlICdcXG5cXG4nIHdpdGggJ1xcbisnLCB0aGlzIHdheSB3ZSBjYW4gYWxzbyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiAna2V5KysnXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIGVuZCB3ZSBzaW1wbHkgc3BsaXQgb24gJ1xcbicgdG8gZ2V0IHRoZSBrZXkgYXJyYXlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAubWFwKChrYykgPT4ga2MucmVwbGFjZSgnKycsICdcXG4nKS5yZXBsYWNlKCdcXG5cXG4nLCAnXFxuKycpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzRmxhdCA9IGtleXMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHJlcy5jb25jYXQoLi4uaXRlbSksIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5cywga2V5c0ZsYXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICB9LCBba2V5Q29kZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnM/LnRhcmdldCA/PyBkZWZhdWx0RG9jO1xuICAgICAgICBjb25zdCBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA9IG9wdGlvbnM/LmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyID8/IHRydWU7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIWFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmFkZChldmVudFtrZXlPckNvZGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQlVUVE9OJyB8fCB0YXJnZXQ/Lm5vZGVOYW1lID09PSAnQSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREZWZhdWx0ICE9PSBmYWxzZSAmJiAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgIWlzSW50ZXJhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLypcbiAgICAgICAgICogd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgICAqIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgICogdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAgKi9cbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLypcbiAgICAgICAgICogc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgICAqIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHVzZVZpZXdwb3J0SGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6b29tSW46IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEgLyAxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tVG86ICh6b29tTGV2ZWwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlVG8oem9vbUxldmVsLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Wm9vbTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICBzZXRWaWV3cG9ydDogYXN5bmMgKHZpZXdwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IFt0WCwgdFksIHRab29tXSwgcGFuWm9vbSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdmlld3BvcnQueCA/PyB0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdmlld3BvcnQueSA/PyB0WSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmlld3BvcnQuem9vbSA/PyB0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgem9vbSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5zZXRDZW50ZXIoeCwgeSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0Qm91bmRzOiBhc3luYyAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBvcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuVG9GbG93UG9zaXRpb246IChjbGllbnRQb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2xpZW50UG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsaWVudFBvc2l0aW9uLnkgLSBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBHcmlkID0gb3B0aW9ucy5zbmFwR3JpZCA/PyBzbmFwR3JpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBfc25hcFRvR3JpZCA9IG9wdGlvbnMuc25hcFRvR3JpZCA/PyBzbmFwVG9HcmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChjb3JyZWN0ZWRQb3NpdGlvbiwgdHJhbnNmb3JtLCBfc25hcFRvR3JpZCwgX3NuYXBHcmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93VG9TY3JlZW5Qb3NpdGlvbjogKGZsb3dQb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQb3NpdGlvbiA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGZsb3dQb3NpdGlvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiByZW5kZXJlclBvc2l0aW9uLnkgKyBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgY2hhbmdlcyB0byBub2RlcyBvciBlZGdlcyB0aGF0IGFyZSB0cmlnZ2VyZWQgYnkgUmVhY3QgRmxvdyBpbnRlcm5hbGx5LlxuICogV2hlbiB5b3UgZHJhZyBhIG5vZGUgZm9yIGV4YW1wbGUsIFJlYWN0IEZsb3cgd2lsbCBzZW5kIGEgcG9zaXRpb24gY2hhbmdlIHVwZGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gdGhlbiBhcHBsaWVzIHRoZSBjaGFuZ2VzIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWxlbWVudHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBbXTtcbiAgICAvKlxuICAgICAqIEJ5IHN0b3JpbmcgYSBtYXAgb2YgY2hhbmdlcyBmb3IgZWFjaCBlbGVtZW50LCB3ZSBjYW4gYSBxdWljayBsb29rdXAgYXMgd2VcbiAgICAgKiBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIGFycmF5IVxuICAgICAqL1xuICAgIGNvbnN0IGNoYW5nZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkSXRlbUNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGFkZEl0ZW1DaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRm9yIGEgJ3JlbW92ZScgY2hhbmdlIHdlIGNhbiBzYWZlbHkgaWdub3JlIGFueSBvdGhlciBjaGFuZ2VzIHF1ZXVlZCBmb3JcbiAgICAgICAgICAgICAqIHRoZSBzYW1lIGVsZW1lbnQsIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZCBhbnl3YXkhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudENoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHNvbWUgY2hhbmdlcyBxdWV1ZWQgYWxyZWFkeSwgd2UgY2FuIGRvIGEgbXV0YWJsZSB1cGRhdGUgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGFycmF5IGFuZCBzYXZlIG91cnNlbHZlcyBzb21lIGNvcHlpbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxlbWVudENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc01hcC5zZXQoY2hhbmdlLmlkLCBbY2hhbmdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChlbGVtZW50LmlkKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2hlbiB0aGVyZSBhcmUgbm8gY2hhbmdlcyBmb3IgYW4gZWxlbWVudCB3ZSBjYW4ganVzdCBwdXNoIGl0IHVubW9kaWZpZWQsXG4gICAgICAgICAqIG5vIG5lZWQgdG8gY29weSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgJ3JlbW92ZScgY2hhbmdlIHF1ZXVlZCwgaXQnbGwgYmUgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZXNbMF0uaXRlbSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igb3RoZXIgdHlwZXMgb2YgY2hhbmdlcywgd2Ugd2FudCB0byBzdGFydCB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIHRoZVxuICAgICAgICAgKiBvYmplY3Qgc28gUmVhY3Qga25vd3MgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkLiBTZXF1ZW50aWFsIGNoYW5nZXMgd2lsbFxuICAgICAgICAgKiBlYWNoIF9tdXRhdGVfIHRoaXMgb2JqZWN0LCBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUgY29weS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlKGNoYW5nZSwgdXBkYXRlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHVwZGF0ZWRFbGVtZW50KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiB3ZSBuZWVkIHRvIHdhaXQgZm9yIGFsbCBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgYmVmb3JlIGFkZGluZyBuZXcgaXRlbXNcbiAgICAgKiB0byBiZSBhYmxlIHRvIGFkZCB0aGVtIGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICovXG4gICAgaWYgKGFkZEl0ZW1DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICBhZGRJdGVtQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5zcGxpY2UoY2hhbmdlLmluZGV4LCAwLCB7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRWxlbWVudHM7XG59XG4vLyBBcHBsaWVzIGEgc2luZ2xlIGNoYW5nZSB0byBhbiBlbGVtZW50LiBUaGlzIGlzIGEgKm11dGFibGUqIHVwZGF0ZS5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlKGNoYW5nZSwgZWxlbWVudCkge1xuICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZCA9IGNoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IGNoYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZHJhZ2dpbmcgPSBjaGFuZ2UuZHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZGltZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkID8/PSB7fTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkLndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gdHJ1ZSB8fCBjaGFuZ2Uuc2V0QXR0cmlidXRlcyA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucmVzaXppbmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXppbmcgPSBjaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgbm9kZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIG5vZGVzIC0gQXJyYXkgb2Ygbm9kZXMgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIG5vZGVzLlxuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseU5vZGVDaGFuZ2VzLCB0eXBlIE5vZGUsIHR5cGUgRWRnZSwgdHlwZSBPbk5vZGVzQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGU8Tm9kZVtdPihbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZTxFZGdlW10+KFtdKTtcbiAqICBjb25zdCBvbk5vZGVzQ2hhbmdlOiBPbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gKiAgICAoY2hhbmdlcykgPT4ge1xuICogICAgICBzZXROb2Rlcygob2xkTm9kZXMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgb2xkTm9kZXMpKTtcbiAqICAgIH0sXG4gKiAgICBbc2V0Tm9kZXNdLFxuICogICk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtub2Rlc30gZWRnZXM9e2VkZ2VzfSBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfSAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIE5vZGVDaGFuZ2V9XG4gKiB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXlcbiAqIG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBlZGdlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2YgZWRnZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHkuXG4gKiBAcGFyYW0gZWRnZXMgLSBBcnJheSBvZiBlZGdlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBlZGdlcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIGFwcGx5RWRnZUNoYW5nZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0RWRnZXMoKG9sZEVkZ2VzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIG9sZEVkZ2VzKSk7XG4gKiAgICB9LFxuICogICAgW3NldEVkZ2VzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBFZGdlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpZCwgc2VsZWN0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25DaGFuZ2VzKGl0ZW1zLCBzZWxlY3RlZElkcyA9IG5ldyBTZXQoKSwgbXV0YXRlSXRlbSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiBpdGVtcykge1xuICAgICAgICBjb25zdCB3aWxsQmVTZWxlY3RlZCA9IHNlbGVjdGVkSWRzLmhhcyhpZCk7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc2V0IGFsbCBpdGVtcyB0byBzZWxlY3RlZD1mYWxzZSBvbiB0aGUgZmlyc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmICghKGl0ZW0uc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCAmJiAhd2lsbEJlU2VsZWN0ZWQpICYmIGl0ZW0uc2VsZWN0ZWQgIT09IHdpbGxCZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRlSXRlbSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdGhpcyBoYWNrIGlzIG5lZWRlZCBmb3Igbm9kZXMuIFdoZW4gdGhlIHVzZXIgZHJhZ2dlZCBhIG5vZGUsIGl0J3Mgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgICogV2hlbiBhbm90aGVyIG5vZGUgZ2V0cyBkcmFnZ2VkLCB3ZSBuZWVkIHRvIGRlc2VsZWN0IHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gaGF2ZSBvbmx5IG9uZSBzZWxlY3RlZCBub2RlIGF0IGEgdGltZSAtIHRoZSBvbk5vZGVzQ2hhbmdlIGNhbGxiYWNrIGNvbWVzIHRvbyBsYXRlIGhlcmUgOi9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gd2lsbEJlU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGl0ZW0uaWQsIHdpbGxCZVNlbGVjdGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHsgaXRlbXMgPSBbXSwgbG9va3VwLCB9KSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGl0ZW1zTG9va3VwID0gbmV3IE1hcChpdGVtcy5tYXAoKGl0ZW0pID0+IFtpdGVtLmlkLCBpdGVtXSkpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgbG9va3VwSXRlbSA9IGxvb2t1cC5nZXQoaXRlbS5pZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlSXRlbSA9IGxvb2t1cEl0ZW0/LmludGVybmFscz8udXNlck5vZGUgPz8gbG9va3VwSXRlbTtcbiAgICAgICAgaWYgKHN0b3JlSXRlbSAhPT0gdW5kZWZpbmVkICYmIHN0b3JlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQ6IGl0ZW0uaWQsIGl0ZW06IGl0ZW0sIHR5cGU6ICdyZXBsYWNlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGl0ZW06IGl0ZW0sIHR5cGU6ICdhZGQnLCBpbmRleCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZF0gb2YgbG9va3VwKSB7XG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gaXRlbXNMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkLCB0eXBlOiAncmVtb3ZlJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRUb1JlbW92ZUNoYW5nZShpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgIH07XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BOb2RlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvbm9kZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0LlxuICogQHJldHVybnMgVGVzdHMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYSBgTm9kZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBOb2RlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzTm9kZShub2RlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiBpc05vZGVCYXNlKGVsZW1lbnQpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhbiBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKS5cbiAqIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0b1xuICogW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgaWYgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGBFZGdlYC4gSWYgeW91J3JlIHVzaW5nIFR5cGVTY3JpcHQsXG4gKiB0aGlzIGZ1bmN0aW9uIGFjdHMgYXMgYSB0eXBlIGd1YXJkIGFuZCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYEVkZ2VgIGlmIGl0IHJldHVybnNcbiAqIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgaXNFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICppZiAoaXNFZGdlKGVkZ2UpKSB7XG4gKiAvLyAuLi5cbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgaXNFZGdlID0gKGVsZW1lbnQpID0+IGlzRWRnZUJhc2UoZWxlbWVudCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlXG5mdW5jdGlvbiBmaXhlZEZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZm9yd2FyZFJlZihyZW5kZXIpO1xufVxuXG4vLyB3ZSBuZWVkIHRoaXMgaG9vayB0byBwcmV2ZW50IGEgd2FybmluZyB3aGVuIHVzaW5nIHJlYWN0LWZsb3cgaW4gU1NSXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBxdWV1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHJ1blF1ZXVlIC0gYSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGZsdXNoZWRcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEByZXR1cm5zIGEgUXVldWUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXVlKHJ1blF1ZXVlKSB7XG4gICAgLypcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIHVzaW5nIGEgcmVmIGFib3ZlLCB3ZSBuZWVkIHNvbWUgd2F5IHRvIGxldCBSZWFjdCBrbm93IHdoZW4gdG9cbiAgICAgKiBhY3R1YWxseSBwcm9jZXNzIHRoZSBxdWV1ZS4gV2UgaW5jcmVtZW50IHRoaXMgbnVtYmVyIGFueSB0aW1lIHdlIG11dGF0ZSB0aGVcbiAgICAgKiBxdWV1ZSwgY3JlYXRpbmcgYSBuZXcgc3RhdGUgdG8gdHJpZ2dlciB0aGUgbGF5b3V0IGVmZmVjdCBiZWxvdy5cbiAgICAgKiBVc2luZyBhIGJvb2xlYW4gZGlydHkgZmxhZyBoZXJlIGluc3RlYWQgd291bGQgbGVhZCB0byBpc3N1ZXMgcmVsYXRlZCB0b1xuICAgICAqIGF1dG9tYXRpYyBiYXRjaGluZy4gKGh0dHBzOi8vZ2l0aHViLmNvbS94eWZsb3cveHlmbG93L2lzc3Vlcy80Nzc5KVxuICAgICAqL1xuICAgIGNvbnN0IFtzZXJpYWwsIHNldFNlcmlhbF0gPSB1c2VTdGF0ZShCaWdJbnQoMCkpO1xuICAgIC8qXG4gICAgICogQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgICAqIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAgKiBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAqL1xuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTZXJpYWwobiA9PiBuICsgQmlnSW50KDEpKSkpO1xuICAgIC8qXG4gICAgICogTGF5b3V0IGVmZmVjdHMgYXJlIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgd2hpY2ggbWVhbnMgd2VcbiAgICAgKiBzaG91bGRuJ3QgcnVuIGludG8gYW55IGlzc3VlcyB3aXRoIHN0YWxlIHN0YXRlIG9yIHdlaXJkIGlzc3VlcyB0aGF0IGNvbWUgZnJvbVxuICAgICAqIHJlbmRlcmluZyB0aGluZ3Mgb25lIGZyYW1lIGxhdGVyIHRoYW4gZXhwZWN0ZWQgKHdlIHVzZWQgdG8gdXNlIGBzZXRUaW1lb3V0YCkuXG4gICAgICovXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbXMgPSBxdWV1ZS5nZXQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5RdWV1ZShxdWV1ZUl0ZW1zKTtcbiAgICAgICAgICAgIHF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2VyaWFsXSk7XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVldWUoY2IpIHtcbiAgICBsZXQgcXVldWUgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlLFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IEJhdGNoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgaXMgYSBjb250ZXh0IHByb3ZpZGVyIHRoYXQgaG9sZHMgYW5kIHByb2Nlc3NlcyB0aGUgbm9kZSBhbmQgZWRnZSB1cGRhdGUgcXVldWVzXG4gKiB0aGF0IGFyZSBuZWVkZWQgdG8gaGFuZGxlIHNldE5vZGVzLCBhZGROb2Rlcywgc2V0RWRnZXMgYW5kIGFkZEVkZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBCYXRjaFByb3ZpZGVyKHsgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSwgbm9kZUxvb2t1cCwgZml0Vmlld1F1ZXVlZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhbiBgQXJyYXkucmVkdWNlYCBpbiBpbXBlcmF0aXZlIGNsb3RoaW5nLiBQcm9jZXNzaW5nXG4gICAgICAgICAqIHRoaXMgcXVldWUgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoIHNvIHdlJ2QgbGlrZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWQgb2ZcbiAgICAgICAgICogYXJyYXkgbWV0aG9kcyB3aGVyZSB3ZSBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICBsb29rdXA6IG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRGVmYXVsdE5vZGVzKSB7XG4gICAgICAgICAgICBzZXROb2RlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZmlyZSBvbk5vZGVzQ2hhbmdlIGlmIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIHRoZSBub2Rlc1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNoYW5nZXMgdG8gdGhlIG5vZGVzLCB3ZSBzdGlsbCBuZWVkIHRvIGNhbGwgc2V0Tm9kZXNcbiAgICAgICAgICAgIC8vIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgYW5kIGZpdFZpZXcuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpdFZpZXdRdWV1ZWQsIG5vZGVzLCBzZXROb2RlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIFJlYWN0Rmxvd0luc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIG5vZGVzIGFuZCBlZGdlcywgbWFuaXB1bGF0ZSB0aGUgdmlld3BvcnQsIG9yIHF1ZXJ5IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBOb2RlQ291bnRlcigpIHtcbiAqICBjb25zdCByZWFjdEZsb3cgPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IGNvdW50Tm9kZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgICBzZXRDb3VudChyZWFjdEZsb3cuZ2V0Tm9kZXMoKS5sZW5ndGgpO1xuICogICAgLy8geW91IG5lZWQgdG8gcGFzcyBpdCBhcyBhIGRlcGVuZGVuY3kgaWYgeW91IGFyZSB1c2luZyBpdCB3aXRoIHVzZUVmZmVjdCBvciB1c2VDYWxsYmFja1xuICogICAgLy8gYmVjYXVzZSBhdCB0aGUgZmlyc3QgcmVuZGVyLCBpdCdzIG5vdCBpbml0aWFsaXplZCB5ZXQgYW5kIHNvbWUgZnVuY3Rpb25zIG1pZ2h0IG5vdCB3b3JrLlxuICogIH0sIFtyZWFjdEZsb3ddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxidXR0b24gb25DbGljaz17Y291bnROb2Rlc30+VXBkYXRlIGNvdW50PC9idXR0b24+XG4gKiAgICAgIDxwPlRoZXJlIGFyZSB7Y291bnR9IG5vZGVzIGluIHRoZSBmbG93LjwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVJlYWN0RmxvdygpIHtcbiAgICBjb25zdCB2aWV3cG9ydEhlbHBlciA9IHVzZVZpZXdwb3J0SGVscGVyKCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUJhdGNoQ29udGV4dCgpO1xuICAgIGNvbnN0IHZpZXdwb3J0SW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciRrKTtcbiAgICBjb25zdCBnZW5lcmFsSGVscGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEludGVybmFsTm9kZSA9IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHNldE5vZGVzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0RWRnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0LmVkZ2VRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXROb2RlUmVjdCA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlVG9Vc2UgPSBpc05vZGUobm9kZSkgPyBub2RlIDogbm9kZUxvb2t1cC5nZXQobm9kZS5pZCk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGVUb1VzZS5wYXJlbnRJZFxuICAgICAgICAgICAgICAgID8gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKG5vZGVUb1VzZS5wb3NpdGlvbiwgbm9kZVRvVXNlLm1lYXN1cmVkLCBub2RlVG9Vc2UucGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pXG4gICAgICAgICAgICAgICAgOiBub2RlVG9Vc2UucG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBub2RlV2l0aFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGVUb1VzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVRvVXNlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlVG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlVG9Vc2UubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlVG9Vc2UuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlVG9SZWN0KG5vZGVXaXRoUG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVOb2RlID0gKGlkLCBub2RlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlcygocHJldk5vZGVzKSA9PiBwcmV2Tm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdHlwZW9mIG5vZGVVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBub2RlVXBkYXRlKG5vZGUpIDogbm9kZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc05vZGUobmV4dE5vZGUpID8gbmV4dE5vZGUgOiB7IC4uLm5vZGUsIC4uLm5leHROb2RlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVFZGdlID0gKGlkLCBlZGdlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXRFZGdlcygocHJldkVkZ2VzKSA9PiBwcmV2RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGdlID0gdHlwZW9mIGVkZ2VVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBlZGdlVXBkYXRlKGVkZ2UpIDogZWRnZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc0VkZ2UobmV4dEVkZ2UpID8gbmV4dEVkZ2UgOiB7IC4uLmVkZ2UsIC4uLm5leHRFZGdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Tm9kZXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGdldE5vZGU6IChpZCkgPT4gZ2V0SW50ZXJuYWxOb2RlKGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlLFxuICAgICAgICAgICAgZ2V0SW50ZXJuYWxOb2RlLFxuICAgICAgICAgICAgZ2V0RWRnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRnZTogKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmVkZ2VMb29rdXAuZ2V0KGlkKSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRFZGdlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaCgoZWRnZXMpID0+IFsuLi5lZGdlcywgLi4ubmV3RWRnZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b09iamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXSwgdHJhbnNmb3JtIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50czogYXN5bmMgKHsgbm9kZXM6IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXM6IGVkZ2VzVG9SZW1vdmUgPSBbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgZWRnZXMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBvbkRlbGV0ZSwgb25CZWZvcmVEZWxldGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0gPSBhd2FpdCBnZXRFbGVtZW50c1RvUmVtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZURlbGV0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0VkZ2VzID0gbWF0Y2hpbmdFZGdlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nTm9kZXMgPSBtYXRjaGluZ05vZGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBtYXRjaGluZ0VkZ2VzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4obWF0Y2hpbmdFZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbWF0Y2hpbmdOb2Rlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2Rlc0RlbGV0ZT8uKG1hdGNoaW5nTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2RlcyB8fCBoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlPy4oeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWROb2RlczogbWF0Y2hpbmdOb2RlcywgZGVsZXRlZEVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJ0aWFsIGlzIGRlZmluZWQgYXMgXCJ0aGUgMiBub2Rlcy9hcmVhcyBhcmUgaW50ZXJzZWN0aW5nIHBhcnRpYWxseVwiLlxuICAgICAgICAgICAgICogSWYgYSBpcyBjb250YWluZWQgaW4gYiBvciBiIGlzIGNvbnRhaW5lZCBpbiBhLCB0aGV5IGFyZSBib3RoXG4gICAgICAgICAgICAgKiBjb25zaWRlcmVkIGZ1bGx5IGludGVyc2VjdGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXM6IChub2RlT3JSZWN0LCBwYXJ0aWFsbHkgPSB0cnVlLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOb2Rlc09wdGlvbiA9IG5vZGVzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZXMgfHwgc3RvcmUuZ2V0U3RhdGUoKS5ub2RlcykuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUgJiYgIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZU9yUmVjdC5pZCB8fCAhaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3QoaGFzTm9kZXNPcHRpb24gPyBuIDogaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKGN1cnJOb2RlUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFydGlhbGx5VmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBcmVhID49IGN1cnJOb2RlUmVjdC53aWR0aCAqIGN1cnJOb2RlUmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNOb2RlSW50ZXJzZWN0aW5nOiAobm9kZU9yUmVjdCwgYXJlYSwgcGFydGlhbGx5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKG5vZGVSZWN0LCBhcmVhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJ0aWFsbHlWaXNpYmxlIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhLndpZHRoICogYXJlYS5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBcmVhID49IG5vZGVSZWN0LndpZHRoICogbm9kZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOb2RlLFxuICAgICAgICAgICAgdXBkYXRlTm9kZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGUoaWQsIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKG5vZGUpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4ubm9kZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4ubm9kZSwgZGF0YTogeyAuLi5ub2RlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVFZGdlLFxuICAgICAgICAgICAgdXBkYXRlRWRnZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2UoaWQsIChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKGVkZ2UpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4uZWRnZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4uZWRnZSwgZGF0YTogeyAuLi5lZGdlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROb2Rlc0JvdW5kczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2Rlc0JvdW5kcyhub2RlcywgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEhhbmRsZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBpZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICAgICAgZ2V0Tm9kZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBoYW5kbGVJZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9JHt0eXBlID8gKGhhbmRsZUlkID8gYC0ke3R5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHt0eXBlfWApIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGZpdFZpZXc6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGNyZWF0ZSBhIG5ldyBQcm9taXNlIG9yIHJldXNlIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIGZpdFZpZXcgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgcm93LCB3ZSBvbmx5IGVuZCB1cCB3aXRoIGEgc2luZ2xlIFByb21pc2VcbiAgICAgICAgICAgICAgICBjb25zdCBmaXRWaWV3UmVzb2x2ZXIgPSBzdG9yZS5nZXRTdGF0ZSgpLmZpdFZpZXdSZXNvbHZlciA/PyB3aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2NoZWR1bGUgYSBmaXRWaWV3IGJ5IHNldHRpbmcgZml0Vmlld1F1ZXVlZCBhbmQgdHJpZ2dlcmluZyBhIHNldE5vZGVzXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiB0cnVlLCBmaXRWaWV3T3B0aW9uczogb3B0aW9ucywgZml0Vmlld1Jlc29sdmVyIH0pO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2Rlc10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRWaWV3UmVzb2x2ZXIucHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmdlbmVyYWxIZWxwZXIsXG4gICAgICAgICAgICAuLi52aWV3cG9ydEhlbHBlcixcbiAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQsXG4gICAgICAgIH07XG4gICAgfSwgW3ZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0ZWQgPSAoaXRlbSkgPT4gaXRlbS5zZWxlY3RlZDtcbmNvbnN0IHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIGdsb2JhbCBrZXkgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiBmYWxzZSB9KTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4kMSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBub2Rlcy5maWx0ZXIoc2VsZWN0ZWQpLCBlZGdlczogZWRnZXMuZmlsdGVyKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc2l6ZUhhbmRsZXIoZG9tTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb21Ob2RlLmN1cnJlbnQgfHwgIShkb21Ob2RlLmN1cnJlbnQuY2hlY2tWaXNpYmlsaXR5Py4oKSA/PyB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXREaW1lbnNpb25zKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgPT09IDAgfHwgc2l6ZS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDQnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNCddKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB3aWR0aDogc2l6ZS53aWR0aCB8fCA1MDAsIGhlaWdodDogc2l6ZS5oZWlnaHQgfHwgNTAwIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB1cGRhdGVEaW1lbnNpb25zKCkpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU9ic2VydmVyICYmIGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5jb25zdCBjb250YWluZXJTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxufTtcblxuY29uc3Qgc2VsZWN0b3IkaiA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBsaWI6IHMubGliLFxuICAgIGNvbm5lY3Rpb25JblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbn0pO1xuZnVuY3Rpb24gWm9vbVBhbmUoeyBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBsaWIsIGNvbm5lY3Rpb25JblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRqLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhblpvb20gPSB1c2VSZWYoKTtcbiAgICB1c2VSZXNpemVIYW5kbGVyKHpvb21QYW5lKTtcbiAgICBjb25zdCBvblRyYW5zZm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHsgeDogdHJhbnNmb3JtWzBdLCB5OiB0cmFuc2Zvcm1bMV0sIHpvb206IHRyYW5zZm9ybVsyXSB9KTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoem9vbVBhbmUuY3VycmVudCkge1xuICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50ID0gWFlQYW5ab29tKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlOiAocGFuZURyYWdnaW5nKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZyB9KSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VTdGFydCwgb25Nb3ZlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZSwgb25Nb3ZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCwgb25Nb3ZlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gcGFuWm9vbS5jdXJyZW50LmdldFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuWm9vbTogcGFuWm9vbS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3gsIHksIHpvb21dLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGFuWm9vbS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JblByb2dyZXNzLFxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBsaWIsXG4gICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9ncmVzcyxcbiAgICBdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19yZW5kZXJlclwiLCByZWY6IHpvb21QYW5lLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGkgPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IHMudXNlclNlbGVjdGlvblJlY3QsXG59KTtcbmZ1bmN0aW9uIFVzZXJTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaSwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3NlbGVjdGlvbiByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB1c2VyU2VsZWN0aW9uUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdXNlclNlbGVjdGlvblJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dXNlclNlbGVjdGlvblJlY3QueH1weCwgJHt1c2VyU2VsZWN0aW9uUmVjdC55fXB4KWAsXG4gICAgICAgIH0gfSkpO1xufVxuXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJGggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBjb25uZWN0aW9uSW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgZHJhZ2dpbmc6IHMucGFuZURyYWdnaW5nLFxufSk7XG5mdW5jdGlvbiBQYW5lKHsgaXNTZWxlY3RpbmcsIHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbk9uRHJhZywgc2VsZWN0aW9uT25EcmFnLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2ssIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBlbGVtZW50c1NlbGVjdGFibGUsIGRyYWdnaW5nLCBjb25uZWN0aW9uSW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaCwgc2hhbGxvdyk7XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb25JblByb2dyZXNzID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIFdlIGFsc28gcHJldmVudCBjbGljayBldmVudHMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCB8fCBjb25uZWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXNldFNlbGVjdGVkRWxlbWVudHMsIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50ID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlIHx8XG4gICAgICAgICAgICAhaXNTZWxlY3RpbmcgfHxcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbiAhPT0gMCB8fFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXIuY3VycmVudCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgZWRnZUxvb2t1cCwgY29ubmVjdGlvbkxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVJZHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50O1xuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCA9IG5ldyBTZXQoZ2V0Tm9kZXNJbnNpZGUobm9kZUxvb2t1cCwgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlZGdlc1NlbGVjdGFibGUgPSBkZWZhdWx0RWRnZU9wdGlvbnM/LnNlbGVjdGFibGUgPz8gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2Ygc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbkxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZWRnZUlkIH0gb2YgY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZWRnZUxvb2t1cC5nZXQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZS5zZWxlY3RhYmxlID8/IGVkZ2VzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZE5vZGVJZHMsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZEVkZ2VJZHMsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBuZXh0VXNlclNlbGVjdFJlY3QsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8ucmVsZWFzZVBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2Ugb25seSB3YW50IHRvIHRyaWdnZXIgY2xpY2sgZnVuY3Rpb25zIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgaWZcbiAgICAgICAgICogdGhlIHVzZXIgZGlkIG5vdCBtb3ZlIHRoZSBtb3VzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAqIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHNlbGVjdGlvbk9uRHJhZykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMCkpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lJywgeyBkcmFnZ2FibGUsIGRyYWdnaW5nLCBzZWxlY3Rpb246IGlzU2VsZWN0aW5nIH1dKSwgb25DbGljazogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogd3JhcEhhbmRsZXIob25DbGljaywgY29udGFpbmVyKSwgb25Db250ZXh0TWVudTogd3JhcEhhbmRsZXIob25Db250ZXh0TWVudSwgY29udGFpbmVyKSwgb25XaGVlbDogd3JhcEhhbmRsZXIob25XaGVlbCwgY29udGFpbmVyKSwgb25Qb2ludGVyRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUG9pbnRlckRvd246IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlckRvd24gOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlck1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlck1vdmUgOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlclVwOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvblBvaW50ZXJVcCA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIHJlZjogY29udGFpbmVyLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIGpzeChVc2VyU2VsZWN0aW9uLCB7fSldIH0pKTtcbn1cblxuLypcbiAqIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbiAqIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2VcbiAqIG9yXG4gKiAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVOb2RlQ2xpY2soeyBpZCwgc3RvcmUsIHVuc2VsZWN0ID0gZmFsc2UsIG5vZGVSZWYsIH0pIHtcbiAgICBjb25zdCB7IGFkZFNlbGVjdGVkTm9kZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVMb29rdXAsIG9uRXJyb3IgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMiddKGlkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgaWYgKCFub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXMoW2lkXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuc2VsZWN0IHx8IChub2RlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSkge1xuICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW25vZGVdLCBlZGdlczogW10gfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBub2RlUmVmPy5jdXJyZW50Py5ibHVyKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIFhZRHJhZyBoZWxwZXIgZnJvbSBAeHlmbG93L3N5c3RlbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZyh7IG5vZGVSZWYsIGRpc2FibGVkID0gZmFsc2UsIG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIG5vZGVJZCwgaXNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB4eURyYWcgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB4eURyYWcuY3VycmVudCA9IFhZRHJhZyh7XG4gICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBub2RlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkaXNhYmxlZCwgaXNTZWxlY3RhYmxlLCBub2RlUmVmLCBub2RlSWRdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmNvbnN0IHNlbGVjdGVkQW5kRHJhZ2dhYmxlID0gKG5vZGVzRHJhZ2dhYmxlKSA9PiAobikgPT4gbi5zZWxlY3RlZCAmJiAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbi8qKlxuICogSG9vayBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnMgYnkgcGFzc2luZyBhIGRpcmVjdGlvbiBhbmQgZmFjdG9yXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnQsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBub2Rlc0RyYWdnYWJsZSwgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3Qgbm9kZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEFuZERyYWdnYWJsZShub2Rlc0RyYWdnYWJsZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgYSBub2RlIG1vdmVzIDVweCBvbiBlYWNoIGtleSBwcmVzc1xuICAgICAgICAgKiBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IHhEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi54ICogeFZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBjb25zdCB5RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueSAqIHlWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICsgeERpZmYsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICsgeURpZmYsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBub2RlVXBkYXRlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBtb3ZlU2VsZWN0ZWROb2Rlcztcbn1cblxuY29uc3QgTm9kZUlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciA9IE5vZGVJZENvbnRleHQuUHJvdmlkZXI7XG5Ob2RlSWRDb250ZXh0LkNvbnN1bWVyO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBpZCBvZiB0aGUgbm9kZSBpdCBpcyB1c2VkIGluc2lkZS4gSXQgaXMgdXNlZnVsXG4gKiBpZiB5b3UgbmVlZCB0aGUgbm9kZSdzIGlkIGRlZXBlciBpbiB0aGUgcmVuZGVyIHRyZWUgYnV0IGRvbid0IHdhbnQgdG8gbWFudWFsbHlcbiAqIGRyaWxsIGRvd24gdGhlIGlkIGFzIGEgcHJvcC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgaWQgZm9yIGEgbm9kZSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUlkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDdXN0b21Ob2RlKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8c3Bhbj5UaGlzIG5vZGUgaGFzIGFuIGlkIG9mIDwvc3Bhbj5cbiAqICAgICAgPE5vZGVJZERpc3BsYXkgLz5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqXG4gKmZ1bmN0aW9uIE5vZGVJZERpc3BsYXkoKSB7XG4gKiAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gKlxuICogIHJldHVybiA8c3Bhbj57bm9kZUlkfTwvc3Bhbj47XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzczogISFjbGlja0hhbmRsZSxcbiAgICAgICAgdmFsaWQ6IGNvbm5lY3RpbmdUbyAmJiBpc1ZhbGlkLFxuICAgIH07XG59O1xuZnVuY3Rpb24gSGFuZGxlQ29tcG9uZW50KHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZ0Zyb20sIGNvbm5lY3RpbmdUbywgY2xpY2tDb25uZWN0aW5nLCBpc1Bvc3NpYmxlRW5kSGFuZGxlLCBjb25uZWN0aW9uSW5Qcm9jZXNzLCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MsIHZhbGlkLCB9ID0gdXNlU3RvcmUoY29ubmVjdGluZ1NlbGVjdG9yKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpLCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEwJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTAnXSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb25Db25uZWN0RXh0ZW5kZWQgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEVkZ2VPcHRpb25zLCBvbkNvbm5lY3Q6IG9uQ29ubmVjdEFjdGlvbiwgaGFzRGVmYXVsdEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlZGdlUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBzZXRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGFkZEVkZ2UoZWRnZVBhcmFtcywgZWRnZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbm5lY3RBY3Rpb24/LihlZGdlUGFyYW1zKTtcbiAgICAgICAgb25Db25uZWN0Py4oZWRnZVBhcmFtcyk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RhYmxlU3RhcnQgJiZcbiAgICAgICAgICAgICgoaXNNb3VzZVRyaWdnZXJlZCAmJiBldmVudC5idXR0b24gPT09IDApIHx8ICFpc01vdXNlVHJpZ2dlcmVkKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b3JlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVEb21Ob2RlOiBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IGN1cnJlbnRTdG9yZS5hdXRvUGFuT25Db25uZWN0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblJhZGl1czogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogY3VycmVudFN0b3JlLmRvbU5vZGUsXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cDogY3VycmVudFN0b3JlLm5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgbGliOiBjdXJyZW50U3RvcmUubGliLFxuICAgICAgICAgICAgICAgIGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBmbG93SWQ6IGN1cnJlbnRTdG9yZS5yZklkLFxuICAgICAgICAgICAgICAgIHBhbkJ5OiBjdXJyZW50U3RvcmUucGFuQnksXG4gICAgICAgICAgICAgICAgY2FuY2VsQ29ubmVjdGlvbjogY3VycmVudFN0b3JlLmNhbmNlbENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ6IGN1cnJlbnRTdG9yZS5vbkNvbm5lY3RTdGFydCxcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RFbmQ6IGN1cnJlbnRTdG9yZS5vbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbjogY3VycmVudFN0b3JlLnVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFeHRlbmRlZCxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24gfHwgY3VycmVudFN0b3JlLmlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgICAgICAgICAgYXV0b1BhblNwZWVkOiBjdXJyZW50U3RvcmUuYXV0b1BhblNwZWVkLFxuICAgICAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uRHJhZ1RocmVzaG9sZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdXNlVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bj8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlLCBsaWIsIHJmSWQ6IGZsb3dJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbjogY29ubmVjdGlvblN0YXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFub2RlSWQgfHwgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSAmJiAhaXNDb25uZWN0YWJsZVN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tDb25uZWN0U3RhcnQ/LihldmVudC5uYXRpdmVFdmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogeyBub2RlSWQsIHR5cGUsIGlkOiBoYW5kbGVJZCB9IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciA9IGlzVmFsaWRDb25uZWN0aW9uIHx8IGlzVmFsaWRDb25uZWN0aW9uU3RvcmU7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgaXNWYWxpZCB9ID0gWFlIYW5kbGUuaXNWYWxpZChldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5pZCB8fCBudWxsLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdEV4dGVuZGVkKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25DbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNsb25lLmluUHJvZ3Jlc3M7XG4gICAgICAgIGNvbm5lY3Rpb25DbG9uZS50b1Bvc2l0aW9uID0gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlID8gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlLnBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCwgY29ubmVjdGlvbkNsb25lKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLWhhbmRsZWlkXCI6IGhhbmRsZUlkLCBcImRhdGEtbm9kZWlkXCI6IG5vZGVJZCwgXCJkYXRhLWhhbmRsZXBvc1wiOiBwb3NpdGlvbiwgXCJkYXRhLWlkXCI6IGAke3JmSWR9LSR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjbGlja2Nvbm5lY3Rpbmc6IGNsaWNrQ29ubmVjdGluZyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nZnJvbTogY29ubmVjdGluZ0Zyb20sXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ3RvOiBjb25uZWN0aW5nVG8sXG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzaG93cyB3aGVyZSB5b3UgY2FuIHN0YXJ0IGEgY29ubmVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgICogYW5kIHdoZXJlIHlvdSBjYW4gZW5kIGl0IHdoaWxlIGNvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uaW5kaWNhdG9yOiBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICghY29ubmVjdGlvbkluUHJvY2VzcyB8fCBpc1Bvc3NpYmxlRW5kSGFuZGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29ubmVjdGlvbkluUHJvY2VzcyB8fCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MgPyBpc0Nvbm5lY3RhYmxlRW5kIDogaXNDb25uZWN0YWJsZVN0YXJ0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCBvbk1vdXNlRG93bjogb25Qb2ludGVyRG93biwgb25Ub3VjaFN0YXJ0OiBvblBvaW50ZXJEb3duLCBvbkNsaWNrOiBjb25uZWN0T25DbGljayA/IG9uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxIYW5kbGUgLz5gIGNvbXBvbmVudCBpcyB1c2VkIGluIHlvdXIgW2N1c3RvbSBub2Rlc10oL2xlYXJuL2N1c3RvbWl6YXRpb24vY3VzdG9tLW5vZGVzKVxuICogdG8gZGVmaW5lIGNvbm5lY3Rpb24gcG9pbnRzLlxuICpcbiAqQHB1YmxpY1xuICpcbiAqQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpgYGBcbiAqL1xuY29uc3QgSGFuZGxlID0gbWVtbyhmaXhlZEZvcndhcmRSZWYoSGFuZGxlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIElucHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwTm9kZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gT3V0cHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWxdIH0pKTtcbn1cblxuY29uc3QgYXJyb3dLZXlEaWZmcyA9IHtcbiAgICBBcnJvd1VwOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgQXJyb3dEb3duOiB7IHg6IDAsIHk6IDEgfSxcbiAgICBBcnJvd0xlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgICBBcnJvd1JpZ2h0OiB7IHg6IDEsIHk6IDAgfSxcbn07XG5jb25zdCBidWlsdGluTm9kZVR5cGVzID0ge1xuICAgIGlucHV0OiBJbnB1dE5vZGUsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUsXG4gICAgb3V0cHV0OiBPdXRwdXROb2RlLFxuICAgIGdyb3VwOiBHcm91cE5vZGUsXG59O1xuZnVuY3Rpb24gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgaWYgKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgIH07XG59XG5cbmNvbnN0IHNlbGVjdG9yJGYgPSAocykgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHtcbiAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISFub2RlLnNlbGVjdGVkLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBpc051bWVyaWMod2lkdGgpID8gd2lkdGggOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IGlzTnVtZXJpYyhoZWlnaHQpID8gaGVpZ2h0IDogbnVsbCxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSkgdHJhbnNsYXRlKCR7eH1weCwke3l9cHgpYCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIE5vZGVzU2VsZWN0aW9uKHsgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm1TdHJpbmcsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgbm9kZVJlZi5jdXJyZW50Py5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Rpc2FibGVLZXlib2FyZEExMXldKTtcbiAgICB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICB9KTtcbiAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IG9uU2VsZWN0aW9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNvbnRleHRNZW51KGV2ZW50LCBzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbicsICdyZWFjdC1mbG93X19jb250YWluZXInLCBub1BhbkNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1TdHJpbmcsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyByZWY6IG5vZGVSZWYsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbi1yZWN0XCIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnUsIHRhYkluZGV4OiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogLTEsIG9uS2V5RG93bjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IG9uS2V5RG93biwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB9IH0pIH0pKTtcbn1cblxuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+IHtcbiAgICByZXR1cm4geyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcy5ub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlIH07XG59O1xuZnVuY3Rpb24gRmxvd1JlbmRlcmVyQ29tcG9uZW50KHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IF9wYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiBfcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5PbkRyYWcgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25EcmFnO1xuICAgIGNvbnN0IHBhbk9uU2Nyb2xsID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uU2Nyb2xsO1xuICAgIGNvbnN0IF9zZWxlY3Rpb25PbkRyYWcgPSBzZWxlY3Rpb25PbkRyYWcgJiYgcGFuT25EcmFnICE9PSB0cnVlO1xuICAgIGNvbnN0IGlzU2VsZWN0aW5nID0gc2VsZWN0aW9uS2V5UHJlc3NlZCB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlIHx8IF9zZWxlY3Rpb25PbkRyYWc7XG4gICAgdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSB9KTtcbiAgICByZXR1cm4gKGpzeChab29tUGFuZSwgeyBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBjaGlsZHJlbjoganN4cyhQYW5lLCB7IG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGlzU2VsZWN0aW5nOiAhIWlzU2VsZWN0aW5nLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBzZWxlY3Rpb25LZXlQcmVzc2VkOiBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25PbkRyYWc6IF9zZWxlY3Rpb25PbkRyYWcsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIG5vZGVzU2VsZWN0aW9uQWN0aXZlICYmIChqc3goTm9kZXNTZWxlY3Rpb24sIHsgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pKV0gfSkgfSkpO1xufVxuRmxvd1JlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0Zsb3dSZW5kZXJlcic7XG5jb25zdCBGbG93UmVuZGVyZXIgPSBtZW1vKEZsb3dSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJGQgPSAob25seVJlbmRlclZpc2libGUpID0+IChzKSA9PiB7XG4gICAgcmV0dXJuIG9ubHlSZW5kZXJWaXNpYmxlXG4gICAgICAgID8gZ2V0Tm9kZXNJbnNpZGUocy5ub2RlTG9va3VwLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzLndpZHRoLCBoZWlnaHQ6IHMuaGVpZ2h0IH0sIHMudHJhbnNmb3JtLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpXG4gICAgICAgIDogQXJyYXkuZnJvbShzLm5vZGVMb29rdXAua2V5cygpKTtcbn07XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgbm9kZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBub2RlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlTm9kZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzZWxlY3RvciRkKG9ubHlSZW5kZXJWaXNpYmxlKSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlSWRzO1xufVxuXG5jb25zdCBzZWxlY3RvciRjID0gKHMpID0+IHMudXBkYXRlTm9kZUludGVybmFscztcbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKCkge1xuICAgIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VTdG9yZShzZWxlY3RvciRjKTtcbiAgICBjb25zdCBbcmVzaXplT2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGVudHJ5LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUVsZW1lbnQ6IGVudHJ5LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICAgIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGhhbmRsZSB0aGUgcmVzaXplIG9ic2VydmF0aW9uICsgaW50ZXJuYWwgdXBkYXRlcyBmb3IgdGhlIHBhc3NlZCBub2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgbm9kZVJlZiAtIHJlZmVyZW5jZSB0byB0aGUgbm9kZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IG9ic2VydmVkTm9kZSA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwcmV2U291cmNlUG9zaXRpb24gPSB1c2VSZWYobm9kZS5zb3VyY2VQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlRhcmdldFBvc2l0aW9uID0gdXNlUmVmKG5vZGUudGFyZ2V0UG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdXNlUmVmKG5vZGVUeXBlKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gaGFzRGltZW5zaW9ucyAmJiAhIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50ICYmICFub2RlLmhpZGRlbiAmJiAoIWlzSW5pdGlhbGl6ZWQgfHwgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgIT09IG5vZGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUobm9kZVJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbm9kZVJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgfSwgW2lzSW5pdGlhbGl6ZWQsIG5vZGUuaGlkZGVuXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlZE5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUob2JzZXJ2ZWROb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVkTm9kZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWxzXG4gICAgICAgICAgICAgKiB0byBtYWtlIHN1cmUgdGhlIGVkZ2VzIGFyZSB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IHByZXZUeXBlLmN1cnJlbnQgIT09IG5vZGVUeXBlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9zQ2hhbmdlZCA9IHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zQ2hhbmdlZCA9IHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ICE9PSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVDaGFuZ2VkIHx8IHNvdXJjZVBvc0NoYW5nZWQgfHwgdGFyZ2V0UG9zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlLmN1cnJlbnQgPSBub2RlVHlwZTtcbiAgICAgICAgICAgICAgICBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCA9IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnRhcmdldFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVOb2RlSW50ZXJuYWxzKG5ldyBNYXAoW1tub2RlLmlkLCB7IGlkOiBub2RlLmlkLCBub2RlRWxlbWVudDogbm9kZVJlZi5jdXJyZW50LCBmb3JjZTogdHJ1ZSB9XV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtub2RlLmlkLCBub2RlVHlwZSwgbm9kZS5zb3VyY2VQb3NpdGlvbiwgbm9kZS50YXJnZXRQb3NpdGlvbl0pO1xuICAgIHJldHVybiBub2RlUmVmO1xufVxuXG5mdW5jdGlvbiBOb2RlV3JhcHBlcih7IGlkLCBvbkNsaWNrLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2ssIG5vZGVzRHJhZ2dhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCByZXNpemVPYnNlcnZlciwgbm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZCwgbm9kZVR5cGVzLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgaW50ZXJuYWxzLCBpc1BhcmVudCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBpc1BhcmVudCA9IHMucGFyZW50TG9va3VwLmhhcyhpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiBub2RlLmludGVybmFscyxcbiAgICAgICAgICAgIGlzUGFyZW50LFxuICAgICAgICB9O1xuICAgIH0sIHNoYWxsb3cpO1xuICAgIGxldCBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/Lltub2RlVHlwZV0gfHwgYnVpbHRpbk5vZGVUeXBlc1tub2RlVHlwZV07XG4gICAgaWYgKE5vZGVDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAwMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAzJ10obm9kZVR5cGUpKTtcbiAgICAgICAgbm9kZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIE5vZGVDb21wb25lbnQgPSBub2RlVHlwZXM/LlsnZGVmYXVsdCddIHx8IGJ1aWx0aW5Ob2RlVHlwZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIShub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKG5vZGUuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBub2RlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNDb25uZWN0YWJsZSA9ICEhKG5vZGUuY29ubmVjdGFibGUgfHwgKG5vZGVzQ29ubmVjdGFibGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShub2RlLmZvY3VzYWJsZSB8fCAobm9kZXNGb2N1c2FibGUgJiYgdHlwZW9mIG5vZGUuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYXNEaW1lbnNpb25zID0gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciB9KTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgICAgICBkaXNhYmxlZDogbm9kZS5oaWRkZW4gfHwgIWlzRHJhZ2dhYmxlLFxuICAgICAgICBub0RyYWdDbGFzc05hbWUsXG4gICAgICAgIGhhbmRsZVNlbGVjdG9yOiBub2RlLmRyYWdIYW5kbGUsXG4gICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgbm9kZUNsaWNrRGlzdGFuY2UsXG4gICAgfSk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBpbmxpbmVEaW1lbnNpb25zID0gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaXNTZWxlY3RhYmxlIHx8IGlzRHJhZ2dhYmxlIHx8IG9uQ2xpY2sgfHwgb25Nb3VzZUVudGVyIHx8IG9uTW91c2VNb3ZlIHx8IG9uTW91c2VMZWF2ZTtcbiAgICBjb25zdCBvbk1vdXNlRW50ZXJIYW5kbGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IG9uTW91c2VNb3ZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTW92ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51SGFuZGxlciA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gb25Eb3VibGVDbGlja1xuICAgICAgICA/IChldmVudCkgPT4gb25Eb3VibGVDbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TZWxlY3ROb2RlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiAoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc0RyYWdnYWJsZSB8fCBub2RlRHJhZ1RocmVzaG9sZCA+IDApKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogdGhpcyBoYW5kbGVyIGdldHMgY2FsbGVkIGJ5IFhZRHJhZyBvbiBkcmFnIHN0YXJ0IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9dHJ1ZVxuICAgICAgICAgICAgICogaGVyZSB3ZSBvbmx5IG5lZWQgdG8gY2FsbCBpdCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc0lucHV0RE9NTm9kZShldmVudC5uYXRpdmVFdmVudCkgfHwgZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdCxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEcmFnZ2FibGUgJiYgbm9kZS5zZWxlY3RlZCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBiZWhhdmlvciBvbiBhcnJvdyBrZXkgcHJlc3Mgd2hlbiBub2RlIGlzIG1vdmVkXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgeyBhcmlhTGFiZWxDb25maWcgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmFyaWFMaXZlTWVzc2FnZSddKHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBldmVudC5rZXkucmVwbGFjZSgnQXJyb3cnLCAnJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgeDogfn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiB+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25Gb2N1cyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVLZXlib2FyZEExMXkgfHwgIW5vZGVSZWYuY3VycmVudD8ubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCB3aWR0aCwgaGVpZ2h0LCBhdXRvUGFuT25Ob2RlRm9jdXMsIHNldENlbnRlciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Ob2RlRm9jdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aXRoaW5WaWV3cG9ydCA9IGdldE5vZGVzSW5zaWRlKG5ldyBNYXAoW1tpZCwgbm9kZV1dKSwgeyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0IH0sIHRyYW5zZm9ybSwgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCF3aXRoaW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgc2V0Q2VudGVyKG5vZGUucG9zaXRpb24ueCArIG5vZGVEaW1lbnNpb25zLndpZHRoIC8gMiwgbm9kZS5wb3NpdGlvbi55ICsgbm9kZURpbWVuc2lvbnMuaGVpZ2h0IC8gMiwge1xuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX25vZGUtJHtub2RlVHlwZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3ZlcndyaXRhYmxlIGJ5IHBhc3NpbmcgYG5vcGFuYCBhcyBhIGNsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpc1BhcmVudCxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIHJlZjogbm9kZVJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHpJbmRleDogaW50ZXJuYWxzLnosXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fXB4LCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueX1weClgLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogaGFzUG9pbnRlckV2ZW50cyA/ICdhbGwnIDogJ25vbmUnLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGFzRGltZW5zaW9ucyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgLi4ubm9kZS5zdHlsZSxcbiAgICAgICAgICAgIC4uLmlubGluZURpbWVuc2lvbnMsXG4gICAgICAgIH0sIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX25vZGUtJHtpZH1gLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlckhhbmRsZXIsIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZUhhbmRsZXIsIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlSGFuZGxlciwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudUhhbmRsZXIsIG9uQ2xpY2s6IG9uU2VsZWN0Tm9kZUhhbmRsZXIsIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2tIYW5kbGVyLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCBvbkZvY3VzOiBpc0ZvY3VzYWJsZSA/IG9uRm9jdXMgOiB1bmRlZmluZWQsIHJvbGU6IG5vZGUuYXJpYVJvbGUgPz8gKGlzRm9jdXNhYmxlID8gJ2dyb3VwJyA6IHVuZGVmaW5lZCksIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJub2RlXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgXCJhcmlhLWxhYmVsXCI6IG5vZGUuYXJpYUxhYmVsLCAuLi5ub2RlLmRvbUF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBqc3goUHJvdmlkZXIsIHsgdmFsdWU6IGlkLCBjaGlsZHJlbjoganN4KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBub2RlLmRhdGEsIHR5cGU6IG5vZGVUeXBlLCBwb3NpdGlvbkFic29sdXRlWDogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCwgcG9zaXRpb25BYnNvbHV0ZVk6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksIHNlbGVjdGVkOiBub2RlLnNlbGVjdGVkID8/IGZhbHNlLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRyYWdnYWJsZTogaXNEcmFnZ2FibGUsIGRlbGV0YWJsZTogbm9kZS5kZWxldGFibGUgPz8gdHJ1ZSwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb246IG5vZGUuc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiBub2RlLnRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IG5vZGUuZHJhZ0hhbmRsZSwgekluZGV4OiBpbnRlcm5hbHMueiwgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsIC4uLm5vZGVEaW1lbnNpb25zIH0pIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkYiA9IChzKSA9PiAoe1xuICAgIG5vZGVzRHJhZ2dhYmxlOiBzLm5vZGVzRHJhZ2dhYmxlLFxuICAgIG5vZGVzQ29ubmVjdGFibGU6IHMubm9kZXNDb25uZWN0YWJsZSxcbiAgICBub2Rlc0ZvY3VzYWJsZTogcy5ub2Rlc0ZvY3VzYWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gTm9kZVJlbmRlcmVyQ29tcG9uZW50KHByb3BzKSB7XG4gICAgY29uc3QgeyBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYiwgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVZpc2libGVOb2RlSWRzKHByb3BzLm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc1wiLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBzcGxpdCBvZiByZXNwb25zaWJpbGl0aWVzIGJldHdlZW4gTm9kZVJlbmRlcmVyIGFuZFxuICAgICAgICAgICAgICogTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgICAgICAgKiBtaW5pbWl6ZSB0aGUgY29zdCBvZiB1cGRhdGVzIHdoZW4gaW5kaXZpZHVhbCBub2RlcyBjaGFuZ2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRm9yIGV4YW1wbGUsIHdoZW4geW914oCZcmUgZHJhZ2dpbmcgYSBzaW5nbGUgbm9kZSwgdGhhdCBub2RlIGdldHNcbiAgICAgICAgICAgICAqIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgcGVyIHNlY29uZC4gSWYgYE5vZGVSZW5kZXJlcmAgd2VyZSB0byB1cGRhdGVcbiAgICAgICAgICAgICAqIGV2ZXJ5IHRpbWUsIGl0IHdvdWxkIGhhdmUgdG8gcmUtcnVuIHRoZSBgbm9kZXMubWFwKClgIGxvb3AgZXZlcnlcbiAgICAgICAgICAgICAqIHRpbWUuIFRoaXMgZ2V0cyBwcmljZXkgd2l0aCBodW5kcmVkcyBvZiBub2RlcywgZXNwZWNpYWxseSBpZiBldmVyeVxuICAgICAgICAgICAgICogbG9vcCBjeWNsZSBkb2VzIG1vcmUgdGhhbiBqdXN0IHJlbmRlcmluZyBhIEpTWCBlbGVtZW50IVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFzIGEgcmVzdWx0IG9mIHRoaXMgY2hvaWNlLCB3ZSB0b29rIHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAqIGRlY2lzaW9uczpcbiAgICAgICAgICAgICAqIC0gTm9kZVJlbmRlcmVyIHN1YnNjcmliZXMgKm9ubHkqIHRvIG5vZGUgSURzIOKAkyBhbmQgdGhlcmVmb3JlXG4gICAgICAgICAgICAgKiAgIHJlcmVuZGVyICpvbmx5KiB3aGVuIHZpc2libGUgbm9kZXMgYXJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICAgICAgICAgKiAtIE5vZGVSZW5kZXJlciBwZXJmb3JtcyBhbGwgb3BlcmF0aW9ucyB0aGUgcmVzdWx0IG9mIHdoaWNoIGNhbiBiZVxuICAgICAgICAgICAgICogICBzaGFyZWQgYmV0d2VlbiBub2RlcyAoc3VjaCBhcyBjcmVhdGluZyB0aGUgYFJlc2l6ZU9ic2VydmVyYFxuICAgICAgICAgICAgICogICBpbnN0YW5jZSwgb3Igc3Vic2NyaWJpbmcgdG8gYHNlbGVjdG9yYCkuIFRoaXMgbWVhbnMgZXh0cmEgcHJvcFxuICAgICAgICAgICAgICogICBkcmlsbGluZyBpbnRvIGBOb2RlQ29tcG9uZW50V3JhcHBlcmAsIGJ1dCBpdCBtZWFucyB3ZSBuZWVkIHRvIHJ1blxuICAgICAgICAgICAgICogICB0aGVzZSBvcGVyYXRpb25zIG9ubHkgb25jZSDigJMgaW5zdGVhZCBvZiBvbmNlIHBlciBub2RlLlxuICAgICAgICAgICAgICogLSBBbnkgb3BlcmF0aW9ucyB0aGF0IHlvdeKAmWQgbm9ybWFsbHkgd3JpdGUgaW5zaWRlIGBub2Rlcy5tYXBgIGFyZVxuICAgICAgICAgICAgICogICBtb3ZlZCBpbnRvIGBOb2RlQ29tcG9uZW50V3JhcHBlcmAuIFRoaXMgZW5zdXJlcyB0aGV5IGFyZVxuICAgICAgICAgICAgICogICBtZW1vcml6ZWQg4oCTIHNvIGlmIGBOb2RlUmVuZGVyZXJgICpoYXMqIHRvIHJlcmVuZGVyLCBpdCBvbmx5XG4gICAgICAgICAgICAgKiAgIG5lZWRzIHRvIHJlZ2VuZXJhdGUgdGhlIGxpc3Qgb2Ygbm9kZXMsIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAganN4KE5vZGVXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVUeXBlczogcHJvcHMubm9kZVR5cGVzLCBub2RlRXh0ZW50OiBwcm9wcy5ub2RlRXh0ZW50LCBvbkNsaWNrOiBwcm9wcy5vbk5vZGVDbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk5vZGVNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogcHJvcHMub25Ob2RlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTm9kZU1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnU6IHByb3BzLm9uTm9kZUNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrOiBwcm9wcy5vbk5vZGVEb3VibGVDbGljaywgbm9EcmFnQ2xhc3NOYW1lOiBwcm9wcy5ub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBwcm9wcy5ub1BhbkNsYXNzTmFtZSwgcmZJZDogcHJvcHMucmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogcHJvcHMuZGlzYWJsZUtleWJvYXJkQTExeSwgcmVzaXplT2JzZXJ2ZXI6IHJlc2l6ZU9ic2VydmVyLCBub2Rlc0RyYWdnYWJsZTogbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlOiBwcm9wcy5ub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvcjogb25FcnJvciB9LCBub2RlSWQpKTtcbiAgICAgICAgfSkgfSkpO1xufVxuTm9kZVJlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ05vZGVSZW5kZXJlcic7XG5jb25zdCBOb2RlUmVuZGVyZXIgPSBtZW1vKE5vZGVSZW5kZXJlckNvbXBvbmVudCk7XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB0aGUgdmlzaWJsZSBlZGdlIGlkcyBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvbmx5UmVuZGVyVmlzaWJsZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIGVkZ2UgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGlmICghb25seVJlbmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUVkZ2VJZHMgPSBbXTtcbiAgICAgICAgaWYgKHMud2lkdGggJiYgcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBzLmVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRWRnZVZpc2libGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlRWRnZUlkcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZUVkZ2VJZHM7XG4gICAgfSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlSWRzO1xufVxuXG5jb25zdCBBcnJvd1N5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgLi4uKGNvbG9yICYmIHsgc3Ryb2tlOiBjb2xvciB9KSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBjbGFzc05hbWU6IFwiYXJyb3dcIiwgc3R5bGU6IHN0eWxlLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDRcIiB9KSk7XG59O1xuY29uc3QgQXJyb3dDbG9zZWRTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIC4uLihjb2xvciAmJiB7IHN0cm9rZTogY29sb3IsIGZpbGw6IGNvbG9yIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IGNsYXNzTmFtZTogXCJhcnJvd2Nsb3NlZFwiLCBzdHlsZTogc3R5bGUsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0IC01LC00XCIgfSkpO1xufTtcbmNvbnN0IE1hcmtlclN5bWJvbHMgPSB7XG4gICAgW01hcmtlclR5cGUuQXJyb3ddOiBBcnJvd1N5bWJvbCxcbiAgICBbTWFya2VyVHlwZS5BcnJvd0Nsb3NlZF06IEFycm93Q2xvc2VkU3ltYm9sLFxufTtcbmZ1bmN0aW9uIHVzZU1hcmtlclN5bWJvbCh0eXBlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW1ib2xFeGlzdHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTWFya2VyU3ltYm9scywgdHlwZSk7XG4gICAgICAgIGlmICghc3ltYm9sRXhpc3RzKSB7XG4gICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA5JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDknXSh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyU3ltYm9sc1t0eXBlXTtcbiAgICB9LCBbdHlwZV0pO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5cbmNvbnN0IE1hcmtlciA9ICh7IGlkLCB0eXBlLCBjb2xvciwgd2lkdGggPSAxMi41LCBoZWlnaHQgPSAxMi41LCBtYXJrZXJVbml0cyA9ICdzdHJva2VXaWR0aCcsIHN0cm9rZVdpZHRoLCBvcmllbnQgPSAnYXV0by1zdGFydC1yZXZlcnNlJywgfSkgPT4ge1xuICAgIGNvbnN0IFN5bWJvbCA9IHVzZU1hcmtlclN5bWJvbCh0eXBlKTtcbiAgICBpZiAoIVN5bWJvbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJtYXJrZXJcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXJyb3doZWFkXCIsIGlkOiBpZCwgbWFya2VyV2lkdGg6IGAke3dpZHRofWAsIG1hcmtlckhlaWdodDogYCR7aGVpZ2h0fWAsIHZpZXdCb3g6IFwiLTEwIC0xMCAyMCAyMFwiLCBtYXJrZXJVbml0czogbWFya2VyVW5pdHMsIG9yaWVudDogb3JpZW50LCByZWZYOiBcIjBcIiwgcmVmWTogXCIwXCIsIGNoaWxkcmVuOiBqc3goU3ltYm9sLCB7IGNvbG9yOiBjb2xvciwgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoIH0pIH0pKTtcbn07XG4vKlxuICogd2hlbiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiBhIHBhZ2UgYW5kIHlvdSBoaWRlIHRoZSBmaXJzdCBvbmUsIHRoZSBvdGhlciBvbmVzIGhhdmUgbm8gbWFya2VycyBhbnltb3JlXG4gKiB3aGVuIHRoZXkgZG8gaGF2ZSBtYXJrZXJzIHdpdGggdGhlIHNhbWUgaWRzLiBUbyBwcmV2ZW50IHRoaXMgdGhlIHVzZXIgY2FuIHBhc3MgYSB1bmlxdWUgaWQgdG8gdGhlIHJlYWN0IGZsb3cgd3JhcHBlclxuICogdGhhdCB3ZSBjYW4gdGhlbiB1c2UgZm9yIGNyZWF0aW5nIG91ciB1bmlxdWUgbWFya2VyIGlkc1xuICovXG5jb25zdCBNYXJrZXJEZWZpbml0aW9ucyA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlcyk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBjcmVhdGVNYXJrZXJJZHMoZWRnZXMsIHtcbiAgICAgICAgICAgIGlkOiByZklkLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlclN0YXJ0OiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlclN0YXJ0LFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlckVuZDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJFbmQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbZWRnZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgcmZJZCwgZGVmYXVsdENvbG9yXSk7XG4gICAgaWYgKCFtYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWFya2VyXCIsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNoaWxkcmVuOiBqc3goXCJkZWZzXCIsIHsgY2hpbGRyZW46IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChqc3goTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIHR5cGU6IG1hcmtlci50eXBlLCBjb2xvcjogbWFya2VyLmNvbG9yLCB3aWR0aDogbWFya2VyLndpZHRoLCBoZWlnaHQ6IG1hcmtlci5oZWlnaHQsIG1hcmtlclVuaXRzOiBtYXJrZXIubWFya2VyVW5pdHMsIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGgsIG9yaWVudDogbWFya2VyLm9yaWVudCB9LCBtYXJrZXIuaWQpKSkgfSkgfSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmZ1bmN0aW9uIEVkZ2VUZXh0Q29tcG9uZW50KHsgeCwgeSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnID0gdHJ1ZSwgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZyA9IFsyLCA0XSwgbGFiZWxCZ0JvcmRlclJhZGl1cyA9IDIsIGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IFtlZGdlVGV4dEJib3gsIHNldEVkZ2VUZXh0QmJveF0gPSB1c2VTdGF0ZSh7IHg6IDEsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgY29uc3QgZWRnZVRleHRDbGFzc2VzID0gY2MoWydyZWFjdC1mbG93X19lZGdlLXRleHR3cmFwcGVyJywgY2xhc3NOYW1lXSk7XG4gICAgY29uc3QgZWRnZVRleHRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVkZ2VUZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRCYm94ID0gZWRnZVRleHRSZWYuY3VycmVudC5nZXRCQm94KCk7XG4gICAgICAgICAgICBzZXRFZGdlVGV4dEJib3goe1xuICAgICAgICAgICAgICAgIHg6IHRleHRCYm94LngsXG4gICAgICAgICAgICAgICAgeTogdGV4dEJib3gueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4dEJib3gud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0QmJveC5oZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtsYWJlbF0pO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhcImdcIiwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4IC0gZWRnZVRleHRCYm94LndpZHRoIC8gMn0gJHt5IC0gZWRnZVRleHRCYm94LmhlaWdodCAvIDJ9KWAsIGNsYXNzTmFtZTogZWRnZVRleHRDbGFzc2VzLCB2aXNpYmlsaXR5OiBlZGdlVGV4dEJib3gud2lkdGggPyAndmlzaWJsZScgOiAnaGlkZGVuJywgLi4ucmVzdCwgY2hpbGRyZW46IFtsYWJlbFNob3dCZyAmJiAoanN4KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLCBqc3goXCJ0ZXh0XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dFwiLCB5OiBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMiwgZHk6IFwiMC4zZW1cIiwgcmVmOiBlZGdlVGV4dFJlZiwgc3R5bGU6IGxhYmVsU3R5bGUsIGNoaWxkcmVuOiBsYWJlbCB9KSwgY2hpbGRyZW5dIH0pKTtcbn1cbkVkZ2VUZXh0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VUZXh0Jztcbi8qKlxuICogWW91IGNhbiB1c2UgdGhlIGA8RWRnZVRleHQgLz5gIGNvbXBvbmVudCBhcyBhIGhlbHBlciBjb21wb25lbnQgdG8gZGlzcGxheSB0ZXh0XG4gKiB3aXRoaW4geW91ciBjdXN0b20gZWRnZXMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IEVkZ2VUZXh0IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2VMYWJlbCh7IGxhYmVsIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8RWRnZVRleHRcbiAqICAgICAgIHg9ezEwMH1cbiAqICAgICAgIHk9ezEwMH1cbiAqICAgICAgIGxhYmVsPXtsYWJlbH1cbiAqICAgICAgIGxhYmVsU3R5bGU9e3sgZmlsbDogJ3doaXRlJyB9fVxuICogICAgICAgbGFiZWxTaG93QmdcbiAqICAgICAgIGxhYmVsQmdTdHlsZT17eyBmaWxsOiAncmVkJyB9fVxuICogICAgICAgbGFiZWxCZ1BhZGRpbmc9e1syLCA0XX1cbiAqICAgICAgIGxhYmVsQmdCb3JkZXJSYWRpdXM9ezJ9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqYGBgXG4gKi9cbmNvbnN0IEVkZ2VUZXh0ID0gbWVtbyhFZGdlVGV4dENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGA8QmFzZUVkZ2UgLz5gIGNvbXBvbmVudCBnZXRzIHVzZWQgaW50ZXJuYWxseSBmb3IgYWxsIHRoZSBlZGdlcy4gSXQgY2FuIGJlXG4gKiB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIGFuZCBoYW5kbGVzIHRoZSBpbnZpc2libGUgaGVscGVyIGVkZ2UgYW5kIHRoZSBlZGdlIGxhYmVsXG4gKiBmb3IgeW91LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgQmFzZUVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgLi4ucHJvcHMgfSkge1xuICogIGNvbnN0IFtlZGdlUGF0aF0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWCxcbiAqICAgIHNvdXJjZVksXG4gKiAgICB0YXJnZXRYLFxuICogICAgdGFyZ2V0WSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIDxCYXNlRWRnZSBwYXRoPXtlZGdlUGF0aH0gey4uLnByb3BzfSAvPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3Ugd2FudCB0byB1c2UgYW4gZWRnZSBtYXJrZXIgd2l0aCB0aGUgW2A8QmFzZUVkZ2UgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2Jhc2UtZWRnZSkgY29tcG9uZW50LFxuICogeW91IGNhbiBwYXNzIHRoZSBgbWFya2VyU3RhcnRgIG9yIGBtYXJrZXJFbmRgIHByb3BzIHBhc3NlZCB0byB5b3VyIGN1c3RvbSBlZGdlXG4gKiB0aHJvdWdoIHRvIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQuXG4gKiBZb3UgY2FuIHNlZSBhbGwgdGhlIHByb3BzIHBhc3NlZCB0byBhIGN1c3RvbSBlZGdlIGJ5IGxvb2tpbmcgYXQgdGhlIFtgRWRnZVByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZS1wcm9wcykgdHlwZS5cbiAqL1xuZnVuY3Rpb24gQmFzZUVkZ2UoeyBwYXRoLCBsYWJlbFgsIGxhYmVsWSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBpbnRlcmFjdGlvbldpZHRoID0gMjAsIC4uLnByb3BzIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgLi4ucHJvcHMsIGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fZWRnZS1wYXRoJywgcHJvcHMuY2xhc3NOYW1lXSkgfSksIGludGVyYWN0aW9uV2lkdGggPyAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSkgOiBudWxsLCBsYWJlbCAmJiBpc051bWVyaWMobGFiZWxYKSAmJiBpc051bWVyaWMobGFiZWxZKSA/IChqc3goRWRnZVRleHQsIHsgeDogbGFiZWxYLCB5OiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSA6IG51bGxdIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbCh7IHBvcywgeDEsIHkxLCB4MiwgeTIgfSkge1xuICAgIGlmIChwb3MgPT09IFBvc2l0aW9uLkxlZnQgfHwgcG9zID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gWzAuNSAqICh4MSArIHgyKSwgeTFdO1xuICAgIH1cbiAgICByZXR1cm4gW3gxLCAwLjUgKiAoeTEgKyB5MildO1xufVxuLyoqXG4gKiBUaGUgYGdldFNpbXBsZUJlemllclBhdGhgIHV0aWwgcmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHJlbmRlciBhIHNpbXBsZVxuICogYmV6aWVyIGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0U2ltcGxlQmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbCh7XG4gICAgICAgIHBvczogc291cmNlUG9zaXRpb24sXG4gICAgICAgIHgxOiBzb3VyY2VYLFxuICAgICAgICB5MTogc291cmNlWSxcbiAgICAgICAgeDI6IHRhcmdldFgsXG4gICAgICAgIHkyOiB0YXJnZXRZLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbCh7XG4gICAgICAgIHBvczogdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHgxOiB0YXJnZXRYLFxuICAgICAgICB5MTogdGFyZ2V0WSxcbiAgICAgICAgeDI6IHNvdXJjZVgsXG4gICAgICAgIHkyOiBzb3VyY2VZLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNpbXBsZUJlemllckVkZ2UgPSBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG5jb25zdCBTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwgPSBjcmVhdGVTaW1wbGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNpbXBsZUJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZSc7XG5TaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU2ltcGxlQmV6aWVyRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU21vb3RoU3RlcEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogcGF0aE9wdGlvbnM/LmJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgIG9mZnNldDogcGF0aE9wdGlvbnM/Lm9mZnNldCxcbiAgICAgICAgICAgIHN0ZXBQb3NpdGlvbjogcGF0aE9wdGlvbnM/LnN0ZXBQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHNtb290aCBzdGVwIGVkZ2UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFNtb290aFN0ZXBFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFNtb290aFN0ZXBFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU21vb3RoU3RlcEVkZ2UgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNtb290aFN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlJztcblNtb290aFN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChTbW9vdGhTdGVwRWRnZSwgeyAuLi5wcm9wcywgaWQ6IF9pZCwgcGF0aE9wdGlvbnM6IHVzZU1lbW8oKCkgPT4gKHsgYm9yZGVyUmFkaXVzOiAwLCBvZmZzZXQ6IHByb3BzLnBhdGhPcHRpb25zPy5vZmZzZXQgfSksIFtwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0XSkgfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzdGVwIGVkZ2UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFN0ZXBFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFN0ZXBFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU3RlcEVkZ2UgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlJztcblN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmFpZ2h0RWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHN0cmFpZ2h0IGxpbmUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFN0cmFpZ2h0RWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U3RyYWlnaHRFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgU3RyYWlnaHRFZGdlID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdHJhaWdodEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblN0cmFpZ2h0RWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBiZXppZXIgY3VydmUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IEJlemllckVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8QmV6aWVyRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEJlemllckVkZ2UgPSBjcmVhdGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCZXppZXJFZGdlSW50ZXJuYWwgPSBjcmVhdGVCZXppZXJFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcbkJlemllckVkZ2UuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZSc7XG5CZXppZXJFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnQmV6aWVyRWRnZUludGVybmFsJztcblxuY29uc3QgYnVpbHRpbkVkZ2VUeXBlcyA9IHtcbiAgICBkZWZhdWx0OiBCZXppZXJFZGdlSW50ZXJuYWwsXG4gICAgc3RyYWlnaHQ6IFN0cmFpZ2h0RWRnZUludGVybmFsLFxuICAgIHN0ZXA6IFN0ZXBFZGdlSW50ZXJuYWwsXG4gICAgc21vb3Roc3RlcDogU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzaW1wbGViZXppZXI6IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCxcbn07XG5jb25zdCBudWxsUG9zaXRpb24gPSB7XG4gICAgc291cmNlWDogbnVsbCxcbiAgICBzb3VyY2VZOiBudWxsLFxuICAgIHRhcmdldFg6IG51bGwsXG4gICAgdGFyZ2V0WTogbnVsbCxcbiAgICBzb3VyY2VQb3NpdGlvbjogbnVsbCxcbiAgICB0YXJnZXRQb3NpdGlvbjogbnVsbCxcbn07XG5cbmNvbnN0IHNoaWZ0WCA9ICh4LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQpXG4gICAgICAgIHJldHVybiB4IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodClcbiAgICAgICAgcmV0dXJuIHggKyBzaGlmdDtcbiAgICByZXR1cm4geDtcbn07XG5jb25zdCBzaGlmdFkgPSAoeSwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3ApXG4gICAgICAgIHJldHVybiB5IC0gc2hpZnQ7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5Cb3R0b20pXG4gICAgICAgIHJldHVybiB5ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHk7XG59O1xuY29uc3QgRWRnZVVwZGF0ZXJDbGFzc05hbWUgPSAncmVhY3QtZmxvd19fZWRnZXVwZGF0ZXInO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gRWRnZUFuY2hvcih7IHBvc2l0aW9uLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgPSAxMCwgb25Nb3VzZURvd24sIG9uTW91c2VFbnRlciwgb25Nb3VzZU91dCwgdHlwZSwgfSkge1xuICAgIHJldHVybiAoanN4KFwiY2lyY2xlXCIsIHsgb25Nb3VzZURvd246IG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlciwgb25Nb3VzZU91dDogb25Nb3VzZU91dCwgY2xhc3NOYW1lOiBjYyhbRWRnZVVwZGF0ZXJDbGFzc05hbWUsIGAke0VkZ2VVcGRhdGVyQ2xhc3NOYW1lfS0ke3R5cGV9YF0pLCBjeDogc2hpZnRYKGNlbnRlclgsIHJhZGl1cywgcG9zaXRpb24pLCBjeTogc2hpZnRZKGNlbnRlclksIHJhZGl1cywgcG9zaXRpb24pLCByOiByYWRpdXMsIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBmaWxsOiBcInRyYW5zcGFyZW50XCIgfSkpO1xufVxuXG5mdW5jdGlvbiBFZGdlVXBkYXRlQW5jaG9ycyh7IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzLCBlZGdlLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgc2V0UmVjb25uZWN0aW5nLCBzZXRVcGRhdGVIb3ZlciwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYW5kbGVFZGdlVXBkYXRlciA9IChldmVudCwgb3Bwb3NpdGVIYW5kbGUpID0+IHtcbiAgICAgICAgLy8gYXZvaWQgdHJpZ2dlcmluZyBlZGdlIHVwZGF0ZXIgaWYgbW91c2UgYnRuIGlzIG5vdCBsZWZ0XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGF1dG9QYW5PbkNvbm5lY3QsIGRvbU5vZGUsIGlzVmFsaWRDb25uZWN0aW9uLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgbGliLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBjYW5jZWxDb25uZWN0aW9uLCBub2RlTG9va3VwLCByZklkOiBmbG93SWQsIHBhbkJ5LCB1cGRhdGVDb25uZWN0aW9uLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgaXNUYXJnZXQgPSBvcHBvc2l0ZUhhbmRsZS50eXBlID09PSAndGFyZ2V0JztcbiAgICAgICAgY29uc3QgX29uUmVjb25uZWN0RW5kID0gKGV2dCwgY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ29ubmVjdEVkZ2UgPSAoY29ubmVjdGlvbikgPT4gb25SZWNvbm5lY3Q/LihlZGdlLCBjb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3QgX29uQ29ubmVjdFN0YXJ0ID0gKF9ldmVudCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgICAgICBvblJlY29ubmVjdFN0YXJ0Py4oZXZlbnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUpO1xuICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ/LihfZXZlbnQsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0OiBfb25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICBvbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZDogX29uUmVjb25uZWN0RW5kLFxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsXG4gICAgICAgICAgICBoYW5kbGVEb21Ob2RlOiBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgeyBub2RlSWQ6IGVkZ2UudGFyZ2V0LCBpZDogZWRnZS50YXJnZXRIYW5kbGUgPz8gbnVsbCwgdHlwZTogJ3RhcmdldCcgfSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS5zb3VyY2UsIGlkOiBlZGdlLnNvdXJjZUhhbmRsZSA/PyBudWxsLCB0eXBlOiAnc291cmNlJyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdE1vdXNlRW50ZXIgPSAoKSA9PiBzZXRVcGRhdGVIb3Zlcih0cnVlKTtcbiAgICBjb25zdCBvblJlY29ubmVjdE1vdXNlT3V0ID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIoZmFsc2UpO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyhpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAnc291cmNlJykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgY2VudGVyWDogc291cmNlWCwgY2VudGVyWTogc291cmNlWSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwic291cmNlXCIgfSkpLCAoaXNSZWNvbm5lY3RhYmxlID09PSB0cnVlIHx8IGlzUmVjb25uZWN0YWJsZSA9PT0gJ3RhcmdldCcpICYmIChqc3goRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGNlbnRlclg6IHRhcmdldFgsIGNlbnRlclk6IHRhcmdldFksIHJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbk1vdXNlRG93bjogb25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25SZWNvbm5lY3RNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvblJlY29ubmVjdE1vdXNlT3V0LCB0eXBlOiBcInRhcmdldFwiIH0pKV0gfSkpO1xufVxuXG5mdW5jdGlvbiBFZGdlV3JhcHBlcih7IGlkLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIG9uQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uRXJyb3IsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBsZXQgZWRnZSA9IHVzZVN0b3JlKChzKSA9PiBzLmVkZ2VMb29rdXAuZ2V0KGlkKSk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBlZGdlID0gZGVmYXVsdEVkZ2VPcHRpb25zID8geyAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsIC4uLmVkZ2UgfSA6IGVkZ2U7XG4gICAgbGV0IGVkZ2VUeXBlID0gZWRnZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICBsZXQgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlcz8uW2VkZ2VUeXBlXSB8fCBidWlsdGluRWRnZVR5cGVzW2VkZ2VUeXBlXTtcbiAgICBpZiAoRWRnZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDExJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTEnXShlZGdlVHlwZSkpO1xuICAgICAgICBlZGdlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgRWRnZUNvbXBvbmVudCA9IGVkZ2VUeXBlcz8uWydkZWZhdWx0J10gfHwgYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAuLi4oZWRnZVBvc2l0aW9uIHx8IG51bGxQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgfSwgW2VkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCwgZWRnZS5zb3VyY2VIYW5kbGUsIGVkZ2UudGFyZ2V0SGFuZGxlLCBlZGdlLnNlbGVjdGVkLCBlZGdlLnpJbmRleF0pLCBzaGFsbG93KTtcbiAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyU3RhcnQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlclN0YXJ0LCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyRW5kID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJFbmQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlckVuZCwgcmZJZF0pO1xuICAgIGlmIChlZGdlLmhpZGRlbiB8fCBzb3VyY2VYID09PSBudWxsIHx8IHNvdXJjZVkgPT09IG51bGwgfHwgdGFyZ2V0WCA9PT0gbnVsbCB8fCB0YXJnZXRZID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZFNlbGVjdGVkRWRnZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2sgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSAmJiBlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogeyB6SW5kZXggfSwgY2hpbGRyZW46IGpzeHMoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7ZWRnZVR5cGV9YCxcbiAgICAgICAgICAgICAgICBlZGdlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZDogZWRnZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6ICFpc1NlbGVjdGFibGUgJiYgIW9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0aW5nOiB1cGRhdGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGVkZ2UuYXJpYVJvbGUgPz8gKGlzRm9jdXNhYmxlID8gJ2dyb3VwJyA6ICdpbWcnKSwgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcImVkZ2VcIiwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBlZGdlLmFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2UuYXJpYUxhYmVsIHx8IGBFZGdlIGZyb20gJHtlZGdlLnNvdXJjZX0gdG8gJHtlZGdlLnRhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYsIC4uLmVkZ2UuZG9tQXR0cmlidXRlcywgY2hpbGRyZW46IFshcmVjb25uZWN0aW5nICYmIChqc3goRWRnZUNvbXBvbmVudCwgeyBpZDogaWQsIHNvdXJjZTogZWRnZS5zb3VyY2UsIHRhcmdldDogZWRnZS50YXJnZXQsIHR5cGU6IGVkZ2UudHlwZSwgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRlbGV0YWJsZTogZWRnZS5kZWxldGFibGUgPz8gdHJ1ZSwgbGFiZWw6IGVkZ2UubGFiZWwsIGxhYmVsU3R5bGU6IGVkZ2UubGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGVkZ2UubGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogZWRnZS5sYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBlZGdlLmxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBlZGdlLmxhYmVsQmdCb3JkZXJSYWRpdXMsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkYXRhOiBlZGdlLmRhdGEsIHN0eWxlOiBlZGdlLnN0eWxlLCBzb3VyY2VIYW5kbGVJZDogZWRnZS5zb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZUlkOiBlZGdlLnRhcmdldEhhbmRsZSwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0VXJsLCBtYXJrZXJFbmQ6IG1hcmtlckVuZFVybCwgcGF0aE9wdGlvbnM6ICdwYXRoT3B0aW9ucycgaW4gZWRnZSA/IGVkZ2UucGF0aE9wdGlvbnMgOiB1bmRlZmluZWQsIGludGVyYWN0aW9uV2lkdGg6IGVkZ2UuaW50ZXJhY3Rpb25XaWR0aCB9KSksIGlzUmVjb25uZWN0YWJsZSAmJiAoanN4KEVkZ2VVcGRhdGVBbmNob3JzLCB7IGVkZ2U6IGVkZ2UsIGlzUmVjb25uZWN0YWJsZTogaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBzZXRVcGRhdGVIb3Zlcjogc2V0VXBkYXRlSG92ZXIsIHNldFJlY29ubmVjdGluZzogc2V0UmVjb25uZWN0aW5nIH0pKV0gfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRhID0gKHMpID0+ICh7XG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNSZWNvbm5lY3RhYmxlOiBzLmVkZ2VzUmVjb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gRWRnZVJlbmRlcmVyQ29tcG9uZW50KHsgZGVmYXVsdE1hcmtlckNvbG9yLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXNcIiwgY2hpbGRyZW46IFtqc3goTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSwgZWRnZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRWRnZVdyYXBwZXIsIHsgaWQ6IGlkLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25DbGljazogb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCByZklkOiByZklkLCBvbkVycm9yOiBvbkVycm9yLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9LCBpZCkpO1xuICAgICAgICAgICAgfSldIH0pKTtcbn1cbkVkZ2VSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xuY29uc3QgRWRnZVJlbmRlcmVyID0gbWVtbyhFZGdlUmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkOSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQgeHlmbG93X192aWV3cG9ydCByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHsgdHJhbnNmb3JtIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbi8qKlxuICogSG9vayBmb3IgY2FsbGluZyBvbkluaXQgaGFuZGxlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlT25Jbml0SGFuZGxlcihvbkluaXQpIHtcbiAgICBjb25zdCByZkluc3RhbmNlID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkLmN1cnJlbnQgJiYgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkICYmIG9uSW5pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkluaXQocmZJbnN0YW5jZSksIDEpO1xuICAgICAgICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkluaXQsIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ4ID0gKHN0YXRlKSA9PiBzdGF0ZS5wYW5ab29tPy5zeW5jVmlld3BvcnQ7XG4vKipcbiAqIEhvb2sgZm9yIHN5bmNpbmcgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHBhbnpvb20gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KSB7XG4gICAgY29uc3Qgc3luY1ZpZXdwb3J0ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgc3luY1ZpZXdwb3J0Py4odmlld3BvcnQpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm06IFt2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56b29tXSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2aWV3cG9ydCwgc3luY1ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2VsZWN0b3IkMShzKSB7XG4gICAgcmV0dXJuIHMuY29ubmVjdGlvbi5pblByb2dyZXNzXG4gICAgICAgID8geyAuLi5zLmNvbm5lY3Rpb24sIHRvOiBwb2ludFRvUmVuZGVyZXJQb2ludChzLmNvbm5lY3Rpb24udG8sIHMudHJhbnNmb3JtKSB9XG4gICAgICAgIDogeyAuLi5zLmNvbm5lY3Rpb24gfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGlmIChjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RvcmVTZWxlY3RvciQxKHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25TZWxlY3Rvcihjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkU2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZVNlbGVjdG9yJDE7XG59XG4vKipcbiAqIFRoZSBgdXNlQ29ubmVjdGlvbmAgaG9vayByZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmVcbiAqIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24uIElmIG5vIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBpdCByZXR1cm5zIG51bGxcbiAqIGZvciBldmVyeSBwcm9wZXJ0eS4gQSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGlzIGhvb2sgaXMgdG8gY29sb3JpemUgaGFuZGxlc1xuICogYmFzZWQgb24gYSBjZXJ0YWluIGNvbmRpdGlvbiAoZS5nLiBpZiB0aGUgY29ubmVjdGlvbiBpcyB2YWxpZCBvciBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjb25uZWN0aW9uU2VsZWN0b3IgLSBBbiBvcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB1c2VkIHRvIGV4dHJhY3QgYSBzbGljZSBvZiB0aGVcbiAqIGBDb25uZWN0aW9uU3RhdGVgIGRhdGEuIFVzaW5nIGEgc2VsZWN0b3IgY2FuIHByZXZlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMgd2hlcmUgZGF0YSB5b3UgZG9uJ3RcbiAqIG90aGVyd2lzZSBjYXJlIGFib3V0IG1pZ2h0IGNoYW5nZS4gSWYgYSBzZWxlY3RvciBpcyBub3QgcHJvdmlkZWQsIHRoZSBlbnRpcmUgYENvbm5lY3Rpb25TdGF0ZWBcbiAqIG9iamVjdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VDb25uZWN0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBBcHAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbiA9IHVzZUNvbm5lY3Rpb24oKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+IHtjb25uZWN0aW9uID8gYFNvbWVvbmUgaXMgdHJ5aW5nIHRvIG1ha2UgYSBjb25uZWN0aW9uIGZyb20gJHtjb25uZWN0aW9uLmZyb21Ob2RlfSB0byB0aGlzIG9uZS5gIDogJ1RoZXJlIGFyZSBjdXJyZW50bHkgbm8gaW5jb21pbmcgY29ubmVjdGlvbnMhJ31cbiAqXG4gKiAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybnMgQ29ubmVjdGlvblN0YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbm5lY3Rpb24oY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcik7XG4gICAgcmV0dXJuIHVzZVN0b3JlKGNvbWJpbmVkU2VsZWN0b3IsIHNoYWxsb3cpO1xufVxuXG5jb25zdCBzZWxlY3RvciQ3ID0gKHMpID0+ICh7XG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIGlzVmFsaWQ6IHMuY29ubmVjdGlvbi5pc1ZhbGlkLFxuICAgIGluUHJvZ3Jlc3M6IHMuY29ubmVjdGlvbi5pblByb2dyZXNzLFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG59KTtcbmZ1bmN0aW9uIENvbm5lY3Rpb25MaW5lV3JhcHBlcih7IGNvbnRhaW5lclN0eWxlLCBzdHlsZSwgdHlwZSwgY29tcG9uZW50LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc0Nvbm5lY3RhYmxlLCB3aWR0aCwgaGVpZ2h0LCBpc1ZhbGlkLCBpblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciQ3LCBzaGFsbG93KTtcbiAgICBjb25zdCByZW5kZXJDb25uZWN0aW9uID0gISEod2lkdGggJiYgbm9kZXNDb25uZWN0YWJsZSAmJiBpblByb2dyZXNzKTtcbiAgICBpZiAoIXJlbmRlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbmxpbmUgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2Nvbm5lY3Rpb24nLCBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpXSksIGNoaWxkcmVuOiBqc3goQ29ubmVjdGlvbkxpbmUsIHsgc3R5bGU6IHN0eWxlLCB0eXBlOiB0eXBlLCBDdXN0b21Db21wb25lbnQ6IGNvbXBvbmVudCwgaXNWYWxpZDogaXNWYWxpZCB9KSB9KSB9KSk7XG59XG5jb25zdCBDb25uZWN0aW9uTGluZSA9ICh7IHN0eWxlLCB0eXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgQ3VzdG9tQ29tcG9uZW50LCBpc1ZhbGlkLCB9KSA9PiB7XG4gICAgY29uc3QgeyBpblByb2dyZXNzLCBmcm9tLCBmcm9tTm9kZSwgZnJvbUhhbmRsZSwgZnJvbVBvc2l0aW9uLCB0bywgdG9Ob2RlLCB0b0hhbmRsZSwgdG9Qb3NpdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpO1xuICAgIGlmICghaW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChDdXN0b21Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChqc3goQ3VzdG9tQ29tcG9uZW50LCB7IGNvbm5lY3Rpb25MaW5lVHlwZTogdHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZTogc3R5bGUsIGZyb21Ob2RlOiBmcm9tTm9kZSwgZnJvbUhhbmRsZTogZnJvbUhhbmRsZSwgZnJvbVg6IGZyb20ueCwgZnJvbVk6IGZyb20ueSwgdG9YOiB0by54LCB0b1k6IHRvLnksIGZyb21Qb3NpdGlvbjogZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uOiB0b1Bvc2l0aW9uLCBjb25uZWN0aW9uU3RhdHVzOiBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpLCB0b05vZGU6IHRvTm9kZSwgdG9IYW5kbGU6IHRvSGFuZGxlIH0pKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBjb25zdCBwYXRoUGFyYW1zID0ge1xuICAgICAgICBzb3VyY2VYOiBmcm9tLngsXG4gICAgICAgIHNvdXJjZVk6IGZyb20ueSxcbiAgICAgICAgc291cmNlUG9zaXRpb246IGZyb21Qb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WDogdG8ueCxcbiAgICAgICAgdGFyZ2V0WTogdG8ueSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb246IHRvUG9zaXRpb24sXG4gICAgfTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0QmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TaW1wbGVCZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICAgICAgLi4ucGF0aFBhcmFtcyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TbW9vdGhTdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFN0cmFpZ2h0UGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb24tcGF0aFwiLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuQ29ubmVjdGlvbkxpbmUuZGlzcGxheU5hbWUgPSAnQ29ubmVjdGlvbkxpbmUnO1xuXG5jb25zdCBlbXB0eVR5cGVzID0ge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlT3JFZGdlVHlwZXMgPSBlbXB0eVR5cGVzKSB7XG4gICAgY29uc3QgdHlwZXNSZWYgPSB1c2VSZWYobm9kZU9yRWRnZVR5cGVzKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VkS2V5cyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKHR5cGVzUmVmLmN1cnJlbnQpLCAuLi5PYmplY3Qua2V5cyhub2RlT3JFZGdlVHlwZXMpXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1c2VkS2V5cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1JlZi5jdXJyZW50W2tleV0gIT09IG5vZGVPckVkZ2VUeXBlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMiddKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlc1JlZi5jdXJyZW50ID0gbm9kZU9yRWRnZVR5cGVzO1xuICAgICAgICB9XG4gICAgfSwgW25vZGVPckVkZ2VUeXBlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBjaGVja2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19wYW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUgJiYgISh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYW5lKS56SW5kZXggPT09ICcxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEzJ10oJ3JlYWN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja2VkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBHcmFwaFZpZXdDb21wb25lbnQoeyBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Jbml0LCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIGNvbm5lY3Rpb25MaW5lVHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBkZWxldGVLZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBlbGVtZW50c1NlbGVjdGFibGUsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBkZWZhdWx0TWFya2VyQ29sb3IsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQsIHJmSWQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB9KSB7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlVHlwZXMpO1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcoZWRnZVR5cGVzKTtcbiAgICB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCk7XG4gICAgdXNlT25Jbml0SGFuZGxlcihvbkluaXQpO1xuICAgIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIChqc3goRmxvd1JlbmRlcmVyLCB7IG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZTogZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlOiBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlOiBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiAhIXZpZXdwb3J0LCBjaGlsZHJlbjoganN4cyhWaWV3cG9ydCwgeyBjaGlsZHJlbjogW2pzeChFZGdlUmVuZGVyZXIsIHsgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgb25FZGdlQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQ6IHJmSWQgfSksIGpzeChDb25uZWN0aW9uTGluZVdyYXBwZXIsIHsgc3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIHR5cGU6IGNvbm5lY3Rpb25MaW5lVHlwZSwgY29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXJcIiB9KSwganN4KE5vZGVSZW5kZXJlciwgeyBub2RlVHlwZXM6IG5vZGVUeXBlcywgb25Ob2RlQ2xpY2s6IG9uTm9kZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXI6IG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZTogb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlOiBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudTogb25Ob2RlQ29udGV4dE1lbnUsIG5vZGVDbGlja0Rpc3RhbmNlOiBub2RlQ2xpY2tEaXN0YW5jZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgcmZJZDogcmZJZCB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0LXBvcnRhbFwiIH0pXSB9KSB9KSk7XG59XG5HcmFwaFZpZXdDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnR3JhcGhWaWV3JztcbmNvbnN0IEdyYXBoVmlldyA9IG1lbW8oR3JhcGhWaWV3Q29tcG9uZW50KTtcblxuY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9ID0ge30pID0+IHtcbiAgICBjb25zdCBub2RlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhcmVudExvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVkZ2VMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RvcmVFZGdlcyA9IGRlZmF1bHRFZGdlcyA/PyBlZGdlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVzID0gZGVmYXVsdE5vZGVzID8/IG5vZGVzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZU9yaWdpbiA9IG5vZGVPcmlnaW4gPz8gWzAsIDBdO1xuICAgIGNvbnN0IHN0b3JlTm9kZUV4dGVudCA9IG5vZGVFeHRlbnQgPz8gaW5maW5pdGVFeHRlbnQ7XG4gICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBzdG9yZUVkZ2VzKTtcbiAgICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gYWRvcHRVc2VyTm9kZXMoc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogZmFsc2UsXG4gICAgfSk7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFswLCAwLCAxXTtcbiAgICBpZiAoZml0VmlldyAmJiB3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2RlTG9va3VwLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhISgobm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkgJiYgKG5vZGUuaGVpZ2h0IHx8IG5vZGUuaW5pdGlhbEhlaWdodCkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIGZpdFZpZXdPcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgIHRyYW5zZm9ybSA9IFt4LCB5LCB6b29tXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmZJZDogJzEnLFxuICAgICAgICB3aWR0aDogd2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBub2Rlczogc3RvcmVOb2RlcyxcbiAgICAgICAgbm9kZXNJbml0aWFsaXplZCxcbiAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgcGFyZW50TG9va3VwLFxuICAgICAgICBlZGdlczogc3RvcmVFZGdlcyxcbiAgICAgICAgZWRnZUxvb2t1cCxcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cCxcbiAgICAgICAgb25Ob2Rlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgb25FZGdlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgaGFzRGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgaGFzRGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuWm9vbTogbnVsbCxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IENvbm5lY3Rpb25Nb2RlLlN0cmljdCxcbiAgICAgICAgZG9tTm9kZTogbnVsbCxcbiAgICAgICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZURyYWdUaHJlc2hvbGQ6IDEsXG4gICAgICAgIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBzbmFwR3JpZDogWzE1LCAxNV0sXG4gICAgICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgICAgICBub2Rlc0RyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIGVkZ2VzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc1JlY29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWc6IHRydWUsXG4gICAgICAgIG11bHRpU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZml0Vmlld1F1ZXVlZDogZml0VmlldyA/PyBmYWxzZSxcbiAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcjogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCxcbiAgICAgICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgICAgIGFyaWFMaXZlTWVzc2FnZTogJycsXG4gICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IHRydWUsXG4gICAgICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRm9jdXM6IHRydWUsXG4gICAgICAgIGF1dG9QYW5TcGVlZDogMTUsXG4gICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgICAgICBvbkVycm9yOiBkZXZXYXJuLFxuICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBbXSxcbiAgICAgICAgbGliOiAncmVhY3QnLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGFyaWFMYWJlbENvbmZpZzogZGVmYXVsdEFyaWFMYWJlbENvbmZpZyxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSkgPT4gY3JlYXRlV2l0aEVxdWFsaXR5Rm4oKHNldCwgZ2V0KSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUZpdFZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFuWm9vbSwgZml0Vmlld09wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZpdFZpZXdwb3J0KHtcbiAgICAgICAgICAgIG5vZGVzOiBub2RlTG9va3VwLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgZml0Vmlld1Jlc29sdmVyPy5yZXNvbHZlKHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogd2FpdCBmb3IgdGhlIGZpdFZpZXdwb3J0IHRvIHJlc29sdmUgYmVmb3JlIGRlbGV0aW5nIHRoZSByZXNvbHZlcixcbiAgICAgICAgICogd2Ugd2FudCB0byByZXVzZSB0aGUgb2xkIHJlc29sdmVyIGlmIHRoZSB1c2VyIGNhbGxzIGZpdFZpZXcgYWdhaW4gaW4gdGhlIG1lYW4gdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHsgZml0Vmlld1Jlc29sdmVyOiBudWxsIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXRJbml0aWFsU3RhdGUoe1xuICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgZml0VmlldyxcbiAgICAgICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlcyxcbiAgICAgICAgICAgIGRlZmF1bHRFZGdlcyxcbiAgICAgICAgfSksXG4gICAgICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZml0Vmlld1F1ZXVlZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogc2V0Tm9kZXMoKSBpcyBjYWxsZWQgZXhjbHVzaXZlbHkgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zOlxuICAgICAgICAgICAgICogLSBlaXRoZXIgd2hlbiB0aGUgYDxSZWFjdEZsb3cgbm9kZXM+YCBwcm9wIGlzIHVwZGF0ZWQgaW4gdGhlIGNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLFxuICAgICAgICAgICAgICogLSBvciB3aGVuIHRoZSB1c2VyIGNhbGxzIHNvbWV0aGluZyBsaWtlIGByZWFjdEZsb3dJbnN0YW5jZS5zZXROb2RlcygpYCBpbiBhbiB1bmNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSB0YWtlIHRoZSBub3RlIG9iamVjdHMgcGFzc2VkIGJ5IHRoZSB1c2VyIGFuZCBleHRlbmQgdGhlbSB3aXRoIGZpZWxkc1xuICAgICAgICAgICAgICogcmVsZXZhbnQgZm9yIGludGVybmFsIFJlYWN0IEZsb3cgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQgJiYgbm9kZXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaXRWaWV3KCk7XG4gICAgICAgICAgICAgICAgc2V0KHsgbm9kZXMsIG5vZGVzSW5pdGlhbGl6ZWQsIGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0KHsgbm9kZXMsIG5vZGVzSW5pdGlhbGl6ZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVkZ2VzOiAoZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIGVkZ2VzKTtcbiAgICAgICAgICAgIHNldCh7IGVkZ2VzIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIHNldCh7IGhhc0RlZmF1bHROb2RlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0RWRnZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldEVkZ2VzKGVkZ2VzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0RWRnZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIEV2ZXJ5IG5vZGUgZ2V0cyByZWdpc3RlcmQgYXQgYSBSZXNpemVPYnNlcnZlci4gV2hlbmV2ZXIgYSBub2RlXG4gICAgICAgICAqIGNoYW5nZXMgaXRzIGRpbWVuc2lvbnMsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIG1lYXN1cmUgdGhlXG4gICAgICAgICAqIG5ldyBkaW1lbnNpb25zIGFuZCB1cGRhdGUgdGhlIG5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTm9kZUludGVybmFsczogKHVwZGF0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGRlYnVnLCBmaXRWaWV3UXVldWVkIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9ID0gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVkSW50ZXJuYWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMobm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSk7XG4gICAgICAgICAgICBpZiAoZml0Vmlld1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaXRWaWV3KCk7XG4gICAgICAgICAgICAgICAgc2V0KHsgZml0Vmlld1F1ZXVlZDogZmFsc2UsIGZpdFZpZXdPcHRpb25zOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHdheXMgd2FudCB0byB0cmlnZ2VyIHVzZVN0b3JlIGNhbGxzIHdoZW5ldmVyIHVwZGF0ZU5vZGVJbnRlcm5hbHMgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgc2V0KHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9uczogKG5vZGVEcmFnSXRlbXMsIGRyYWdnaW5nID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoaWxkcmVuID0gW107XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIG5vZGVEcmFnSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlIG5vZGVsb29rdXAgdG8gYmUgc3VyZSB0byB1c2UgdGhlIGN1cnJlbnQgZXhwYW5kUGFyZW50IGFuZCBwYXJlbnRJZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kUGFyZW50ID0gISEobm9kZT8uZXhwYW5kUGFyZW50ICYmIG5vZGU/LnBhcmVudElkICYmIGRyYWdJdGVtPy5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cGFuZFBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoMCwgZHJhZ0l0ZW0ucG9zaXRpb24ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5tYXgoMCwgZHJhZ0l0ZW0ucG9zaXRpb24ueSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFeHBhbmRDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRyYWdJdGVtLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIHNldE5vZGVzLCBub2RlcywgaGFzRGVmYXVsdE5vZGVzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm9kZXModXBkYXRlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlczogKGNoYW5nZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25FZGdlc0NoYW5nZSwgc2V0RWRnZXMsIGVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIGRlYnVnIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRFZGdlcyA9IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFZGdlcyh1cGRhdGVkRWRnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgZWRnZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlczogKHNlbGVjdGVkTm9kZUlkcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgZWRnZUxvb2t1cCwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBzZWxlY3RlZE5vZGVJZHMubWFwKChub2RlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShub2RlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkTm9kZUlkc10pLCB0cnVlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkRWRnZXM6IChzZWxlY3RlZEVkZ2VJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VkRWRnZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkRWRnZUlkc10pKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KCksIHRydWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzOiAoeyBub2RlcywgZWRnZXMgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzOiBzdG9yZUVkZ2VzLCBub2Rlczogc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXMgPyBub2RlcyA6IHN0b3JlTm9kZXM7XG4gICAgICAgICAgICBjb25zdCBlZGdlc1RvVW5zZWxlY3QgPSBlZGdlcyA/IGVkZ2VzIDogc3RvcmVFZGdlcztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbm9kZXNUb1Vuc2VsZWN0Lm1hcCgobikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byB1bnNlbGVjdCB0aGUgaW50ZXJuYWwgbm9kZSB0aGF0IHdhcyBzZWxlY3RlZCBwcmV2aW91c2x5IGJlZm9yZSB3ZVxuICAgICAgICAgICAgICAgICAgICAgKiBzZW5kIHRoZSBjaGFuZ2UgdG8gdGhlIHVzZXIgdG8gcHJldmVudCBpdCB0byBiZSBzZWxlY3RlZCB3aGlsZSBkcmFnZ2luZyB0aGUgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsTm9kZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG4uaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlc1RvVW5zZWxlY3QubWFwKChlZGdlKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtYXhab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgICAgICBzZXQoeyBtaW5ab29tIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRNYXhab29tOiAobWF4Wm9vbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgICAgICBzZXQoeyBtYXhab29tIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6ICh0cmFuc2xhdGVFeHRlbnQpID0+IHtcbiAgICAgICAgICAgIGdldCgpLnBhblpvb20/LnNldFRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICAgICAgc2V0KHsgdHJhbnNsYXRlRXh0ZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQYW5lQ2xpY2tEaXN0YW5jZTogKGNsaWNrRGlzdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGdldCgpLnBhblpvb20/LnNldENsaWNrRGlzdGFuY2UoY2xpY2tEaXN0YW5jZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50czogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBlbGVtZW50c1NlbGVjdGFibGUgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50c1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzLnJlZHVjZSgocmVzLCBub2RlKSA9PiAobm9kZS5zZWxlY3RlZCA/IFsuLi5yZXMsIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShub2RlLmlkLCBmYWxzZSldIDogcmVzKSwgW10pO1xuICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlcy5yZWR1Y2UoKHJlcywgZWRnZSkgPT4gKGVkZ2Uuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXROb2RlRXh0ZW50OiAobmV4dE5vZGVFeHRlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVFeHRlbnQgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG5leHROb2RlRXh0ZW50WzBdWzBdID09PSBub2RlRXh0ZW50WzBdWzBdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMF1bMV0gPT09IG5vZGVFeHRlbnRbMF1bMV0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVswXSA9PT0gbm9kZUV4dGVudFsxXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzFdWzFdID09PSBub2RlRXh0ZW50WzFdWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgbm9kZUV4dGVudDogbmV4dE5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldCh7IG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBwYW5CeTogKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYW5CeSh7IGRlbHRhLCBwYW5ab29tLCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2VudGVyOiBhc3luYyAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtYXhab29tLCBwYW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0eXBlb2Ygb3B0aW9ucz8uem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnpvb20gOiBtYXhab29tO1xuICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgeDogd2lkdGggLyAyIC0geCAqIG5leHRab29tLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb20sXG4gICAgICAgICAgICAgICAgem9vbTogbmV4dFpvb20sXG4gICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiwgZWFzZTogb3B0aW9ucz8uZWFzZSwgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiB7IC4uLmluaXRpYWxDb25uZWN0aW9uIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbjogKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNldCh7IGNvbm5lY3Rpb24gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiBzZXQoeyAuLi5nZXRJbml0aWFsU3RhdGUoKSB9KSxcbiAgICB9O1xufSwgT2JqZWN0LmlzKTtcblxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IGlzIGEgW2NvbnRleHQgcHJvdmlkZXJdKGh0dHBzOi8vcmVhY3QuZGV2L2xlYXJuL3Bhc3NpbmctZGF0YS1kZWVwbHktd2l0aC1jb250ZXh0IylcbiAqIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gYWNjZXNzIGEgZmxvdydzIGludGVybmFsIHN0YXRlIG91dHNpZGUgb2YgdGhlXG4gKiBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93KSBjb21wb25lbnQuIE1hbnkgb2YgdGhlIGhvb2tzIHdlXG4gKiBwcm92aWRlIHJlbHkgb24gdGhpcyBjb21wb25lbnQgdG8gd29yay5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dQcm92aWRlcj5cbiAqICAgICAgPFJlYWN0RmxvdyBub2Rlcz17Li4ufSBlZGdlcz17Li4ufSAvPlxuICogICAgICA8U2lkZWJhciAvPlxuICogICAgPC9SZWFjdEZsb3dQcm92aWRlcj5cbiAqICApO1xuICp9XG4gKlxuICpmdW5jdGlvbiBTaWRlYmFyKCkge1xuICogIC8vIFRoaXMgaG9vayB3aWxsIG9ubHkgd29yayBpZiB0aGUgY29tcG9uZW50IGl0J3MgdXNlZCBpbiBpcyBhIGNoaWxkIG9mIGFcbiAqICAvLyA8UmVhY3RGbG93UHJvdmlkZXIgLz4uXG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpXG4gKlxuICogIHJldHVybiA8YXNpZGU+ZG8gc29tZXRoaW5nIHdpdGggbm9kZXM8L2FzaWRlPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UncmUgdXNpbmcgYSByb3V0ZXIgYW5kIHdhbnQgeW91ciBmbG93J3Mgc3RhdGUgdG8gcGVyc2lzdCBhY3Jvc3Mgcm91dGVzLFxuICogaXQncyB2aXRhbCB0aGF0IHlvdSBwbGFjZSB0aGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IF9vdXRzaWRlXyBvZlxuICogeW91ciByb3V0ZXIuIElmIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIHRoZSBzYW1lIHBhZ2UgeW91IHdpbGwgbmVlZCB0byB1c2UgYSBzZXBhcmF0ZVxuICogYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgZm9yIGVhY2ggZmxvdy5cbiAqL1xuZnVuY3Rpb24gUmVhY3RGbG93UHJvdmlkZXIoeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBpbml0aWFsTWluWm9vbTogbWluWm9vbSwgaW5pdGlhbE1heFpvb206IG1heFpvb20sIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGZpdFZpZXcsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3QgW3N0b3JlXSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZVN0b3JlKHtcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIGVkZ2VzLFxuICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgIGRlZmF1bHRFZGdlcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZml0VmlldyxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQsXG4gICAgfSkpO1xuICAgIHJldHVybiAoanN4KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlLCBjaGlsZHJlbjoganN4KEJhdGNoUHJvdmlkZXIsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gV3JhcHBlcih7IGNoaWxkcmVuLCBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSkge1xuICAgIGNvbnN0IGlzV3JhcHBlZCA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoaXNXcmFwcGVkKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIG5lZWQgdG8gd3JhcCBpdCB3aXRoIGEgZnJhZ21lbnQgYmVjYXVzZSBpdCdzIG5vdCBhbGxvd2VkIGZvciBjaGlsZHJlbiB0byBiZSBhIFJlYWN0Tm9kZVxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9pc3N1ZXMvMTgwNTFcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChSZWFjdEZsb3dQcm92aWRlciwgeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgaW5pdGlhbEZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAwLFxufTtcbmZ1bmN0aW9uIFJlYWN0Rmxvdyh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Jbml0LCBvbk1vdmUsIG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQsIG9uQ29ubmVjdCwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZSwgb25TZWxlY3Rpb25DaGFuZ2UsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvbkJlZm9yZURlbGV0ZSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMgPSBmYWxzZSwgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXMsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBub2RlT3JpZ2luID0gZGVmYXVsdE5vZGVPcmlnaW4sIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0JDEgPSBkZWZhdWx0Vmlld3BvcnQsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCB0cmFuc2xhdGVFeHRlbnQgPSBpbmZpbml0ZUV4dGVudCwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIG5vZGVFeHRlbnQsIGRlZmF1bHRNYXJrZXJDb2xvciA9ICcjYjFiMWI3Jywgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSA9IDAsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgY2hpbGRyZW4sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgY29ubmVjdE9uQ2xpY2ssIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0LCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQsIGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uLCBvbkVycm9yLCBzdHlsZSwgaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIHdpZHRoLCBoZWlnaHQsIGNvbG9yTW9kZSA9ICdsaWdodCcsIGRlYnVnLCBvblNjcm9sbCwgYXJpYUxhYmVsQ29uZmlnLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHJmSWQgPSBpZCB8fCAnMSc7XG4gICAgY29uc3QgY29sb3JNb2RlQ2xhc3NOYW1lID0gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAvLyBVbmRvIHNjcm9sbCBldmVudHMsIHByZXZlbnRpbmcgdmlld3BvcnQgZnJvbSBzaGlmdGluZyB3aGVuIG5vZGVzIG91dHNpZGUgb2YgaXQgYXJlIGZvY3VzZWRcbiAgICBjb25zdCB3cmFwcGVyT25TY3JvbGwgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsVG8oeyB0b3A6IDAsIGxlZnQ6IDAsIGJlaGF2aW9yOiAnaW5zdGFudCcgfSk7XG4gICAgICAgIG9uU2Nyb2xsPy4oZSk7XG4gICAgfSwgW29uU2Nyb2xsXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgLi4ucmVzdCwgb25TY3JvbGw6IHdyYXBwZXJPblNjcm9sbCwgc3R5bGU6IHsgLi4uc3R5bGUsIC4uLndyYXBwZXJTdHlsZSB9LCByZWY6IHJlZiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3cnLCBjbGFzc05hbWUsIGNvbG9yTW9kZUNsYXNzTmFtZV0pLCBpZDogaWQsIHJvbGU6IFwiYXBwbGljYXRpb25cIiwgY2hpbGRyZW46IGpzeHMoV3JhcHBlciwgeyBub2Rlczogbm9kZXMsIGVkZ2VzOiBlZGdlcywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXM6IGF1dG9QYW5Pbk5vZGVGb2N1cywgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdDogZWxldmF0ZUVkZ2VzT25TZWxlY3QsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIG9uTm9kZXNDaGFuZ2U6IG9uTm9kZXNDaGFuZ2UsIG9uRWRnZXNDaGFuZ2U6IG9uRWRnZXNDaGFuZ2UsIHNuYXBUb0dyaWQ6IHNuYXBUb0dyaWQsIHNuYXBHcmlkOiBzbmFwR3JpZCwgY29ubmVjdGlvbk1vZGU6IGNvbm5lY3Rpb25Nb2RlLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgY29ubmVjdE9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrLCBkZWZhdWx0RWRnZU9wdGlvbnM6IGRlZmF1bHRFZGdlT3B0aW9ucywgZml0VmlldzogZml0VmlldywgZml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBvbk5vZGVzRGVsZXRlOiBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlOiBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZTogb25EZWxldGUsIG9uTm9kZURyYWdTdGFydDogb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnOiBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcDogb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZzogb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdGFydDogb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0b3A6IG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uTW92ZTogb25Nb3ZlLCBvbk1vdmVTdGFydDogb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZDogb25Nb3ZlRW5kLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIHJmSWQ6IHJmSWQsIGF1dG9QYW5PbkNvbm5lY3Q6IGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnOiBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkOiBhdXRvUGFuU3BlZWQsIG9uRXJyb3I6IG9uRXJyb3IsIGNvbm5lY3Rpb25SYWRpdXM6IGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiwgc2VsZWN0Tm9kZXNPbkRyYWc6IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZDogbm9kZURyYWdUaHJlc2hvbGQsIGNvbm5lY3Rpb25EcmFnVGhyZXNob2xkOiBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlYnVnOiBkZWJ1ZywgYXJpYUxhYmVsQ29uZmlnOiBhcmlhTGFiZWxDb25maWcgfSksIGpzeChTZWxlY3Rpb25MaXN0ZW5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSksIGNoaWxkcmVuLCBqc3goQXR0cmlidXRpb24sIHsgcHJvT3B0aW9uczogcHJvT3B0aW9ucywgcG9zaXRpb246IGF0dHJpYnV0aW9uUG9zaXRpb24gfSksIGpzeChBMTF5RGVzY3JpcHRpb25zLCB7IHJmSWQ6IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSldIH0pIH0pKTtcbn1cbi8qKlxuICogVGhlIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQgaXMgdGhlIGhlYXJ0IG9mIHlvdXIgUmVhY3QgRmxvdyBhcHBsaWNhdGlvbi5cbiAqIEl0IHJlbmRlcnMgeW91ciBub2RlcyBhbmQgZWRnZXMgYW5kIGhhbmRsZXMgdXNlciBpbnRlcmFjdGlvblxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoPFJlYWN0Rmxvd1xuICogICAgbm9kZXM9ey4uLn1cbiAqICAgIGVkZ2VzPXsuLi59XG4gKiAgICBvbk5vZGVzQ2hhbmdlPXsuLi59XG4gKiAgICAuLi5cbiAqICAvPik7XG4gKn1cbiAqYGBgXG4gKi9cbnZhciBpbmRleCA9IGZpeGVkRm9yd2FyZFJlZihSZWFjdEZsb3cpO1xuXG5jb25zdCBzZWxlY3RvciQ2ID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlcicpO1xuLyoqXG4gKiBFZGdlcyBhcmUgU1ZHLWJhc2VkLiBJZiB5b3Ugd2FudCB0byByZW5kZXIgbW9yZSBjb21wbGV4IGxhYmVscyB5b3UgY2FuIHVzZSB0aGVcbiAqIGA8RWRnZUxhYmVsUmVuZGVyZXIgLz5gIGNvbXBvbmVudCB0byBhY2Nlc3MgYSBkaXYgYmFzZWQgcmVuZGVyZXIuIFRoaXMgY29tcG9uZW50XG4gKiBpcyBhIHBvcnRhbCB0aGF0IHJlbmRlcnMgdGhlIGxhYmVsIGluIGEgYDxkaXYgLz5gIHRoYXQgaXMgcG9zaXRpb25lZCBvbiB0b3Agb2ZcbiAqIHRoZSBlZGdlcy4gWW91IGNhbiBzZWUgYW4gZXhhbXBsZSB1c2FnZSBvZiB0aGUgY29tcG9uZW50IGluIHRoZVxuICogW2VkZ2UgbGFiZWwgcmVuZGVyZXIgZXhhbXBsZV0oL2V4YW1wbGVzL2VkZ2VzL2VkZ2UtbGFiZWwtcmVuZGVyZXIpLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKiBpbXBvcnQgeyBnZXRCZXppZXJQYXRoLCBFZGdlTGFiZWxSZW5kZXJlciwgQmFzZUVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IGlkLCBkYXRhLCAuLi5wcm9wcyB9KSB7XG4gKiAgIGNvbnN0IFtlZGdlUGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0QmV6aWVyUGF0aChwcm9wcyk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDw+XG4gKiAgICAgICA8QmFzZUVkZ2UgaWQ9e2lkfSBwYXRoPXtlZGdlUGF0aH0gLz5cbiAqICAgICAgIDxFZGdlTGFiZWxSZW5kZXJlcj5cbiAqICAgICAgICAgPGRpdlxuICogICAgICAgICAgIHN0eWxlPXt7XG4gKiAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAqICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSB0cmFuc2xhdGUoJHtsYWJlbFh9cHgsJHtsYWJlbFl9cHgpYCxcbiAqICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZjYzAwJyxcbiAqICAgICAgICAgICAgIHBhZGRpbmc6IDEwLFxuICogICAgICAgICB9fVxuICogICAgICAgICAgIGNsYXNzTmFtZT1cIm5vZHJhZyBub3BhblwiXG4gKiAgICAgICAgID5cbiAqICAgICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgIDwvRWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgPC8+XG4gKiAgICk7XG4gKiB9O1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhlIGA8RWRnZUxhYmVsUmVuZGVyZXIgLz5gIGhhcyBubyBwb2ludGVyIGV2ZW50cyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0b1xuICogYWRkIG1vdXNlIGludGVyYWN0aW9ucyB5b3UgbmVlZCB0byBzZXQgdGhlIHN0eWxlIGBwb2ludGVyRXZlbnRzOiBhbGxgIGFuZCBhZGRcbiAqIHRoZSBgbm9wYW5gIGNsYXNzIG9uIHRoZSBsYWJlbCBvciB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBpbnRlcmFjdCB3aXRoLlxuICovXG5mdW5jdGlvbiBFZGdlTGFiZWxSZW5kZXJlcih7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCBlZGdlTGFiZWxSZW5kZXJlciA9IHVzZVN0b3JlKHNlbGVjdG9yJDYpO1xuICAgIGlmICghZWRnZUxhYmVsUmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGVkZ2VMYWJlbFJlbmRlcmVyKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNSA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWwnKTtcbi8qKlxuICogVGhlIGA8Vmlld3BvcnRQb3J0YWwgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgY29tcG9uZW50cyB0byB0aGUgc2FtZSB2aWV3cG9ydFxuICogb2YgdGhlIGZsb3cgd2hlcmUgbm9kZXMgYW5kIGVkZ2VzIGFyZSByZW5kZXJlZC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZW5kZXJcbiAqIHlvdXIgb3duIGNvbXBvbmVudHMgdGhhdCBhcmUgYWRoZXJlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtIGFzIHRoZSBub2RlcyAmIGVkZ2VzXG4gKiBhbmQgYXJlIGFsc28gYWZmZWN0ZWQgYnkgem9vbWluZyBhbmQgcGFubmluZ1xuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgVmlld3BvcnRQb3J0YWwgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFZpZXdwb3J0UG9ydGFsPlxuICogICAgICA8ZGl2XG4gKiAgICAgICAgc3R5bGU9e3sgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEwMHB4LCAxMDBweCknLCBwb3NpdGlvbjogJ2Fic29sdXRlJyB9fVxuICogICAgICA+XG4gKiAgICAgICAgVGhpcyBkaXYgaXMgcG9zaXRpb25lZCBhdCBbMTAwLCAxMDBdIG9uIHRoZSBmbG93LlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvVmlld3BvcnRQb3J0YWw+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gVmlld3BvcnRQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3Qgdmlld1BvcnRhbERpdiA9IHVzZVN0b3JlKHNlbGVjdG9yJDUpO1xuICAgIGlmICghdmlld1BvcnRhbERpdikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgdmlld1BvcnRhbERpdik7XG59XG5cbi8qKlxuICogV2hlbiB5b3UgcHJvZ3JhbW1hdGljYWxseSBhZGQgb3IgcmVtb3ZlIGhhbmRsZXMgdG8gYSBub2RlIG9yIHVwZGF0ZSBhIG5vZGUnc1xuICogaGFuZGxlIHBvc2l0aW9uLCB5b3UgbmVlZCB0byBsZXQgUmVhY3QgRmxvdyBrbm93IGFib3V0IGl0IHVzaW5nIHRoaXMgaG9vay4gVGhpc1xuICogd2lsbCB1cGRhdGUgdGhlIGludGVybmFsIGRpbWVuc2lvbnMgb2YgdGhlIG5vZGUgYW5kIHByb3Blcmx5IHJlcG9zaXRpb24gaGFuZGxlc1xuICogb24gdGhlIGNhbnZhcyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVXNlIHRoaXMgZnVuY3Rpb24gdG8gdGVsbCBSZWFjdCBGbG93IHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWwgc3RhdGUgb2Ygb25lIG9yIG1vcmUgbm9kZXNcbiAqIHRoYXQgeW91IGhhdmUgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhbmRvbUhhbmRsZU5vZGUoeyBpZCB9KSB7XG4gKiAgY29uc3QgdXBkYXRlTm9kZUludGVybmFscyA9IHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKTtcbiAqICBjb25zdCBbaGFuZGxlQ291bnQsIHNldEhhbmRsZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuICogIGNvbnN0IHJhbmRvbWl6ZUhhbmRsZUNvdW50ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICogICBzZXRIYW5kbGVDb3VudChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkpO1xuICogICAgdXBkYXRlTm9kZUludGVybmFscyhpZCk7XG4gKiAgfSwgW2lkLCB1cGRhdGVOb2RlSW50ZXJuYWxzXSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICB7QXJyYXkuZnJvbSh7IGxlbmd0aDogaGFuZGxlQ291bnQgfSkubWFwKChfLCBpbmRleCkgPT4gKFxuICogICAgICAgIDxIYW5kbGVcbiAqICAgICAgICAgIGtleT17aW5kZXh9XG4gKiAgICAgICAgICB0eXBlPVwidGFyZ2V0XCJcbiAqICAgICAgICAgIHBvc2l0aW9uPVwibGVmdFwiXG4gKiAgICAgICAgICBpZD17YGhhbmRsZS0ke2luZGV4fWB9XG4gKiAgICAgICAgLz5cbiAqICAgICAgKSl9XG4gKlxuICogICAgICA8ZGl2PlxuICogICAgICAgIDxidXR0b24gb25DbGljaz17cmFuZG9taXplSGFuZGxlQ291bnR9PlJhbmRvbWl6ZSBoYW5kbGUgY291bnQ8L2J1dHRvbj5cbiAqICAgICAgICA8cD5UaGVyZSBhcmUge2hhbmRsZUNvdW50fSBoYW5kbGVzIG9uIHRoaXMgbm9kZS48L3A+XG4gKiAgICAgIDwvZGl2PlxuICogICAgPC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBjYW4gb25seSBiZSB1c2VkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYSBjaGlsZCBvZiBhXG4gKntAbGluayBSZWFjdEZsb3dQcm92aWRlcn0gb3IgYSB7QGxpbmsgUmVhY3RGbG93fSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoaWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb21Ob2RlLCB1cGRhdGVOb2RlSW50ZXJuYWxzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVJZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdXBkYXRlSWRzLmZvckVhY2goKHVwZGF0ZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlRWxlbWVudCA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoYC5yZWFjdC1mbG93X19ub2RlW2RhdGEtaWQ9XCIke3VwZGF0ZUlkfVwiXWApO1xuICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5zZXQodXBkYXRlSWQsIHsgaWQ6IHVwZGF0ZUlkLCBub2RlRWxlbWVudCwgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCB7IHRyaWdnZXJGaXRWaWV3OiBmYWxzZSB9KSk7XG4gICAgfSwgW10pO1xufVxuXG5jb25zdCBub2Rlc1NlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5ub2Rlcztcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgbm9kZXMuIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rXG4gKiB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIGFueSBub2RlIGNoYW5nZXMqKiwgaW5jbHVkaW5nIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkXG4gKiBvciBtb3ZlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgbm9kZXMgY3VycmVudGx5IGluIHRoZSBmbG93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICogIGNvbnN0IG5vZGVzID0gdXNlTm9kZXMoKTtcbiAqXG4gKiAgcmV0dXJuIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7bm9kZXMubGVuZ3RofSBub2RlcyE8L2Rpdj47XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzKCkge1xuICAgIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUobm9kZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuXG5jb25zdCBlZGdlc1NlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5lZGdlcztcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgZWRnZXMuIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rXG4gKiB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIGFueSBlZGdlIGNoYW5nZXMqKi5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgZWRnZXMgY3VycmVudGx5IGluIHRoZSBmbG93LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlRWRnZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBlZGdlcyA9IHVzZUVkZ2VzKCk7XG4gKlxuICogIHJldHVybiA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2VkZ2VzLmxlbmd0aH0gZWRnZXMhPC9kaXY+O1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VFZGdlcygpIHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKGVkZ2VzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlcztcbn1cblxuY29uc3Qgdmlld3BvcnRTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbn0pO1xuLyoqXG4gKiBUaGUgYHVzZVZpZXdwb3J0YCBob29rIGlzIGEgY29udmVuaWVudCB3YXkgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAqIHtAbGluayBWaWV3cG9ydH0gaW4gYSBjb21wb25lbnQuIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rXG4gKiB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSB2aWV3cG9ydCBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyB1c2VWaWV3cG9ydCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVmlld3BvcnREaXNwbGF5KCkge1xuICogIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gdXNlVmlld3BvcnQoKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxwPlxuICogICAgICAgIFRoZSB2aWV3cG9ydCBpcyBjdXJyZW50bHkgYXQgKHt4fSwge3l9KSBhbmQgem9vbWVkIHRvIHt6b29tfS5cbiAqICAgICAgPC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgY2FuIG9ubHkgYmUgdXNlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGEgY2hpbGQgb2YgYVxuICp7QGxpbmsgUmVhY3RGbG93UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFJlYWN0Rmxvd30gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiB1c2VWaWV3cG9ydCgpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHVzZVN0b3JlKHZpZXdwb3J0U2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiB2aWV3cG9ydDtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgbWFrZXMgaXQgZWFzeSB0byBwcm90b3R5cGUgYSBjb250cm9sbGVkIGZsb3cgd2hlcmUgeW91IG1hbmFnZSB0aGVcbiAqIHN0YXRlIG9mIG5vZGVzIGFuZCBlZGdlcyBvdXRzaWRlIHRoZSBgUmVhY3RGbG93SW5zdGFuY2VgLiBZb3UgY2FuIHRoaW5rIG9mIGl0XG4gKiBsaWtlIFJlYWN0J3MgYHVzZVN0YXRlYCBob29rIHdpdGggYW4gYWRkaXRpb25hbCBoZWxwZXIgY2FsbGJhY2suXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnNcbiAqIC0gYG5vZGVzYDogVGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMuIFlvdSBtaWdodCBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBub2Rlc2AgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LCBvciB5b3UgbWF5IHdhbnQgdG8gbWFuaXB1bGF0ZSBpdCBmaXJzdCB0byBwZXJmb3JtIHNvbWUgbGF5b3V0aW5nLFxuICogZm9yIGV4YW1wbGUuXG4gKiAtIGBzZXROb2Rlc2A6IEEgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIHVzZSB0byB1cGRhdGUgdGhlIG5vZGVzLiBZb3UgY2FuIHBhc3MgaXQgYSBuZXcgYXJyYXkgb2ZcbiAqIG5vZGVzIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBhcnJheSBvZiBub2RlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBub2Rlcy5cbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSB0dXBsZSByZXR1cm5lZCBieSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vay5cbiAqIC0gYG9uTm9kZXNDaGFuZ2VgOiBBIGhhbmR5IGNhbGxiYWNrIHRoYXQgY2FuIHRha2UgYW4gYXJyYXkgb2YgYE5vZGVDaGFuZ2VzYCBhbmQgdXBkYXRlIHRoZSBub2Rlc1xuICogc3RhdGUgYWNjb3JkaW5nbHkuIFlvdSdsbCB0eXBpY2FsbHkgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgb25Ob2Rlc0NoYW5nZWAgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LlxuICogQGV4YW1wbGVcbiAqXG4gKmBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU5vZGVzU3RhdGUsIHVzZUVkZ2VzU3RhdGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IGluaXRpYWxOb2RlcyA9IFtdO1xuICpjb25zdCBpbml0aWFsRWRnZXMgPSBbXTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXSA9IHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXSA9IHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dcbiAqICAgICAgbm9kZXM9e25vZGVzfVxuICogICAgICBlZGdlcz17ZWRnZXN9XG4gKiAgICAgIG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9XG4gKiAgICAgIG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9XG4gKiAgICAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHdhcyBjcmVhdGVkIHRvIG1ha2UgcHJvdG90eXBpbmcgZWFzaWVyIGFuZCBvdXIgZG9jdW1lbnRhdGlvblxuICogZXhhbXBsZXMgY2xlYXJlci4gQWx0aG91Z2ggaXQgaXMgT0sgdG8gdXNlIHRoaXMgaG9vayBpbiBwcm9kdWN0aW9uLCBpblxuICogcHJhY3RpY2UgeW91IG1heSB3YW50IHRvIHVzZSBhIG1vcmUgc29waGlzdGljYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IHNvbHV0aW9uXG4gKiBsaWtlIFp1c3RhbmQge0BsaW5rIGh0dHBzOi8vcmVhY3RmbG93LmRldi9kb2NzL2d1aWRlcy9zdGF0ZS1tYW5hZ2VtZW50L30gaW5zdGVhZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKSB7XG4gICAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShpbml0aWFsTm9kZXMpO1xuICAgIGNvbnN0IG9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0Tm9kZXMoKG5kcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBuZHMpKSwgW10pO1xuICAgIHJldHVybiBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXTtcbn1cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBlZGdlc2A6IFRoZSBjdXJyZW50IGFycmF5IG9mIGVkZ2VzLiBZb3UgbWlnaHQgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgZWRnZXNgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCwgb3IgeW91IG1heSB3YW50IHRvIG1hbmlwdWxhdGUgaXQgZmlyc3QgdG8gcGVyZm9ybSBzb21lIGxheW91dGluZyxcbiAqIGZvciBleGFtcGxlLlxuICpcbiAqIC0gYHNldEVkZ2VzYDogQSBmdW5jdGlvbiB0aGF0IHlvdSBjYW4gdXNlIHRvIHVwZGF0ZSB0aGUgZWRnZXMuIFlvdSBjYW4gcGFzcyBpdCBhIG5ldyBhcnJheSBvZlxuICogZWRnZXMgb3IgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBjdXJyZW50IGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVkZ2VzLlxuICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHR1cGxlIHJldHVybmVkIGJ5IFJlYWN0J3MgYHVzZVN0YXRlYCBob29rLlxuICpcbiAqIC0gYG9uRWRnZXNDaGFuZ2VgOiBBIGhhbmR5IGNhbGxiYWNrIHRoYXQgY2FuIHRha2UgYW4gYXJyYXkgb2YgYEVkZ2VDaGFuZ2VzYCBhbmQgdXBkYXRlIHRoZSBlZGdlc1xuICogc3RhdGUgYWNjb3JkaW5nbHkuIFlvdSdsbCB0eXBpY2FsbHkgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgb25FZGdlc0NoYW5nZWAgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LlxuICogQGV4YW1wbGVcbiAqXG4gKmBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU5vZGVzU3RhdGUsIHVzZUVkZ2VzU3RhdGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IGluaXRpYWxOb2RlcyA9IFtdO1xuICpjb25zdCBpbml0aWFsRWRnZXMgPSBbXTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXSA9IHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXSA9IHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dcbiAqICAgICAgbm9kZXM9e25vZGVzfVxuICogICAgICBlZGdlcz17ZWRnZXN9XG4gKiAgICAgIG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9XG4gKiAgICAgIG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9XG4gKiAgICAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHdhcyBjcmVhdGVkIHRvIG1ha2UgcHJvdG90eXBpbmcgZWFzaWVyIGFuZCBvdXIgZG9jdW1lbnRhdGlvblxuICogZXhhbXBsZXMgY2xlYXJlci4gQWx0aG91Z2ggaXQgaXMgT0sgdG8gdXNlIHRoaXMgaG9vayBpbiBwcm9kdWN0aW9uLCBpblxuICogcHJhY3RpY2UgeW91IG1heSB3YW50IHRvIHVzZSBhIG1vcmUgc29waGlzdGljYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IHNvbHV0aW9uXG4gKiBsaWtlIFp1c3RhbmQge0BsaW5rIGh0dHBzOi8vcmVhY3RmbG93LmRldi9kb2NzL2d1aWRlcy9zdGF0ZS1tYW5hZ2VtZW50L30gaW5zdGVhZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKSB7XG4gICAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShpbml0aWFsRWRnZXMpO1xuICAgIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0RWRnZXMoKGVkcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZHMpKSwgW10pO1xuICAgIHJldHVybiBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXTtcbn1cblxuLyoqXG4gKiBUaGUgYHVzZU9uVmlld3BvcnRDaGFuZ2VgIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoZSB2aWV3cG9ydCBzdWNoXG4gKiBhcyBwYW5uaW5nIGFuZCB6b29taW5nLiBZb3UgY2FuIHByb3ZpZGUgYSBjYWxsYmFjayBmb3IgZWFjaCBwaGFzZSBvZiBhIHZpZXdwb3J0XG4gKiBjaGFuZ2U6IGBvblN0YXJ0YCwgYG9uQ2hhbmdlYCwgYW5kIGBvbkVuZGAuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlT25WaWV3cG9ydENoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gVmlld3BvcnRDaGFuZ2VMb2dnZXIoKSB7XG4gKiAgdXNlT25WaWV3cG9ydENoYW5nZSh7XG4gKiAgICBvblN0YXJ0OiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnc3RhcnQnLCB2aWV3cG9ydCksXG4gKiAgICBvbkNoYW5nZTogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2NoYW5nZScsIHZpZXdwb3J0KSxcbiAqICAgIG9uRW5kOiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnZW5kJywgdmlld3BvcnQpLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gbnVsbDtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlT25WaWV3cG9ydENoYW5nZSh7IG9uU3RhcnQsIG9uQ2hhbmdlLCBvbkVuZCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0OiBvblN0YXJ0IH0pO1xuICAgIH0sIFtvblN0YXJ0XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlOiBvbkNoYW5nZSB9KTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VFbmQ6IG9uRW5kIH0pO1xuICAgIH0sIFtvbkVuZF0pO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayBsZXRzIHlvdSBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gYm90aCBub2RlIGFuZCBlZGdlIHNlbGVjdGlvbi4gQXMgdGhlXG4gKm5hbWUgaW1wbGllcywgdGhlIGNhbGxiYWNrIHlvdSBwcm92aWRlIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gb2ZcbiAqX2VpdGhlcl8gbm9kZXMgb3IgZWRnZXMgY2hhbmdlcy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU9uU2VsZWN0aW9uQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBTZWxlY3Rpb25EaXNwbGF5KCkge1xuICogIGNvbnN0IFtzZWxlY3RlZE5vZGVzLCBzZXRTZWxlY3RlZE5vZGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBbc2VsZWN0ZWRFZGdlcywgc2V0U2VsZWN0ZWRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKlxuICogIC8vIHRoZSBwYXNzZWQgaGFuZGxlciBoYXMgdG8gYmUgbWVtb2l6ZWQsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseVxuICogIGNvbnN0IG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHsgbm9kZXMsIGVkZ2VzIH0pID0+IHtcbiAqICAgIHNldFNlbGVjdGVkTm9kZXMobm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gKiAgICBzZXRTZWxlY3RlZEVkZ2VzKGVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICogIH0sIFtdKTtcbiAqXG4gKiAgdXNlT25TZWxlY3Rpb25DaGFuZ2Uoe1xuICogICAgb25DaGFuZ2UsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5TZWxlY3RlZCBub2Rlczoge3NlbGVjdGVkTm9kZXMuam9pbignLCAnKX08L3A+XG4gKiAgICAgIDxwPlNlbGVjdGVkIGVkZ2VzOiB7c2VsZWN0ZWRFZGdlcy5qb2luKCcsICcpfTwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgWW91IG5lZWQgdG8gbWVtb2l6ZSB0aGUgcGFzc2VkIGBvbkNoYW5nZWAgaGFuZGxlciwgb3RoZXJ3aXNlIHRoZSBob29rIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LlxuICovXG5mdW5jdGlvbiB1c2VPblNlbGVjdGlvbkNoYW5nZSh7IG9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzID0gWy4uLnN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycywgb25DaGFuZ2VdO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IG5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEhhbmRsZXJzID0gc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLmZpbHRlcigoZm4pID0+IGZuICE9PSBvbkNoYW5nZSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IG5leHRIYW5kbGVycyB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNCA9IChvcHRpb25zKSA9PiAocykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHMubm9kZXNJbml0aWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHMubm9kZUxvb2t1cC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCB7IGludGVybmFscyB9XSBvZiBzLm5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKGludGVybmFscy5oYW5kbGVCb3VuZHMgPT09IHVuZGVmaW5lZCB8fCAhbm9kZUhhc0RpbWVuc2lvbnMoaW50ZXJuYWxzLnVzZXJOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogVGhpcyBob29rIHRlbGxzIHlvdSB3aGV0aGVyIGFsbCB0aGUgbm9kZXMgaW4gYSBmbG93IGhhdmUgYmVlbiBtZWFzdXJlZCBhbmQgZ2l2ZW5cbiAqYSB3aWR0aCBhbmQgaGVpZ2h0LiBXaGVuIHlvdSBhZGQgYSBub2RlIHRvIHRoZSBmbG93LCB0aGlzIGhvb2sgd2lsbCByZXR1cm5cbiAqYGZhbHNlYCBhbmQgdGhlbiBgdHJ1ZWAgYWdhaW4gb25jZSB0aGUgbm9kZSBoYXMgYmVlbiBtZWFzdXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgbm9kZXMgaGF2ZSBiZWVuIGluaXRpYWxpemVkIGJ5IHRoZSBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50IGFuZFxuICogZ2l2ZW4gYSB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlUmVhY3RGbG93LCB1c2VOb2Rlc0luaXRpYWxpemVkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKlxuICpjb25zdCBvcHRpb25zID0ge1xuICogIGluY2x1ZGVIaWRkZW5Ob2RlczogZmFsc2UsXG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VMYXlvdXQoKSB7XG4gKiAgY29uc3QgeyBnZXROb2RlcyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gKiAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyk7XG4gKiAgY29uc3QgW2xheW91dGVkTm9kZXMsIHNldExheW91dGVkTm9kZXNdID0gdXNlU3RhdGUoZ2V0Tm9kZXMoKSk7XG4gKlxuICogIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICBpZiAobm9kZXNJbml0aWFsaXplZCkge1xuICogICAgICBzZXRMYXlvdXRlZE5vZGVzKHlvdXJMYXlvdXRpbmdGdW5jdGlvbihnZXROb2RlcygpKSk7XG4gKiAgICB9XG4gKiAgfSwgW25vZGVzSW5pdGlhbGl6ZWRdKTtcbiAqXG4gKiAgcmV0dXJuIGxheW91dGVkTm9kZXM7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxufSkge1xuICAgIGNvbnN0IGluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3IkNChvcHRpb25zKSk7XG4gICAgcmV0dXJuIGluaXRpYWxpemVkO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gY2hlY2sgaWYgYSA8SGFuZGxlIC8+IGlzIGNvbm5lY3RlZCB0byBhbm90aGVyIDxIYW5kbGUgLz4gYW5kIGdldCB0aGUgY29ubmVjdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICogQGRlcHJlY2F0ZWQgVXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGluc3RlYWQuXG4gKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGhhbmRsZSBjb25uZWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdXNlSGFuZGxlQ29ubmVjdGlvbnMoeyB0eXBlLCBpZCwgbm9kZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSkge1xuICAgIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdIGB1c2VIYW5kbGVDb25uZWN0aW9uc2AgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCB1c2UgYHVzZU5vZGVDb25uZWN0aW9uc2AgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2FwaS1yZWZlcmVuY2UvaG9va3MvdXNlTm9kZUNvbm5lY3Rpb25zJyk7XG4gICAgY29uc3QgX25vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSWQgPSBub2RlSWQgPz8gX25vZGVJZDtcbiAgICBjb25zdCBwcmV2Q29ubmVjdGlvbnMgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmNvbm5lY3Rpb25Mb29rdXAuZ2V0KGAke2N1cnJlbnROb2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKSwgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQHRvZG8gZGljdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuY29uc3QgZXJyb3IwMTQgPSBlcnJvck1lc3NhZ2VzWydlcnJvcjAxNCddKCk7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIGNvbm5lY3Rpb25zIG9uIGEgc3BlY2lmaWMgbm9kZSwgaGFuZGxlIHR5cGUgKCdzb3VyY2UnLCAndGFyZ2V0Jykgb3IgaGFuZGxlIElELlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggY29ubmVjdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlQ29ubmVjdGlvbnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZU5vZGVDb25uZWN0aW9ucyh7XG4gKiAgICBoYW5kbGVUeXBlOiAndGFyZ2V0JyxcbiAqICAgIGhhbmRsZUlkOiAnbXktaGFuZGxlJyxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7Y29ubmVjdGlvbnMubGVuZ3RofSBpbmNvbWluZyBjb25uZWN0aW9ucyE8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2RlQ29ubmVjdGlvbnMoeyBpZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0LCB9ID0ge30pIHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gaWQgPz8gbm9kZUlkO1xuICAgIGlmICghY3VycmVudE5vZGVJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IwMTQpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2Q29ubmVjdGlvbnMgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmNvbm5lY3Rpb25Mb29rdXAuZ2V0KGAke2N1cnJlbnROb2RlSWR9JHtoYW5kbGVUeXBlID8gKGhhbmRsZUlkID8gYC0ke2hhbmRsZVR5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHtoYW5kbGVUeXBlfWApIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpc2N1c3MgaWYgb25Db25uZWN0L29uRGlzY29ubmVjdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMvdW5tb3VudHNcbiAgICAgICAgaWYgKHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICYmIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICE9PSBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgX2Nvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgX2Nvbm5lY3Rpb25zLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShfY29ubmVjdGlvbnMsIHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBvbkNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgIH0sIFtjb25uZWN0aW9ucywgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3RdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBBcnJheS5mcm9tKGNvbm5lY3Rpb25zPy52YWx1ZXMoKSA/PyBbXSksIFtjb25uZWN0aW9uc10pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZXNEYXRhKG5vZGVJZHMpIHtcbiAgICBjb25zdCBub2Rlc0RhdGEgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGNvbnN0IGlzQXJyYXlPZklkcyA9IEFycmF5LmlzQXJyYXkobm9kZUlkcyk7XG4gICAgICAgIGNvbnN0IF9ub2RlSWRzID0gaXNBcnJheU9mSWRzID8gbm9kZUlkcyA6IFtub2RlSWRzXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2YgX25vZGVJZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5vZGUuZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheU9mSWRzID8gZGF0YSA6IGRhdGFbMF0gPz8gbnVsbDtcbiAgICB9LCBbbm9kZUlkc10pLCBzaGFsbG93Tm9kZURhdGEpO1xuICAgIHJldHVybiBub2Rlc0RhdGE7XG59XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgc3BlY2lmaWMgbm9kZS5cbiAqIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgdGhlIG5vZGUgY2hhbmdlcyoqLFxuICogaW5jbHVkaW5nIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkIG9yIG1vdmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiBhIG5vZGUgeW91IHdhbnQgdG8gb2JzZXJ2ZS5cbiAqIEByZXR1cm5zIFRoZSBgSW50ZXJuYWxOb2RlYCBvYmplY3QgZm9yIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIElELlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlSW50ZXJuYWxOb2RlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgaW50ZXJuYWxOb2RlID0gdXNlSW50ZXJuYWxOb2RlKCdub2RlLTEnKTtcbiAqICBjb25zdCBhYnNvbHV0ZVBvc2l0aW9uID0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGlzIGF0OlxuICogICAgICA8cD54OiB7YWJzb2x1dGVQb3NpdGlvbi54fTwvcD5cbiAqICAgICAgPHA+eToge2Fic29sdXRlUG9zaXRpb24ueX08L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VJbnRlcm5hbE5vZGUoaWQpIHtcbiAgICBjb25zdCBub2RlID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHMubm9kZUxvb2t1cC5nZXQoaWQpLCBbaWRdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIExpbmVQYXR0ZXJuKHsgZGltZW5zaW9ucywgbGluZVdpZHRoLCB2YXJpYW50LCBjbGFzc05hbWUgfSkge1xuICAgIHJldHVybiAoanN4KFwicGF0aFwiLCB7IHN0cm9rZVdpZHRoOiBsaW5lV2lkdGgsIGQ6IGBNJHtkaW1lbnNpb25zWzBdIC8gMn0gMCBWJHtkaW1lbnNpb25zWzFdfSBNMCAke2RpbWVuc2lvbnNbMV0gLyAyfSBIJHtkaW1lbnNpb25zWzBdfWAsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kLXBhdHRlcm4nLCB2YXJpYW50LCBjbGFzc05hbWVdKSB9KSk7XG59XG5mdW5jdGlvbiBEb3RQYXR0ZXJuKHsgcmFkaXVzLCBjbGFzc05hbWUgfSkge1xuICAgIHJldHVybiAoanN4KFwiY2lyY2xlXCIsIHsgY3g6IHJhZGl1cywgY3k6IHJhZGl1cywgcjogcmFkaXVzLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgJ2RvdHMnLCBjbGFzc05hbWVdKSB9KSk7XG59XG5cbi8qKlxuICogVGhlIHRocmVlIHZhcmlhbnRzIGFyZSBleHBvcnRlZCBhcyBhbiBlbnVtIGZvciBjb252ZW5pZW5jZS4gWW91IGNhbiBlaXRoZXIgaW1wb3J0XG4gKiB0aGUgZW51bSBhbmQgdXNlIGl0IGxpa2UgYEJhY2tncm91bmRWYXJpYW50LkxpbmVzYCBvciB5b3UgY2FuIHVzZSB0aGUgcmF3IHN0cmluZ1xuICogdmFsdWUgZGlyZWN0bHkuXG4gKiBAcHVibGljXG4gKi9cbnZhciBCYWNrZ3JvdW5kVmFyaWFudDtcbihmdW5jdGlvbiAoQmFja2dyb3VuZFZhcmlhbnQpIHtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkxpbmVzXCJdID0gXCJsaW5lc1wiO1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiRG90c1wiXSA9IFwiZG90c1wiO1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiQ3Jvc3NcIl0gPSBcImNyb3NzXCI7XG59KShCYWNrZ3JvdW5kVmFyaWFudCB8fCAoQmFja2dyb3VuZFZhcmlhbnQgPSB7fSkpO1xuXG5jb25zdCBkZWZhdWx0U2l6ZSA9IHtcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuRG90c106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkxpbmVzXTogMSxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3NdOiA2LFxufTtcbmNvbnN0IHNlbGVjdG9yJDMgPSAocykgPT4gKHsgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSwgcGF0dGVybklkOiBgcGF0dGVybi0ke3MucmZJZH1gIH0pO1xuZnVuY3Rpb24gQmFja2dyb3VuZENvbXBvbmVudCh7IGlkLCB2YXJpYW50ID0gQmFja2dyb3VuZFZhcmlhbnQuRG90cywgXG4vLyBvbmx5IHVzZWQgZm9yIGRvdHMgYW5kIGNyb3NzXG5nYXAgPSAyMCwgXG4vLyBvbmx5IHVzZWQgZm9yIGxpbmVzIGFuZCBjcm9zc1xuc2l6ZSwgbGluZVdpZHRoID0gMSwgb2Zmc2V0ID0gMCwgY29sb3IsIGJnQ29sb3IsIHN0eWxlLCBjbGFzc05hbWUsIHBhdHRlcm5DbGFzc05hbWUsIH0pIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhdHRlcm5JZCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMywgc2hhbGxvdyk7XG4gICAgY29uc3QgcGF0dGVyblNpemUgPSBzaXplIHx8IGRlZmF1bHRTaXplW3ZhcmlhbnRdO1xuICAgIGNvbnN0IGlzRG90cyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkRvdHM7XG4gICAgY29uc3QgaXNDcm9zcyA9IHZhcmlhbnQgPT09IEJhY2tncm91bmRWYXJpYW50LkNyb3NzO1xuICAgIGNvbnN0IGdhcFhZID0gQXJyYXkuaXNBcnJheShnYXApID8gZ2FwIDogW2dhcCwgZ2FwXTtcbiAgICBjb25zdCBzY2FsZWRHYXAgPSBbZ2FwWFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSwgZ2FwWFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMV07XG4gICAgY29uc3Qgc2NhbGVkU2l6ZSA9IHBhdHRlcm5TaXplICogdHJhbnNmb3JtWzJdO1xuICAgIGNvbnN0IG9mZnNldFhZID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogW29mZnNldCwgb2Zmc2V0XTtcbiAgICBjb25zdCBwYXR0ZXJuRGltZW5zaW9ucyA9IGlzQ3Jvc3MgPyBbc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZV0gOiBzY2FsZWRHYXA7XG4gICAgY29uc3Qgc2NhbGVkT2Zmc2V0ID0gW1xuICAgICAgICBvZmZzZXRYWVswXSAqIHRyYW5zZm9ybVsyXSB8fCAxICsgcGF0dGVybkRpbWVuc2lvbnNbMF0gLyAyLFxuICAgICAgICBvZmZzZXRYWVsxXSAqIHRyYW5zZm9ybVsyXSB8fCAxICsgcGF0dGVybkRpbWVuc2lvbnNbMV0gLyAyLFxuICAgIF07XG4gICAgY29uc3QgX3BhdHRlcm5JZCA9IGAke3BhdHRlcm5JZH0ke2lkID8gaWQgOiAnJ31gO1xuICAgIHJldHVybiAoanN4cyhcInN2Z1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kJywgY2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmNvbnRhaW5lclN0eWxlLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IGJnQ29sb3IsXG4gICAgICAgICAgICAnLS14eS1iYWNrZ3JvdW5kLXBhdHRlcm4tY29sb3ItcHJvcHMnOiBjb2xvcixcbiAgICAgICAgfSwgcmVmOiByZWYsIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fYmFja2dyb3VuZFwiLCBjaGlsZHJlbjogW2pzeChcInBhdHRlcm5cIiwgeyBpZDogX3BhdHRlcm5JZCwgeDogdHJhbnNmb3JtWzBdICUgc2NhbGVkR2FwWzBdLCB5OiB0cmFuc2Zvcm1bMV0gJSBzY2FsZWRHYXBbMV0sIHdpZHRoOiBzY2FsZWRHYXBbMF0sIGhlaWdodDogc2NhbGVkR2FwWzFdLCBwYXR0ZXJuVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiwgcGF0dGVyblRyYW5zZm9ybTogYHRyYW5zbGF0ZSgtJHtzY2FsZWRPZmZzZXRbMF19LC0ke3NjYWxlZE9mZnNldFsxXX0pYCwgY2hpbGRyZW46IGlzRG90cyA/IChqc3goRG90UGF0dGVybiwgeyByYWRpdXM6IHNjYWxlZFNpemUgLyAyLCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIDogKGpzeChMaW5lUGF0dGVybiwgeyBkaW1lbnNpb25zOiBwYXR0ZXJuRGltZW5zaW9ucywgbGluZVdpZHRoOiBsaW5lV2lkdGgsIHZhcmlhbnQ6IHZhcmlhbnQsIGNsYXNzTmFtZTogcGF0dGVybkNsYXNzTmFtZSB9KSkgfSksIGpzeChcInJlY3RcIiwgeyB4OiBcIjBcIiwgeTogXCIwXCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgZmlsbDogYHVybCgjJHtfcGF0dGVybklkfSlgIH0pXSB9KSk7XG59XG5CYWNrZ3JvdW5kQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0JhY2tncm91bmQnO1xuLyoqXG4gKiBUaGUgYDxCYWNrZ3JvdW5kIC8+YCBjb21wb25lbnQgbWFrZXMgaXQgY29udmVuaWVudCB0byByZW5kZXIgZGlmZmVyZW50IHR5cGVzIG9mIGJhY2tncm91bmRzIGNvbW1vbiBpbiBub2RlLWJhc2VkIFVJcy4gSXQgY29tZXMgd2l0aCB0aHJlZSB2YXJpYW50czogbGluZXMsIGRvdHMgYW5kIGNyb3NzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogQSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdG8gdXNlIHRoZSBCYWNrZ3JvdW5kIGNvbXBvbmVudC5cbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFJlYWN0RmxvdyBkZWZhdWx0Tm9kZXM9e1suLi5dfSBkZWZhdWx0RWRnZXM9e1suLi5dfT5cbiAqICAgICAgIDxCYWNrZ3JvdW5kIGNvbG9yPVwiI2NjY1wiIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkRvdHN9IC8+XG4gKiAgICAgPC9SZWFjdEZsb3c+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEluIHRoaXMgZXhhbXBsZSB5b3UgY2FuIHNlZSBob3cgdG8gY29tYmluZSBtdWx0aXBsZSBiYWNrZ3JvdW5kc1xuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICogaW1wb3J0ICdAeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzJztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZFxuICogICAgICAgICBpZD1cIjFcIlxuICogICAgICAgICBnYXA9ezEwfVxuICogICAgICAgICBjb2xvcj1cIiNmMWYxZjFcIlxuICogICAgICAgICB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc31cbiAqICAgICAgIC8+XG4gKiAgICAgICA8QmFja2dyb3VuZFxuICogICAgICAgICBpZD1cIjJcIlxuICogICAgICAgICBnYXA9ezEwMH1cbiAqICAgICAgICAgY29sb3I9XCIjY2NjXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBXaGVuIGNvbWJpbmluZyBtdWx0aXBsZSA8QmFja2dyb3VuZCAvPiBjb21wb25lbnRzIGl04oCZcyBpbXBvcnRhbnQgdG8gZ2l2ZSBlYWNoIG9mIHRoZW0gYSB1bmlxdWUgaWQgcHJvcCFcbiAqXG4gKi9cbmNvbnN0IEJhY2tncm91bmQgPSBtZW1vKEJhY2tncm91bmRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBQbHVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMzIgMTguMTMzSDE4LjEzM1YzMmgtNC4yNjZWMTguMTMzSDB2LTQuMjY2aDEzLjg2N1YwaDQuMjY2djEzLjg2N0gzMnpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIE1pbnVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDVcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0wIDBoMzJ2NC4ySDB6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBGaXRWaWV3SWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMwXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMy42OTIgNC42M2MwLS41My40LS45MzguOTM5LS45MzhoNS4yMTVWMEg0LjcwOEMyLjEzIDAgMCAyLjA1NCAwIDQuNjN2NS4yMTZoMy42OTJWNC42MzF6TTI3LjM1NCAwaC01LjJ2My42OTJoNS4xN2MuNTMgMCAuOTg0LjQuOTg0LjkzOXY1LjIxNUgzMlY0LjYzMUE0LjYyNCA0LjYyNCAwIDAwMjcuMzU0IDB6bS45NTQgMjQuODNjMCAuNTMyLS40Ljk0LS45MzkuOTRoLTUuMjE1djMuNzY4aDUuMjE1YzIuNTc3IDAgNC42MzEtMi4xMyA0LjYzMS00LjcwN3YtNS4xMzloLTMuNjkydjUuMTM5em0tMjMuNjc3Ljk0Yy0uNTMxIDAtLjkzOS0uNC0uOTM5LS45NHYtNS4xMzhIMHY1LjEzOWMwIDIuNTc3IDIuMTMgNC43MDcgNC43MDggNC43MDdoNS4xMzhWMjUuNzdINC42MzF6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBMb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDAgOCAwIDQuNTcxIDMuNDI5IDQuNTcxIDcuNjE5djMuMDQ4SDMuMDQ4QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3ptNC43MjQtMTMuODY2SDcuNDY3VjcuNjE5YzAtMi41OSAyLjEzMy00LjcyNCA0LjcyMy00LjcyNCAyLjU5MSAwIDQuNzI0IDIuMTMzIDQuNzI0IDQuNzI0djMuMDQ4elwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gVW5sb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDBjLTQuMTE0IDEuODI4LTEuMzcgMi4xMzMuMzA1IDIuNDM4IDEuNjc2LjMwNSA0LjQyIDIuNTkgNC40MiA1LjE4MXYzLjA0OEgzLjA0N0EzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6XCIgfSkgfSkpO1xufVxuXG4vKipcbiAqIFlvdSBjYW4gYWRkIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2wgcGFuZWwgYnkgdXNpbmcgdGhlIGA8Q29udHJvbEJ1dHRvbiAvPmAgY29tcG9uZW50XG4gKiBhbmQgcGFzcyBpdCBhcyBhIGNoaWxkIHRvIHRoZSBbYDxDb250cm9scyAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbHMpIGNvbXBvbmVudC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgTWFnaWNXYW5kIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWljb25zJ1xuICppbXBvcnQgeyBSZWFjdEZsb3csIENvbnRyb2xzLCBDb250cm9sQnV0dG9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dfSBlZGdlcz17Wy4uLl19PlxuICogICAgICA8Q29udHJvbHM+XG4gKiAgICAgICAgPENvbnRyb2xCdXR0b24gb25DbGljaz17KCkgPT4gYWxlcnQoJ1NvbWV0aGluZyBtYWdpY2FsIGp1c3QgaGFwcGVuZWQuIOKcqCcpfT5cbiAqICAgICAgICAgIDxNYWdpY1dhbmQgLz5cbiAqICAgICAgICA8L0NvbnRyb2xCdXR0b24+XG4gKiAgICAgIDwvQ29udHJvbHM+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xCdXR0b24oeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICByZXR1cm4gKGpzeChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scy1idXR0b24nLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkMiA9IChzKSA9PiAoe1xuICAgIGlzSW50ZXJhY3RpdmU6IHMubm9kZXNEcmFnZ2FibGUgfHwgcy5ub2Rlc0Nvbm5lY3RhYmxlIHx8IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG1pblpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA8PSBzLm1pblpvb20sXG4gICAgbWF4Wm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdID49IHMubWF4Wm9vbSxcbiAgICBhcmlhTGFiZWxDb25maWc6IHMuYXJpYUxhYmVsQ29uZmlnLFxufSk7XG5mdW5jdGlvbiBDb250cm9sc0NvbXBvbmVudCh7IHN0eWxlLCBzaG93Wm9vbSA9IHRydWUsIHNob3dGaXRWaWV3ID0gdHJ1ZSwgc2hvd0ludGVyYWN0aXZlID0gdHJ1ZSwgZml0Vmlld09wdGlvbnMsIG9uWm9vbUluLCBvblpvb21PdXQsIG9uRml0Vmlldywgb25JbnRlcmFjdGl2ZUNoYW5nZSwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSAnYm90dG9tLWxlZnQnLCBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkLCBhcmlhTGFiZWxDb25maWcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgem9vbUluLCB6b29tT3V0LCBmaXRWaWV3IH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBvblpvb21JbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21JbigpO1xuICAgICAgICBvblpvb21Jbj8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblpvb21PdXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tT3V0KCk7XG4gICAgICAgIG9uWm9vbU91dD8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpdFZpZXdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBmaXRWaWV3KGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgb25GaXRWaWV3Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSA9ICgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbm9kZXNEcmFnZ2FibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICB9KTtcbiAgICAgICAgb25JbnRlcmFjdGl2ZUNoYW5nZT8uKCFpc0ludGVyYWN0aXZlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWVudGF0aW9uQ2xhc3MgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICByZXR1cm4gKGpzeHMoUGFuZWwsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzJywgb3JpZW50YXRpb25DbGFzcywgY2xhc3NOYW1lXSksIHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2NvbnRyb2xzXCIsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwgPz8gYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy5hcmlhTGFiZWwnXSwgY2hpbGRyZW46IFtzaG93Wm9vbSAmJiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbUluSGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21pblwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21Jbi5hcmlhTGFiZWwnXSwgZGlzYWJsZWQ6IG1heFpvb21SZWFjaGVkLCBjaGlsZHJlbjoganN4KFBsdXNJY29uLCB7fSkgfSksIGpzeChDb250cm9sQnV0dG9uLCB7IG9uQ2xpY2s6IG9uWm9vbU91dEhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29tb3V0XCIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtaW5ab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChNaW51c0ljb24sIHt9KSB9KV0gfSkpLCBzaG93Rml0VmlldyAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWZpdHZpZXdcIiwgb25DbGljazogb25GaXRWaWV3SGFuZGxlciwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnXSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnXSwgY2hpbGRyZW46IGpzeChGaXRWaWV3SWNvbiwge30pIH0pKSwgc2hvd0ludGVyYWN0aXZlICYmIChqc3goQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtaW50ZXJhY3RpdmVcIiwgb25DbGljazogb25Ub2dnbGVJbnRlcmFjdGl2aXR5LCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy5pbnRlcmFjdGl2ZS5hcmlhTGFiZWwnXSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBpc0ludGVyYWN0aXZlID8ganN4KFVubG9ja0ljb24sIHt9KSA6IGpzeChMb2NrSWNvbiwge30pIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn1cbkNvbnRyb2xzQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xzJztcbi8qKlxuICogVGhlIGA8Q29udHJvbHMgLz5gIGNvbXBvbmVudCByZW5kZXJzIGEgc21hbGwgcGFuZWwgdGhhdCBjb250YWlucyBjb252ZW5pZW50XG4gKiBidXR0b25zIHRvIHpvb20gaW4sIHpvb20gb3V0LCBmaXQgdGhlIHZpZXcsIGFuZCBsb2NrIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzIC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApXG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVG8gZXh0ZW5kIG9yIGN1c3RvbWlzZSB0aGUgY29udHJvbHMsIHlvdSBjYW4gdXNlIHRoZSBbYDxDb250cm9sQnV0dG9uIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9sLWJ1dHRvbikgY29tcG9uZW50XG4gKlxuICovXG5jb25zdCBDb250cm9scyA9IG1lbW8oQ29udHJvbHNDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBNaW5pTWFwTm9kZUNvbXBvbmVudCh7IGlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgY29sb3IsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCwgY2xhc3NOYW1lLCBib3JkZXJSYWRpdXMsIHNoYXBlUmVuZGVyaW5nLCBzZWxlY3RlZCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZCwgYmFja2dyb3VuZENvbG9yIH0gPSBzdHlsZSB8fCB7fTtcbiAgICBjb25zdCBmaWxsID0gKGNvbG9yIHx8IGJhY2tncm91bmQgfHwgYmFja2dyb3VuZENvbG9yKTtcbiAgICByZXR1cm4gKGpzeChcInJlY3RcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcC1ub2RlJywgeyBzZWxlY3RlZCB9LCBjbGFzc05hbWVdKSwgeDogeCwgeTogeSwgcng6IGJvcmRlclJhZGl1cywgcnk6IGJvcmRlclJhZGl1cywgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3R5bGU6IHtcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljayA/IChldmVudCkgPT4gb25DbGljayhldmVudCwgaWQpIDogdW5kZWZpbmVkIH0pKTtcbn1cbmNvbnN0IE1pbmlNYXBOb2RlID0gbWVtbyhNaW5pTWFwTm9kZUNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yTm9kZUlkcyA9IChzKSA9PiBzLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCk7XG5jb25zdCBnZXRBdHRyRnVuY3Rpb24gPSAoZnVuYykgPT4gZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZnVuYyA6ICgpID0+IGZ1bmM7XG5mdW5jdGlvbiBNaW5pTWFwTm9kZXMoeyBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCA9IE1pbmlNYXBOb2RlLCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVN0b3JlKHNlbGVjdG9yTm9kZUlkcywgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVTdHJva2VDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZVN0cm9rZUNvbG9yKTtcbiAgICBjb25zdCBub2RlQ2xhc3NOYW1lRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBzaGFwZVJlbmRlcmluZyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEhd2luZG93LmNocm9tZSA/ICdjcmlzcEVkZ2VzJyA6ICdnZW9tZXRyaWNQcmVjaXNpb24nO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiAoXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBzcGxpdCBvZiByZXNwb25zaWJpbGl0aWVzIGJldHdlZW4gTWluaU1hcE5vZGVzIGFuZFxuICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICogbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgYSBzaW1pbGFyIGNvbW1pdCBpbiBgTm9kZVJlbmRlcmVyL2luZGV4LnRzeGAuXG4gICAgICAgICAqL1xuICAgICAgICBqc3goTm9kZUNvbXBvbmVudFdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZUNvbG9yRnVuYzogbm9kZUNvbG9yRnVuYywgbm9kZVN0cm9rZUNvbG9yRnVuYzogbm9kZVN0cm9rZUNvbG9yRnVuYywgbm9kZUNsYXNzTmFtZUZ1bmM6IG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgTm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCwgb25DbGljazogb25DbGljaywgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nIH0sIG5vZGVJZCkpKSB9KSk7XG59XG5mdW5jdGlvbiBOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyKHsgaWQsIG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nLCBOb2RlQ29tcG9uZW50LCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCB7IGludGVybmFscyB9ID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5oaWRkZW4gfHwgIW5vZGVIYXNEaW1lbnNpb25zKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb2RlQ29tcG9uZW50LCB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBjbGFzc05hbWU6IG5vZGVDbGFzc05hbWVGdW5jKG5vZGUpLCBjb2xvcjogbm9kZUNvbG9yRnVuYyhub2RlKSwgYm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBzdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yRnVuYyhub2RlKSwgc3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrLCBpZDogbm9kZS5pZCB9KSk7XG59XG5jb25zdCBOb2RlQ29tcG9uZW50V3JhcHBlciA9IG1lbW8oTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcik7XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbmNvbnN0IGRlZmF1bHRXaWR0aCA9IDIwMDtcbmNvbnN0IGRlZmF1bHRIZWlnaHQgPSAxNTA7XG5jb25zdCBmaWx0ZXJIaWRkZW4gPSAobm9kZSkgPT4gIW5vZGUuaGlkZGVuO1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiB7XG4gICAgY29uc3Qgdmlld0JCID0ge1xuICAgICAgICB4OiAtcy50cmFuc2Zvcm1bMF0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXMudHJhbnNmb3JtWzFdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiBzLndpZHRoIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogcy5oZWlnaHQgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZpZXdCQixcbiAgICAgICAgYm91bmRpbmdSZWN0OiBzLm5vZGVMb29rdXAuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gZ2V0Qm91bmRzT2ZSZWN0cyhnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwgeyBmaWx0ZXI6IGZpbHRlckhpZGRlbiB9KSwgdmlld0JCKVxuICAgICAgICAgICAgOiB2aWV3QkIsXG4gICAgICAgIHJmSWQ6IHMucmZJZCxcbiAgICAgICAgcGFuWm9vbTogcy5wYW5ab29tLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IHMudHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBmbG93V2lkdGg6IHMud2lkdGgsXG4gICAgICAgIGZsb3dIZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICBhcmlhTGFiZWxDb25maWc6IHMuYXJpYUxhYmVsQ29uZmlnLFxuICAgIH07XG59O1xuY29uc3QgQVJJQV9MQUJFTF9LRVkgPSAncmVhY3QtZmxvd19fbWluaW1hcC1kZXNjJztcbmZ1bmN0aW9uIE1pbmlNYXBDb21wb25lbnQoeyBzdHlsZSwgY2xhc3NOYW1lLCBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8qXG4gKiBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4gKiBhIGNvbXBvbmVudCBwcm9wZXJseS5cbiAqL1xubm9kZUNvbXBvbmVudCwgYmdDb2xvciwgbWFza0NvbG9yLCBtYXNrU3Ryb2tlQ29sb3IsIG1hc2tTdHJva2VXaWR0aCwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCwgaW52ZXJzZVBhbiwgem9vbVN0ZXAgPSAxLCBvZmZzZXRTY2FsZSA9IDUsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ZnID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgYm91bmRpbmdSZWN0LCB2aWV3QkIsIHJmSWQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0LCBhcmlhTGFiZWxDb25maWcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHN0eWxlPy53aWR0aCA/PyBkZWZhdWx0V2lkdGg7XG4gICAgY29uc3QgZWxlbWVudEhlaWdodCA9IHN0eWxlPy5oZWlnaHQgPz8gZGVmYXVsdEhlaWdodDtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCB2aWV3U2NhbGUgPSBNYXRoLm1heChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCB2aWV3V2lkdGggPSB2aWV3U2NhbGUgKiBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgdmlld0hlaWdodCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0U2NhbGUgKiB2aWV3U2NhbGU7XG4gICAgY29uc3QgeCA9IGJvdW5kaW5nUmVjdC54IC0gKHZpZXdXaWR0aCAtIGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHkgPSBib3VuZGluZ1JlY3QueSAtICh2aWV3SGVpZ2h0IC0gYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHdpZHRoID0gdmlld1dpZHRoICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBoZWlnaHQgPSB2aWV3SGVpZ2h0ICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBsYWJlbGxlZEJ5ID0gYCR7QVJJQV9MQUJFTF9LRVl9LSR7cmZJZH1gO1xuICAgIGNvbnN0IHZpZXdTY2FsZVJlZiA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBtaW5pbWFwSW5zdGFuY2UgPSB1c2VSZWYoKTtcbiAgICB2aWV3U2NhbGVSZWYuY3VycmVudCA9IHZpZXdTY2FsZTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3ZnLmN1cnJlbnQgJiYgcGFuWm9vbSkge1xuICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQgPSBYWU1pbmltYXAoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHN2Zy5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRWaWV3U2NhbGU6ICgpID0+IHZpZXdTY2FsZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW3Bhblpvb21dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8udXBkYXRlKHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgIHdpZHRoOiBmbG93V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGZsb3dIZWlnaHQsXG4gICAgICAgICAgICBpbnZlcnNlUGFuLFxuICAgICAgICAgICAgcGFubmFibGUsXG4gICAgICAgICAgICB6b29tU3RlcCxcbiAgICAgICAgICAgIHpvb21hYmxlLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFubmFibGUsIHpvb21hYmxlLCBpbnZlcnNlUGFuLCB6b29tU3RlcCwgdHJhbnNsYXRlRXh0ZW50LCBmbG93V2lkdGgsIGZsb3dIZWlnaHRdKTtcbiAgICBjb25zdCBvblN2Z0NsaWNrID0gb25DbGlja1xuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnBvaW50ZXIoZXZlbnQpIHx8IFswLCAwXTtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblN2Z05vZGVDbGljayA9IG9uTm9kZUNsaWNrXG4gICAgICAgID8gdXNlQ2FsbGJhY2soKGV2ZW50LCBub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCkuaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICAgICAgb25Ob2RlQ2xpY2soZXZlbnQsIG5vZGUpO1xuICAgICAgICB9LCBbXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgX2FyaWFMYWJlbCA9IGFyaWFMYWJlbCA/PyBhcmlhTGFiZWxDb25maWdbJ21pbmltYXAuYXJpYUxhYmVsJ107XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgYmdDb2xvciA9PT0gJ3N0cmluZycgPyBiZ0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza0NvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZVdpZHRoID09PSAnbnVtYmVyJyA/IG1hc2tTdHJva2VXaWR0aCAqIHZpZXdTY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBub2RlU3Ryb2tlV2lkdGggOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19taW5pbWFwJywgY2xhc3NOYW1lXSksIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fbWluaW1hcFwiLCBjaGlsZHJlbjoganN4cyhcInN2Z1wiLCB7IHdpZHRoOiBlbGVtZW50V2lkdGgsIGhlaWdodDogZWxlbWVudEhlaWdodCwgdmlld0JveDogYCR7eH0gJHt5fSAke3dpZHRofSAke2hlaWdodH1gLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWluaW1hcC1zdmdcIiwgcm9sZTogXCJpbWdcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSwgcmVmOiBzdmcsIG9uQ2xpY2s6IG9uU3ZnQ2xpY2ssIGNoaWxkcmVuOiBbX2FyaWFMYWJlbCAmJiBqc3goXCJ0aXRsZVwiLCB7IGlkOiBsYWJlbGxlZEJ5LCBjaGlsZHJlbjogX2FyaWFMYWJlbCB9KSwganN4KE1pbmlNYXBOb2RlcyQxLCB7IG9uQ2xpY2s6IG9uU3ZnTm9kZUNsaWNrLCBub2RlQ29sb3I6IG5vZGVDb2xvciwgbm9kZVN0cm9rZUNvbG9yOiBub2RlU3Ryb2tlQ29sb3IsIG5vZGVCb3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVDbGFzc05hbWU6IG5vZGVDbGFzc05hbWUsIG5vZGVTdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBub2RlQ29tcG9uZW50OiBub2RlQ29tcG9uZW50IH0pLCBqc3goXCJwYXRoXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtbWFza1wiLCBkOiBgTSR7eCAtIG9mZnNldH0sJHt5IC0gb2Zmc2V0fWgke3dpZHRoICsgb2Zmc2V0ICogMn12JHtoZWlnaHQgKyBvZmZzZXQgKiAyfWgkey13aWR0aCAtIG9mZnNldCAqIDJ9elxuICAgICAgICBNJHt2aWV3QkIueH0sJHt2aWV3QkIueX1oJHt2aWV3QkIud2lkdGh9diR7dmlld0JCLmhlaWdodH1oJHstdmlld0JCLndpZHRofXpgLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0pXSB9KSB9KSk7XG59XG5NaW5pTWFwQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ01pbmlNYXAnO1xuLyoqXG4gKiBUaGUgYDxNaW5pTWFwIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGFuIG92ZXJ2aWV3IG9mIHlvdXIgZmxvdy4gSXRcbiAqIHJlbmRlcnMgZWFjaCBub2RlIGFzIGFuIFNWRyBlbGVtZW50IGFuZCB2aXN1YWxpemVzIHdoZXJlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGlzXG4gKiBpbiByZWxhdGlvbiB0byB0aGUgcmVzdCBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIE1pbmlNYXAgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dXX0gZWRnZXM9e1suLi5dXX0+XG4gKiAgICAgIDxNaW5pTWFwIG5vZGVTdHJva2VXaWR0aD17M30gLz5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IE1pbmlNYXAgPSBtZW1vKE1pbmlNYXBDb21wb25lbnQpO1xuXG5jb25zdCBzY2FsZVNlbGVjdG9yID0gKGNhbGN1bGF0ZVNjYWxlKSA9PiAoc3RvcmUpID0+IGNhbGN1bGF0ZVNjYWxlID8gYCR7TWF0aC5tYXgoMSAvIHN0b3JlLnRyYW5zZm9ybVsyXSwgMSl9YCA6IHVuZGVmaW5lZDtcbmNvbnN0IGRlZmF1bHRQb3NpdGlvbnMgPSB7XG4gICAgW1Jlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmVdOiAncmlnaHQnLFxuICAgIFtSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGVdOiAnYm90dG9tLXJpZ2h0Jyxcbn07XG5mdW5jdGlvbiBSZXNpemVDb250cm9sKHsgbm9kZUlkLCBwb3NpdGlvbiwgdmFyaWFudCA9IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkhhbmRsZSwgY2xhc3NOYW1lLCBzdHlsZSA9IHVuZGVmaW5lZCwgY2hpbGRyZW4sIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgcmVzaXplRGlyZWN0aW9uLCBhdXRvU2NhbGUgPSB0cnVlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBub2RlSWQgPT09ICdzdHJpbmcnID8gbm9kZUlkIDogY29udGV4dE5vZGVJZDtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgcmVzaXplQ29udHJvbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc0hhbmRsZUNvbnRyb2wgPSB2YXJpYW50ID09PSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGU7XG4gICAgY29uc3Qgc2NhbGUgPSB1c2VTdG9yZSh1c2VDYWxsYmFjayhzY2FsZVNlbGVjdG9yKGlzSGFuZGxlQ29udHJvbCAmJiBhdXRvU2NhbGUpLCBbaXNIYW5kbGVDb250cm9sLCBhdXRvU2NhbGVdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVzaXplciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb250cm9sUG9zaXRpb24gPSBwb3NpdGlvbiA/PyBkZWZhdWx0UG9zaXRpb25zW3ZhcmlhbnRdO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcmVzaXplQ29udHJvbFJlZi5jdXJyZW50IHx8ICFpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzaXplci5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXNpemVyLmN1cnJlbnQgPSBYWVJlc2l6ZXIoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lRG9tTm9kZTogZG9tTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoY2hhbmdlLCBjaGlsZENoYW5nZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VyTm9kZUNoYW5nZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IGNoYW5nZS54LCB5OiBjaGFuZ2UueSB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjaGFuZ2Uud2lkdGggPz8gbm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhbmdlLmhlaWdodCA/PyBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmFsdWF0ZUFic29sdXRlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hhbmdlLnggPz8gbm9kZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hhbmdlLnkgPz8gbm9kZS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7IHdpZHRoLCBoZWlnaHQgfSwgbm9kZS5wYXJlbnRJZCwgbm9kZUxvb2t1cCwgb3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQoW2NoaWxkXSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIHRoZSBwYXJlbnQgd2FzIGV4cGFuZGVkIGJ5IHRoZSBjaGlsZCBub2RlLCBpdHMgcG9zaXRpb24gd2lsbCBiZSBjbGFtcGVkIGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAwLDAgd2hlbiBub2RlIG9yaWdpbiBpcyAwLDAgYW5kIHRvIHdpZHRoLCBoZWlnaHQgaWYgaXQncyAxLDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBjaGFuZ2UueCA/IE1hdGgubWF4KG9yaWdpblswXSAqIHdpZHRoLCBjaGFuZ2UueCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueSA9IGNoYW5nZS55ID8gTWF0aC5tYXgob3JpZ2luWzFdICogaGVpZ2h0LCBjaGFuZ2UueSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgbmV4dFBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5uZXh0UG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjaGFuZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAhcmVzaXplRGlyZWN0aW9uID8gdHJ1ZSA6IHJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNoYW5nZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjaGFuZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGRpbWVuc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZENoYW5nZSBvZiBjaGlsZENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnRyaWdnZXJOb2RlQ2hhbmdlcyhbZGltZW5zaW9uQ2hhbmdlXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZXIuY3VycmVudC51cGRhdGUoe1xuICAgICAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICAgICAgYm91bmRhcmllczoge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgcmVzaXplRGlyZWN0aW9uLFxuICAgICAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgICAgIG9uUmVzaXplLFxuICAgICAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgIG1pbldpZHRoLFxuICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgIG1heFdpZHRoLFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgb25SZXNpemUsXG4gICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgXSk7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc05hbWVzID0gY29udHJvbFBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcmVzaXplLWNvbnRyb2wnLCAnbm9kcmFnJywgLi4ucG9zaXRpb25DbGFzc05hbWVzLCB2YXJpYW50LCBjbGFzc05hbWVdKSwgcmVmOiByZXNpemVDb250cm9sUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIC4uLihjb2xvciAmJiB7IFtpc0hhbmRsZUNvbnRyb2wgPyAnYmFja2dyb3VuZENvbG9yJyA6ICdib3JkZXJDb2xvciddOiBjb2xvciB9KSxcbiAgICAgICAgfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVG8gY3JlYXRlIHlvdXIgb3duIHJlc2l6aW5nIFVJLCB5b3UgY2FuIHVzZSB0aGUgYE5vZGVSZXNpemVDb250cm9sYCBjb21wb25lbnQgd2hlcmUgeW91IGNhbiBwYXNzIGNoaWxkcmVuIChzdWNoIGFzIGljb25zKS5cbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmNvbnN0IE5vZGVSZXNpemVDb250cm9sID0gbWVtbyhSZXNpemVDb250cm9sKTtcblxuLyoqXG4gKiBUaGUgYDxOb2RlUmVzaXplciAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGFkZCBhIHJlc2l6ZSBmdW5jdGlvbmFsaXR5IHRvIHlvdXJcbiAqIG5vZGVzLiBJdCByZW5kZXJzIGRyYWdnYWJsZSBjb250cm9scyBhcm91bmQgdGhlIG5vZGUgdG8gcmVzaXplIGluIGFsbCBkaXJlY3Rpb25zLlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKmBgYGpzeFxuICppbXBvcnQgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uLCBOb2RlUmVzaXplciB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gUmVzaXphYmxlTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8Tm9kZVJlc2l6ZXIgbWluV2lkdGg9ezEwMH0gbWluSGVpZ2h0PXszMH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogMTAgfX0+e2RhdGEubGFiZWx9PC9kaXY+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBtZW1vKFJlc2l6YWJsZU5vZGUpO1xuICpgYGBcbiAqL1xuZnVuY3Rpb24gTm9kZVJlc2l6ZXIoeyBub2RlSWQsIGlzVmlzaWJsZSA9IHRydWUsIGhhbmRsZUNsYXNzTmFtZSwgaGFuZGxlU3R5bGUsIGxpbmVDbGFzc05hbWUsIGxpbmVTdHlsZSwgY29sb3IsIG1pbldpZHRoID0gMTAsIG1pbkhlaWdodCA9IDEwLCBtYXhXaWR0aCA9IE51bWJlci5NQVhfVkFMVUUsIG1heEhlaWdodCA9IE51bWJlci5NQVhfVkFMVUUsIGtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlLCBhdXRvU2NhbGUgPSB0cnVlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBsaW5lQ2xhc3NOYW1lLCBzdHlsZTogbGluZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCB2YXJpYW50OiBSZXNpemVDb250cm9sVmFyaWFudC5MaW5lLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBhdXRvU2NhbGU6IGF1dG9TY2FsZSwgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGhhbmRsZUNsYXNzTmFtZSwgc3R5bGU6IGhhbmRsZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBhdXRvU2NhbGU6IGF1dG9TY2FsZSwgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcmVuZGVyZXInKTtcbmZ1bmN0aW9uIE5vZGVUb29sYmFyUG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VTdG9yZShzZWxlY3Rvcik7XG4gICAgaWYgKCF3cmFwcGVyUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB3cmFwcGVyUmVmKTtcbn1cblxuY29uc3Qgbm9kZUVxdWFsaXR5Rm4gPSAoYSwgYikgPT4gYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCB8fFxuICAgIGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgfHxcbiAgICBhPy5tZWFzdXJlZC53aWR0aCAhPT0gYj8ubWVhc3VyZWQud2lkdGggfHxcbiAgICBhPy5tZWFzdXJlZC5oZWlnaHQgIT09IGI/Lm1lYXN1cmVkLmhlaWdodCB8fFxuICAgIGE/LnNlbGVjdGVkICE9PSBiPy5zZWxlY3RlZCB8fFxuICAgIGE/LmludGVybmFscy56ICE9PSBiPy5pbnRlcm5hbHMuejtcbmNvbnN0IG5vZGVzRXF1YWxpdHlGbiA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBhKSB7XG4gICAgICAgIGlmIChub2RlRXF1YWxpdHlGbihub2RlLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IHN0b3JlU2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG4gICAgc2VsZWN0ZWROb2Rlc0NvdW50OiBzdGF0ZS5ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpLmxlbmd0aCxcbn0pO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gcmVuZGVyIGEgdG9vbGJhciBvciB0b29sdGlwIHRvIG9uZSBzaWRlIG9mIGEgY3VzdG9tIG5vZGUuIFRoaXNcbiAqIHRvb2xiYXIgZG9lc24ndCBzY2FsZSB3aXRoIHRoZSB2aWV3cG9ydCBzbyB0aGF0IHRoZSBjb250ZW50IGlzIGFsd2F5cyB2aXNpYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVRvb2xiYXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEN1c3RvbU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVUb29sYmFyIGlzVmlzaWJsZT17ZGF0YS50b29sYmFyVmlzaWJsZX0gcG9zaXRpb249e2RhdGEudG9vbGJhclBvc2l0aW9ufT5cbiAqICAgICAgICA8YnV0dG9uPmRlbGV0ZTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+Y29weTwvYnV0dG9uPlxuICogICAgICAgIDxidXR0b24+ZXhwYW5kPC9idXR0b24+XG4gKiAgICAgIDwvTm9kZVRvb2xiYXI+XG4gKlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhDdXN0b21Ob2RlKTtcbiAqYGBgXG4gKiBAcmVtYXJrcyBCeSBkZWZhdWx0LCB0aGUgdG9vbGJhciBpcyBvbmx5IHZpc2libGUgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQuIElmIG11bHRpcGxlXG4gKiBub2RlcyBhcmUgc2VsZWN0ZWQgaXQgd2lsbCBub3QgYmUgdmlzaWJsZSB0byBwcmV2ZW50IG92ZXJsYXBwaW5nIHRvb2xiYXJzIG9yXG4gKiBjbHV0dGVyLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyB0aGUgYGlzVmlzaWJsZWAgcHJvcCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIE5vZGVUb29sYmFyKHsgbm9kZUlkLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgb2Zmc2V0ID0gMTAsIGFsaWduID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBub2Rlc1NlbGVjdG9yID0gdXNlQ2FsbGJhY2soKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZCkgPyBub2RlSWQgOiBbbm9kZUlkIHx8IGNvbnRleHROb2RlSWQgfHwgJyddO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gbm9kZUlkcy5yZWR1Y2UoKHJlcywgaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxOb2RlcztcbiAgICB9LCBbbm9kZUlkLCBjb250ZXh0Tm9kZUlkXSk7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBub2Rlc0VxdWFsaXR5Rm4pO1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSwgc2VsZWN0ZWROb2Rlc0NvdW50IH0gPSB1c2VTdG9yZShzdG9yZVNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICAvLyBpZiBpc1Zpc2libGUgaXMgbm90IHNldCwgd2Ugc2hvdyB0aGUgdG9vbGJhciBvbmx5IGlmIGl0cyBub2RlIGlzIHNlbGVjdGVkIGFuZCBubyBvdGhlciBub2RlIGlzIHNlbGVjdGVkXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0eXBlb2YgaXNWaXNpYmxlID09PSAnYm9vbGVhbidcbiAgICAgICAgPyBpc1Zpc2libGVcbiAgICAgICAgOiBub2Rlcy5zaXplID09PSAxICYmIG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZT8uc2VsZWN0ZWQgJiYgc2VsZWN0ZWROb2Rlc0NvdW50ID09PSAxO1xuICAgIGlmICghaXNBY3RpdmUgfHwgIW5vZGVzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVSZWN0ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlcyk7XG4gICAgY29uc3Qgbm9kZXNBcnJheSA9IEFycmF5LmZyb20obm9kZXMudmFsdWVzKCkpO1xuICAgIGNvbnN0IHpJbmRleCA9IE1hdGgubWF4KC4uLm5vZGVzQXJyYXkubWFwKChub2RlKSA9PiBub2RlLmludGVybmFscy56ICsgMSkpO1xuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHsgeCwgeSwgem9vbSB9LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbiksXG4gICAgICAgIHpJbmRleCxcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChOb2RlVG9vbGJhclBvcnRhbCwgeyBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGUtdG9vbGJhcicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0LCBcImRhdGEtaWRcIjogbm9kZXNBcnJheS5yZWR1Y2UoKGFjYywgbm9kZSkgPT4gYCR7YWNjfSR7bm9kZS5pZH0gYCwgJycpLnRyaW0oKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZXhwb3J0IHsgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQsIEJhc2VFZGdlLCBCZXppZXJFZGdlLCBDb250cm9sQnV0dG9uLCBDb250cm9scywgRWRnZUxhYmVsUmVuZGVyZXIsIEVkZ2VUZXh0LCBIYW5kbGUsIE1pbmlNYXAsIE1pbmlNYXBOb2RlLCBOb2RlUmVzaXplQ29udHJvbCwgTm9kZVJlc2l6ZXIsIE5vZGVUb29sYmFyLCBQYW5lbCwgaW5kZXggYXMgUmVhY3RGbG93LCBSZWFjdEZsb3dQcm92aWRlciwgU2ltcGxlQmV6aWVyRWRnZSwgU21vb3RoU3RlcEVkZ2UsIFN0ZXBFZGdlLCBTdHJhaWdodEVkZ2UsIFZpZXdwb3J0UG9ydGFsLCBhcHBseUVkZ2VDaGFuZ2VzLCBhcHBseU5vZGVDaGFuZ2VzLCBnZXRTaW1wbGVCZXppZXJQYXRoLCBpc0VkZ2UsIGlzTm9kZSwgdXNlQ29ubmVjdGlvbiwgdXNlRWRnZXMsIHVzZUVkZ2VzU3RhdGUsIHVzZUhhbmRsZUNvbm5lY3Rpb25zLCB1c2VJbnRlcm5hbE5vZGUsIHVzZUtleVByZXNzLCB1c2VOb2RlQ29ubmVjdGlvbnMsIHVzZU5vZGVJZCwgdXNlTm9kZXMsIHVzZU5vZGVzRGF0YSwgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbImpzeHMiLCJGcmFnbWVudCIsImpzeCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwibWVtbyIsImNjIiwiZXJyb3JNZXNzYWdlcyIsIm1lcmdlQXJpYUxhYmVsQ29uZmlnIiwiaW5maW5pdGVFeHRlbnQiLCJpc0lucHV0RE9NTm9kZSIsImdldFZpZXdwb3J0Rm9yQm91bmRzIiwicG9pbnRUb1JlbmRlcmVyUG9pbnQiLCJyZW5kZXJlclBvaW50VG9Qb2ludCIsImlzTm9kZUJhc2UiLCJpc0VkZ2VCYXNlIiwiZ2V0RWxlbWVudHNUb1JlbW92ZSIsImlzUmVjdE9iamVjdCIsIm5vZGVUb1JlY3QiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJnZXROb2Rlc0JvdW5kcyIsIndpdGhSZXNvbHZlcnMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJnZXREaW1lbnNpb25zIiwiWFlQYW5ab29tIiwiUGFuT25TY3JvbGxNb2RlIiwiU2VsZWN0aW9uTW9kZSIsImdldEV2ZW50UG9zaXRpb24iLCJnZXROb2Rlc0luc2lkZSIsImFyZVNldHNFcXVhbCIsIlhZRHJhZyIsInNuYXBQb3NpdGlvbiIsImNhbGN1bGF0ZU5vZGVQb3NpdGlvbiIsIlBvc2l0aW9uIiwiQ29ubmVjdGlvbk1vZGUiLCJpc01vdXNlRXZlbnQiLCJYWUhhbmRsZSIsImdldEhvc3RGb3JFbGVtZW50IiwiYWRkRWRnZSIsImdldEludGVybmFsTm9kZXNCb3VuZHMiLCJpc051bWVyaWMiLCJub2RlSGFzRGltZW5zaW9ucyIsImdldE5vZGVEaW1lbnNpb25zIiwiZWxlbWVudFNlbGVjdGlvbktleXMiLCJpc0VkZ2VWaXNpYmxlIiwiTWFya2VyVHlwZSIsImNyZWF0ZU1hcmtlcklkcyIsImdldEJlemllckVkZ2VDZW50ZXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImdldFN0cmFpZ2h0UGF0aCIsImdldEJlemllclBhdGgiLCJnZXRFZGdlUG9zaXRpb24iLCJnZXRFbGV2YXRlZEVkZ2VaSW5kZXgiLCJnZXRNYXJrZXJJZCIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW9uTGluZVR5cGUiLCJ1cGRhdGVDb25uZWN0aW9uTG9va3VwIiwiYWRvcHRVc2VyTm9kZXMiLCJpbml0aWFsQ29ubmVjdGlvbiIsImRldldhcm4iLCJkZWZhdWx0QXJpYUxhYmVsQ29uZmlnIiwidXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUFic29sdXRlUG9zaXRpb25zIiwiaGFuZGxlRXhwYW5kUGFyZW50IiwicGFuQnkiLCJmaXRWaWV3cG9ydCIsImlzTWFjT3MiLCJhcmVDb25uZWN0aW9uTWFwc0VxdWFsIiwiaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSIsInNoYWxsb3dOb2RlRGF0YSIsIlhZTWluaW1hcCIsImdldEJvdW5kc09mUmVjdHMiLCJSZXNpemVDb250cm9sVmFyaWFudCIsIlhZUmVzaXplciIsIlhZX1JFU0laRVJfTElORV9QT1NJVElPTlMiLCJYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMiLCJnZXROb2RlVG9vbGJhclRyYW5zZm9ybSIsImdldENvbm5lY3RlZEVkZ2VzIiwiZ2V0RWRnZUNlbnRlciIsImdldEluY29tZXJzIiwiZ2V0T3V0Z29lcnMiLCJyZWNvbm5lY3RFZGdlIiwidXNlU3RvcmVXaXRoRXF1YWxpdHlGbiIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuIiwic2hhbGxvdyIsImNyZWF0ZVBvcnRhbCIsIlN0b3JlQ29udGV4dCIsIlByb3ZpZGVyJDEiLCJQcm92aWRlciIsInp1c3RhbmRFcnJvck1lc3NhZ2UiLCJ1c2VTdG9yZSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsInN0b3JlIiwiRXJyb3IiLCJ1c2VTdG9yZUFwaSIsImdldFN0YXRlIiwic2V0U3RhdGUiLCJzdWJzY3JpYmUiLCJzdHlsZSIsImRpc3BsYXkiLCJhcmlhTGl2ZVN0eWxlIiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsIm1hcmdpbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImNsaXAiLCJjbGlwUGF0aCIsIkFSSUFfTk9ERV9ERVNDX0tFWSIsIkFSSUFfRURHRV9ERVNDX0tFWSIsIkFSSUFfTElWRV9NRVNTQUdFIiwiYXJpYUxpdmVTZWxlY3RvciIsInMiLCJhcmlhTGl2ZU1lc3NhZ2UiLCJhcmlhTGFiZWxDb25maWdTZWxlY3RvciIsImFyaWFMYWJlbENvbmZpZyIsIkFyaWFMaXZlTWVzc2FnZSIsInJmSWQiLCJpZCIsImNoaWxkcmVuIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJQYW5lbCIsImNsYXNzTmFtZSIsInJlc3QiLCJyZWYiLCJwb3NpdGlvbkNsYXNzZXMiLCJzcGxpdCIsImRpc3BsYXlOYW1lIiwiQXR0cmlidXRpb24iLCJwcm9PcHRpb25zIiwiaGlkZUF0dHJpYnV0aW9uIiwiaHJlZiIsInRhcmdldCIsInJlbCIsInNlbGVjdG9yJG0iLCJzZWxlY3RlZE5vZGVzIiwic2VsZWN0ZWRFZGdlcyIsIm5vZGUiLCJub2RlTG9va3VwIiwic2VsZWN0ZWQiLCJwdXNoIiwiaW50ZXJuYWxzIiwidXNlck5vZGUiLCJlZGdlIiwiZWRnZUxvb2t1cCIsInNlbGVjdElkIiwib2JqIiwiYXJlRXF1YWwiLCJhIiwiYiIsIm1hcCIsIlNlbGVjdGlvbkxpc3RlbmVySW5uZXIiLCJvblNlbGVjdGlvbkNoYW5nZSIsInBhcmFtcyIsIm5vZGVzIiwiZWRnZXMiLCJvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZm9yRWFjaCIsImZuIiwiY2hhbmdlU2VsZWN0b3IiLCJTZWxlY3Rpb25MaXN0ZW5lciIsInN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJkZWZhdWx0Tm9kZU9yaWdpbiIsImRlZmF1bHRWaWV3cG9ydCIsIngiLCJ5Iiwiem9vbSIsInJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2siLCJmaWVsZHNUb1RyYWNrIiwic2VsZWN0b3IkbCIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInNldFRyYW5zbGF0ZUV4dGVudCIsInNldE5vZGVFeHRlbnQiLCJyZXNldCIsInNldERlZmF1bHROb2Rlc0FuZEVkZ2VzIiwic2V0UGFuZUNsaWNrRGlzdGFuY2UiLCJpbml0UHJldlZhbHVlcyIsInRyYW5zbGF0ZUV4dGVudCIsIm5vZGVPcmlnaW4iLCJtaW5ab29tIiwibWF4Wm9vbSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm5vUGFuQ2xhc3NOYW1lIiwicGFuZUNsaWNrRGlzdGFuY2UiLCJTdG9yZVVwZGF0ZXIiLCJwcm9wcyIsImRlZmF1bHROb2RlcyIsImRlZmF1bHRFZGdlcyIsInByZXZpb3VzRmllbGRzIiwiY3VycmVudCIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJwcmV2aW91c0ZpZWxkVmFsdWUiLCJmaXRWaWV3UXVldWVkIiwiZml0Vmlld09wdGlvbnMiLCJnZXRNZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsInVzZUNvbG9yTW9kZUNsYXNzIiwiY29sb3JNb2RlIiwiY29sb3JNb2RlQ2xhc3MiLCJzZXRDb2xvck1vZGVDbGFzcyIsIm1lZGlhUXVlcnkiLCJ1cGRhdGVDb2xvck1vZGVDbGFzcyIsIm1hdGNoZXMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHREb2MiLCJkb2N1bWVudCIsInVzZUtleVByZXNzIiwia2V5Q29kZSIsIm9wdGlvbnMiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJmaWx0ZXIiLCJrYyIsInJlcGxhY2UiLCJrZXlzRmxhdCIsInJlZHVjZSIsInJlcyIsIml0ZW0iLCJjb25jYXQiLCJkb3duSGFuZGxlciIsImV2ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsInByZXZlbnRBY3Rpb24iLCJrZXlPckNvZGUiLCJ1c2VLZXlPckNvZGUiLCJjb2RlIiwiYWRkIiwiaXNNYXRjaGluZ0tleSIsImNvbXBvc2VkUGF0aCIsImlzSW50ZXJhY3RpdmVFbGVtZW50Iiwibm9kZU5hbWUiLCJwcmV2ZW50RGVmYXVsdCIsInVwSGFuZGxlciIsImNsZWFyIiwiZGVsZXRlIiwia2V5IiwicmVzZXRIYW5kbGVyIiwiaXNVcCIsImxlbmd0aCIsInNpemUiLCJzb21lIiwiZXZlcnkiLCJrIiwiaGFzIiwiZXZlbnRDb2RlIiwiaW5jbHVkZXMiLCJ1c2VWaWV3cG9ydEhlbHBlciIsInpvb21JbiIsInBhblpvb20iLCJzY2FsZUJ5IiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInpvb21PdXQiLCJ6b29tVG8iLCJ6b29tTGV2ZWwiLCJzY2FsZVRvIiwiZ2V0Wm9vbSIsInRyYW5zZm9ybSIsInNldFZpZXdwb3J0Iiwidmlld3BvcnQiLCJ0WCIsInRZIiwidFpvb20iLCJnZXRWaWV3cG9ydCIsInNldENlbnRlciIsImZpdEJvdW5kcyIsImJvdW5kcyIsImVhc2UiLCJpbnRlcnBvbGF0ZSIsInNjcmVlblRvRmxvd1Bvc2l0aW9uIiwiY2xpZW50UG9zaXRpb24iLCJzbmFwR3JpZCIsInNuYXBUb0dyaWQiLCJkb21Ob2RlIiwiZG9tWCIsImRvbVkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3JyZWN0ZWRQb3NpdGlvbiIsIl9zbmFwR3JpZCIsIl9zbmFwVG9HcmlkIiwiZmxvd1RvU2NyZWVuUG9zaXRpb24iLCJmbG93UG9zaXRpb24iLCJyZW5kZXJlclBvc2l0aW9uIiwiYXBwbHlDaGFuZ2VzIiwiY2hhbmdlcyIsImVsZW1lbnRzIiwidXBkYXRlZEVsZW1lbnRzIiwiY2hhbmdlc01hcCIsIk1hcCIsImFkZEl0ZW1DaGFuZ2VzIiwiY2hhbmdlIiwidHlwZSIsInNldCIsImVsZW1lbnRDaGFuZ2VzIiwiZ2V0IiwiZWxlbWVudCIsInVwZGF0ZWRFbGVtZW50IiwiYXBwbHlDaGFuZ2UiLCJpbmRleCIsInVuZGVmaW5lZCIsInNwbGljZSIsImRyYWdnaW5nIiwiZGltZW5zaW9ucyIsIm1lYXN1cmVkIiwic2V0QXR0cmlidXRlcyIsInJlc2l6aW5nIiwiYXBwbHlOb2RlQ2hhbmdlcyIsImFwcGx5RWRnZUNoYW5nZXMiLCJjcmVhdGVTZWxlY3Rpb25DaGFuZ2UiLCJnZXRTZWxlY3Rpb25DaGFuZ2VzIiwiaXRlbXMiLCJzZWxlY3RlZElkcyIsIm11dGF0ZUl0ZW0iLCJ3aWxsQmVTZWxlY3RlZCIsImdldEVsZW1lbnRzRGlmZkNoYW5nZXMiLCJsb29rdXAiLCJpdGVtc0xvb2t1cCIsImVudHJpZXMiLCJsb29rdXBJdGVtIiwic3RvcmVJdGVtIiwibmV4dE5vZGUiLCJlbGVtZW50VG9SZW1vdmVDaGFuZ2UiLCJpc05vZGUiLCJpc0VkZ2UiLCJmaXhlZEZvcndhcmRSZWYiLCJyZW5kZXIiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlUXVldWUiLCJydW5RdWV1ZSIsInNlcmlhbCIsInNldFNlcmlhbCIsIkJpZ0ludCIsInF1ZXVlIiwiY3JlYXRlUXVldWUiLCJuIiwicXVldWVJdGVtcyIsImNiIiwiQmF0Y2hDb250ZXh0IiwiQmF0Y2hQcm92aWRlciIsIm5vZGVRdWV1ZUhhbmRsZXIiLCJoYXNEZWZhdWx0Tm9kZXMiLCJvbk5vZGVzQ2hhbmdlIiwibmV4dCIsInBheWxvYWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub2RlUXVldWUiLCJlZGdlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdEVkZ2VzIiwib25FZGdlc0NoYW5nZSIsImVkZ2VRdWV1ZSIsInZhbHVlIiwidXNlQmF0Y2hDb250ZXh0IiwiYmF0Y2hDb250ZXh0Iiwic2VsZWN0b3IkayIsInVzZVJlYWN0RmxvdyIsInZpZXdwb3J0SGVscGVyIiwidmlld3BvcnRJbml0aWFsaXplZCIsImdlbmVyYWxIZWxwZXIiLCJnZXRJbnRlcm5hbE5vZGUiLCJnZXROb2RlUmVjdCIsIm5vZGVUb1VzZSIsInBhcmVudElkIiwibm9kZVdpdGhQb3NpdGlvbiIsInVwZGF0ZU5vZGUiLCJub2RlVXBkYXRlIiwicHJldk5vZGVzIiwidXBkYXRlRWRnZSIsImVkZ2VVcGRhdGUiLCJwcmV2RWRnZXMiLCJuZXh0RWRnZSIsImdldE5vZGVzIiwiZ2V0Tm9kZSIsImdldEVkZ2VzIiwiZSIsImdldEVkZ2UiLCJhZGROb2RlcyIsIm5ld05vZGVzIiwiYWRkRWRnZXMiLCJuZXdFZGdlcyIsInRvT2JqZWN0IiwiZGVsZXRlRWxlbWVudHMiLCJub2Rlc1RvUmVtb3ZlIiwiZWRnZXNUb1JlbW92ZSIsIm9uTm9kZXNEZWxldGUiLCJvbkVkZ2VzRGVsZXRlIiwidHJpZ2dlck5vZGVDaGFuZ2VzIiwidHJpZ2dlckVkZ2VDaGFuZ2VzIiwib25EZWxldGUiLCJvbkJlZm9yZURlbGV0ZSIsIm1hdGNoaW5nTm9kZXMiLCJtYXRjaGluZ0VkZ2VzIiwiaGFzTWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nTm9kZXMiLCJlZGdlQ2hhbmdlcyIsIm5vZGVDaGFuZ2VzIiwiZGVsZXRlZE5vZGVzIiwiZGVsZXRlZEVkZ2VzIiwiZ2V0SW50ZXJzZWN0aW5nTm9kZXMiLCJub2RlT3JSZWN0IiwicGFydGlhbGx5IiwiaXNSZWN0Iiwibm9kZVJlY3QiLCJoYXNOb2Rlc09wdGlvbiIsImludGVybmFsTm9kZSIsInBvc2l0aW9uQWJzb2x1dGUiLCJjdXJyTm9kZVJlY3QiLCJvdmVybGFwcGluZ0FyZWEiLCJwYXJ0aWFsbHlWaXNpYmxlIiwiaXNOb2RlSW50ZXJzZWN0aW5nIiwiYXJlYSIsInVwZGF0ZU5vZGVEYXRhIiwiZGF0YVVwZGF0ZSIsIm5leHREYXRhIiwiZGF0YSIsInVwZGF0ZUVkZ2VEYXRhIiwiZ2V0SGFuZGxlQ29ubmVjdGlvbnMiLCJub2RlSWQiLCJmcm9tIiwiY29ubmVjdGlvbkxvb2t1cCIsInZhbHVlcyIsImdldE5vZGVDb25uZWN0aW9ucyIsImhhbmRsZUlkIiwiZml0VmlldyIsImZpdFZpZXdSZXNvbHZlciIsInByb21pc2UiLCJ3aW4kMSIsInVzZUdsb2JhbEtleUhhbmRsZXIiLCJkZWxldGVLZXlDb2RlIiwibXVsdGlTZWxlY3Rpb25LZXlDb2RlIiwiZGVsZXRlS2V5UHJlc3NlZCIsIm11bHRpU2VsZWN0aW9uS2V5UHJlc3NlZCIsIm5vZGVzU2VsZWN0aW9uQWN0aXZlIiwibXVsdGlTZWxlY3Rpb25BY3RpdmUiLCJ1c2VSZXNpemVIYW5kbGVyIiwidXBkYXRlRGltZW5zaW9ucyIsImNoZWNrVmlzaWJpbGl0eSIsIm9uRXJyb3IiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNvbnRhaW5lclN0eWxlIiwidG9wIiwibGVmdCIsInNlbGVjdG9yJGoiLCJ1c2VyU2VsZWN0aW9uQWN0aXZlIiwibGliIiwiY29ubmVjdGlvbkluUHJvZ3Jlc3MiLCJjb25uZWN0aW9uIiwiaW5Qcm9ncmVzcyIsIlpvb21QYW5lIiwib25QYW5lQ29udGV4dE1lbnUiLCJ6b29tT25TY3JvbGwiLCJ6b29tT25QaW5jaCIsInBhbk9uU2Nyb2xsIiwicGFuT25TY3JvbGxTcGVlZCIsInBhbk9uU2Nyb2xsTW9kZSIsIkZyZWUiLCJ6b29tT25Eb3VibGVDbGljayIsInBhbk9uRHJhZyIsInpvb21BY3RpdmF0aW9uS2V5Q29kZSIsInByZXZlbnRTY3JvbGxpbmciLCJub1doZWVsQ2xhc3NOYW1lIiwib25WaWV3cG9ydENoYW5nZSIsImlzQ29udHJvbGxlZFZpZXdwb3J0Iiwiem9vbVBhbmUiLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJvblRyYW5zZm9ybUNoYW5nZSIsIm9uRHJhZ2dpbmdDaGFuZ2UiLCJwYW5lRHJhZ2dpbmciLCJvblBhblpvb21TdGFydCIsInZwIiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25Nb3ZlU3RhcnQiLCJvblBhblpvb20iLCJvbk1vdmUiLCJvblBhblpvb21FbmQiLCJvblZpZXdwb3J0Q2hhbmdlRW5kIiwib25Nb3ZlRW5kIiwiY2xvc2VzdCIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJzZWxlY3RvciRpIiwidXNlclNlbGVjdGlvblJlY3QiLCJVc2VyU2VsZWN0aW9uIiwiaXNBY3RpdmUiLCJ3cmFwSGFuZGxlciIsImhhbmRsZXIiLCJjb250YWluZXJSZWYiLCJzZWxlY3RvciRoIiwiUGFuZSIsImlzU2VsZWN0aW5nIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbk1vZGUiLCJGdWxsIiwic2VsZWN0aW9uT25EcmFnIiwib25TZWxlY3Rpb25TdGFydCIsIm9uU2VsZWN0aW9uRW5kIiwib25QYW5lQ2xpY2siLCJvblBhbmVTY3JvbGwiLCJvblBhbmVNb3VzZUVudGVyIiwib25QYW5lTW91c2VNb3ZlIiwib25QYW5lTW91c2VMZWF2ZSIsImhhc0FjdGl2ZVNlbGVjdGlvbiIsImNvbnRhaW5lciIsImNvbnRhaW5lckJvdW5kcyIsInNlbGVjdGVkTm9kZUlkcyIsInNlbGVjdGVkRWRnZUlkcyIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJzZWxlY3Rpb25TdGFydGVkIiwib25DbGljayIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwiZGVmYXVsdEVkZ2VPcHRpb25zIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwiaXNNb3VzZVRyaWdnZXJlZCIsImN1cnJlbnRTdG9yZSIsImhhbmRsZURvbU5vZGUiLCJjdXJyZW50VGFyZ2V0IiwiYXV0b1Bhbk9uQ29ubmVjdCIsImNvbm5lY3Rpb25SYWRpdXMiLCJmbG93SWQiLCJjYW5jZWxDb25uZWN0aW9uIiwib25Db25uZWN0U3RhcnQiLCJvbkNvbm5lY3RFbmQiLCJ1cGRhdGVDb25uZWN0aW9uIiwiZ2V0VHJhbnNmb3JtIiwiZ2V0RnJvbUhhbmRsZSIsImF1dG9QYW5TcGVlZCIsImRyYWdUaHJlc2hvbGQiLCJjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCIsIm9uQ2xpY2tDb25uZWN0U3RhcnQiLCJvbkNsaWNrQ29ubmVjdEVuZCIsImlzVmFsaWRDb25uZWN0aW9uU3RvcmUiLCJjb25uZWN0aW9uU3RhdGUiLCJoYW5kbGVUeXBlIiwiZG9jIiwiaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyIiwiaGFuZGxlIiwiZnJvbU5vZGVJZCIsImZyb21IYW5kbGVJZCIsImZyb21UeXBlIiwiY29ubmVjdGlvbkNsb25lIiwic3RydWN0dXJlZENsb25lIiwidG9Qb3NpdGlvbiIsInNvdXJjZSIsImNvbm5lY3RhYmxlIiwiY29ubmVjdGFibGVzdGFydCIsImNvbm5lY3RhYmxlZW5kIiwiY2xpY2tjb25uZWN0aW5nIiwiY29ubmVjdGluZ2Zyb20iLCJjb25uZWN0aW5ndG8iLCJjb25uZWN0aW9uaW5kaWNhdG9yIiwiSGFuZGxlIiwiSW5wdXROb2RlIiwic291cmNlUG9zaXRpb24iLCJCb3R0b20iLCJsYWJlbCIsIkRlZmF1bHROb2RlIiwidGFyZ2V0UG9zaXRpb24iLCJHcm91cE5vZGUiLCJPdXRwdXROb2RlIiwiYXJyb3dLZXlEaWZmcyIsIkFycm93VXAiLCJBcnJvd0Rvd24iLCJBcnJvd0xlZnQiLCJBcnJvd1JpZ2h0IiwiYnVpbHRpbk5vZGVUeXBlcyIsImlucHV0IiwiZGVmYXVsdCIsIm91dHB1dCIsImdyb3VwIiwiZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyIsImhhbmRsZUJvdW5kcyIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJzZWxlY3RvciRmIiwidHJhbnNmb3JtU3RyaW5nIiwiTm9kZXNTZWxlY3Rpb24iLCJvblNlbGVjdGlvbkNvbnRleHRNZW51IiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwib25LZXlEb3duIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidGFiSW5kZXgiLCJ3aW4iLCJzZWxlY3RvciRlIiwiRmxvd1JlbmRlcmVyQ29tcG9uZW50Iiwic2VsZWN0aW9uS2V5Q29kZSIsInBhbkFjdGl2YXRpb25LZXlDb2RlIiwiX3Bhbk9uU2Nyb2xsIiwiX3Bhbk9uRHJhZyIsInBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIiwiX3NlbGVjdGlvbk9uRHJhZyIsIkZsb3dSZW5kZXJlciIsInNlbGVjdG9yJGQiLCJvbmx5UmVuZGVyVmlzaWJsZSIsInVzZVZpc2libGVOb2RlSWRzIiwibm9kZUlkcyIsInNlbGVjdG9yJGMiLCJ1c2VSZXNpemVPYnNlcnZlciIsInVwZGF0ZXMiLCJlbnRyeSIsImdldEF0dHJpYnV0ZSIsIm5vZGVFbGVtZW50IiwiZm9yY2UiLCJkaXNjb25uZWN0IiwidXNlTm9kZU9ic2VydmVyIiwibm9kZVR5cGUiLCJoYXNEaW1lbnNpb25zIiwib2JzZXJ2ZWROb2RlIiwicHJldlNvdXJjZVBvc2l0aW9uIiwicHJldlRhcmdldFBvc2l0aW9uIiwicHJldlR5cGUiLCJpc0luaXRpYWxpemVkIiwiaGlkZGVuIiwidHlwZUNoYW5nZWQiLCJzb3VyY2VQb3NDaGFuZ2VkIiwidGFyZ2V0UG9zQ2hhbmdlZCIsIk5vZGVXcmFwcGVyIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwibm9kZXNDb25uZWN0YWJsZSIsIm5vZGVzRm9jdXNhYmxlIiwibm9kZVR5cGVzIiwiaXNQYXJlbnQiLCJwYXJlbnRMb29rdXAiLCJOb2RlQ29tcG9uZW50IiwiaXNEcmFnZ2FibGUiLCJpc0ZvY3VzYWJsZSIsImZvY3VzYWJsZSIsImRyYWdIYW5kbGUiLCJub2RlRGltZW5zaW9ucyIsImlubGluZURpbWVuc2lvbnMiLCJoYXNQb2ludGVyRXZlbnRzIiwib25Nb3VzZUVudGVySGFuZGxlciIsIm9uTW91c2VNb3ZlSGFuZGxlciIsIm9uTW91c2VMZWF2ZUhhbmRsZXIiLCJvbkNvbnRleHRNZW51SGFuZGxlciIsIm9uRG91YmxlQ2xpY2tIYW5kbGVyIiwib25TZWxlY3ROb2RlSGFuZGxlciIsInNlbGVjdE5vZGVzT25EcmFnIiwibm9kZURyYWdUaHJlc2hvbGQiLCJ0b0xvd2VyQ2FzZSIsIm9uRm9jdXMiLCJhdXRvUGFuT25Ob2RlRm9jdXMiLCJ3aXRoaW5WaWV3cG9ydCIsInBhcmVudCIsInpJbmRleCIsInoiLCJwb2ludGVyRXZlbnRzIiwidmlzaWJpbGl0eSIsInJvbGUiLCJhcmlhUm9sZSIsImFyaWFMYWJlbCIsImRvbUF0dHJpYnV0ZXMiLCJwb3NpdGlvbkFic29sdXRlWCIsInBvc2l0aW9uQWJzb2x1dGVZIiwiZGVsZXRhYmxlIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwiZWRnZUlkcyIsInZpc2libGVFZGdlSWRzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJBcnJvd1N5bWJvbCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwiZmlsbCIsInN0cm9rZUxpbmVqb2luIiwicG9pbnRzIiwiQXJyb3dDbG9zZWRTeW1ib2wiLCJNYXJrZXJTeW1ib2xzIiwiQXJyb3ciLCJBcnJvd0Nsb3NlZCIsInVzZU1hcmtlclN5bWJvbCIsInN5bWJvbCIsInN5bWJvbEV4aXN0cyIsIk1hcmtlciIsIm1hcmtlclVuaXRzIiwib3JpZW50IiwiU3ltYm9sIiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJ2aWV3Qm94IiwicmVmWCIsInJlZlkiLCJNYXJrZXJEZWZpbml0aW9ucyIsImRlZmF1bHRDb2xvciIsIm1hcmtlcnMiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJtYXJrZXJTdGFydCIsImRlZmF1bHRNYXJrZXJFbmQiLCJtYXJrZXJFbmQiLCJtYXJrZXIiLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwiRWRnZVRleHRDb21wb25lbnQiLCJsYWJlbFN0eWxlIiwibGFiZWxTaG93QmciLCJsYWJlbEJnU3R5bGUiLCJsYWJlbEJnUGFkZGluZyIsImxhYmVsQmdCb3JkZXJSYWRpdXMiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJlZGdlVGV4dENsYXNzZXMiLCJlZGdlVGV4dFJlZiIsInRleHRCYm94IiwiZ2V0QkJveCIsInJ4IiwicnkiLCJkeSIsIkVkZ2VUZXh0IiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwiaW50ZXJhY3Rpb25XaWR0aCIsImQiLCJzdHJva2VPcGFjaXR5IiwiZ2V0Q29udHJvbCIsInBvcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiTGVmdCIsIlJpZ2h0IiwiZ2V0U2ltcGxlQmV6aWVyUGF0aCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSIsIl9pZCIsImlzSW50ZXJuYWwiLCJTaW1wbGVCZXppZXJFZGdlIiwiU2ltcGxlQmV6aWVyRWRnZUludGVybmFsIiwiY3JlYXRlU21vb3RoU3RlcEVkZ2UiLCJwYXRoT3B0aW9ucyIsImJvcmRlclJhZGl1cyIsIm9mZnNldCIsInN0ZXBQb3NpdGlvbiIsIlNtb290aFN0ZXBFZGdlIiwiU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0ZXBFZGdlIiwiU3RlcEVkZ2UiLCJTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlSW50ZXJuYWwiLCJjcmVhdGVCZXppZXJFZGdlIiwiY3VydmF0dXJlIiwiQmV6aWVyRWRnZSIsIkJlemllckVkZ2VJbnRlcm5hbCIsImJ1aWx0aW5FZGdlVHlwZXMiLCJzdHJhaWdodCIsInN0ZXAiLCJzbW9vdGhzdGVwIiwic2ltcGxlYmV6aWVyIiwibnVsbFBvc2l0aW9uIiwic2hpZnRYIiwic2hpZnQiLCJzaGlmdFkiLCJFZGdlVXBkYXRlckNsYXNzTmFtZSIsIkVkZ2VBbmNob3IiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1cyIsIm9uTW91c2VPdXQiLCJjeCIsImN5IiwiciIsIkVkZ2VVcGRhdGVBbmNob3JzIiwiaXNSZWNvbm5lY3RhYmxlIiwicmVjb25uZWN0UmFkaXVzIiwib25SZWNvbm5lY3QiLCJvblJlY29ubmVjdFN0YXJ0Iiwib25SZWNvbm5lY3RFbmQiLCJzZXRSZWNvbm5lY3RpbmciLCJzZXRVcGRhdGVIb3ZlciIsImhhbmRsZUVkZ2VVcGRhdGVyIiwib3Bwb3NpdGVIYW5kbGUiLCJfb25SZWNvbm5lY3RFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwiX29uQ29ubmVjdFN0YXJ0IiwiX2V2ZW50IiwiZWRnZVVwZGF0ZXJUeXBlIiwib25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24iLCJ0YXJnZXRIYW5kbGUiLCJvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biIsInNvdXJjZUhhbmRsZSIsIm9uUmVjb25uZWN0TW91c2VFbnRlciIsIm9uUmVjb25uZWN0TW91c2VPdXQiLCJFZGdlV3JhcHBlciIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNSZWNvbm5lY3RhYmxlIiwiZWRnZVR5cGVzIiwiZWRnZVR5cGUiLCJFZGdlQ29tcG9uZW50IiwicmVjb25uZWN0YWJsZSIsImVkZ2VSZWYiLCJ1cGRhdGVIb3ZlciIsInJlY29ubmVjdGluZyIsImVkZ2VQb3NpdGlvbiIsImVsZXZhdGVPblNlbGVjdCIsImVsZXZhdGVFZGdlc09uU2VsZWN0IiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGljayIsIm9uRWRnZUNvbnRleHRNZW51Iiwib25FZGdlTW91c2VFbnRlciIsIm9uRWRnZU1vdXNlTW92ZSIsIm9uRWRnZU1vdXNlTGVhdmUiLCJhbmltYXRlZCIsImluYWN0aXZlIiwidXBkYXRpbmciLCJzb3VyY2VIYW5kbGVJZCIsInRhcmdldEhhbmRsZUlkIiwic2VsZWN0b3IkYSIsIkVkZ2VSZW5kZXJlckNvbXBvbmVudCIsImRlZmF1bHRNYXJrZXJDb2xvciIsIkVkZ2VSZW5kZXJlciIsInNlbGVjdG9yJDkiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwic2V0VGltZW91dCIsInNlbGVjdG9yJDgiLCJzeW5jVmlld3BvcnQiLCJ1c2VWaWV3cG9ydFN5bmMiLCJzdG9yZVNlbGVjdG9yJDEiLCJ0byIsImdldFNlbGVjdG9yIiwiY29ubmVjdGlvblNlbGVjdG9yIiwiY29tYmluZWRTZWxlY3RvciIsInVzZUNvbm5lY3Rpb24iLCJzZWxlY3RvciQ3IiwiQ29ubmVjdGlvbkxpbmVXcmFwcGVyIiwiY29tcG9uZW50IiwicmVuZGVyQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb25MaW5lIiwiQ3VzdG9tQ29tcG9uZW50IiwiQmV6aWVyIiwiZnJvbU5vZGUiLCJmcm9tUG9zaXRpb24iLCJ0b05vZGUiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsIm5vZGVzSW5pdGlhbGl6ZWQiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsImF1dG9QYW5Pbk5vZGVEcmFnIiwiZGVidWciLCJjcmVhdGVTdG9yZSIsInJlc29sdmVGaXRWaWV3IiwiY2hlY2tFcXVhbGl0eSIsInVwZGF0ZWRJbnRlcm5hbHMiLCJjb25zb2xlIiwibG9nIiwibm9kZURyYWdJdGVtcyIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwiZHJhZ0l0ZW0iLCJleHBhbmRQYXJlbnQiLCJtYXgiLCJyZWN0IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwiY2xpY2tEaXN0YW5jZSIsInNldENsaWNrRGlzdGFuY2UiLCJuZXh0Tm9kZUV4dGVudCIsImRlbHRhIiwibmV4dFpvb20iLCJpcyIsIlJlYWN0Rmxvd1Byb3ZpZGVyIiwiaW5pdGlhbE5vZGVzIiwiaW5pdGlhbEVkZ2VzIiwiaW5pdGlhbE1pblpvb20iLCJpbml0aWFsTWF4Wm9vbSIsImluaXRpYWxGaXRWaWV3T3B0aW9ucyIsIldyYXBwZXIiLCJpc1dyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJvbk5vZGVEcmFnU3RhcnQiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZyIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJkZWZhdWx0Vmlld3BvcnQkMSIsImF0dHJpYnV0aW9uUG9zaXRpb24iLCJvblNjcm9sbCIsImNvbG9yTW9kZUNsYXNzTmFtZSIsIndyYXBwZXJPblNjcm9sbCIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJzZWxlY3RvciQ2IiwiRWRnZUxhYmVsUmVuZGVyZXIiLCJlZGdlTGFiZWxSZW5kZXJlciIsInNlbGVjdG9yJDUiLCJWaWV3cG9ydFBvcnRhbCIsInZpZXdQb3J0YWxEaXYiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJ0cmlnZ2VyRml0VmlldyIsIm5vZGVzU2VsZWN0b3IiLCJ1c2VOb2RlcyIsImVkZ2VzU2VsZWN0b3IiLCJ1c2VFZGdlcyIsInZpZXdwb3J0U2VsZWN0b3IiLCJ1c2VWaWV3cG9ydCIsInVzZU5vZGVzU3RhdGUiLCJuZHMiLCJ1c2VFZGdlc1N0YXRlIiwiZWRzIiwidXNlT25WaWV3cG9ydENoYW5nZSIsIm9uU3RhcnQiLCJvbkNoYW5nZSIsIm9uRW5kIiwidXNlT25TZWxlY3Rpb25DaGFuZ2UiLCJuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsIm5leHRIYW5kbGVycyIsInNlbGVjdG9yJDQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIiwiaW5pdGlhbGl6ZWQiLCJ1c2VIYW5kbGVDb25uZWN0aW9ucyIsIm9uRGlzY29ubmVjdCIsIndhcm4iLCJfbm9kZUlkIiwiY3VycmVudE5vZGVJZCIsInByZXZDb25uZWN0aW9ucyIsIl9jb25uZWN0aW9ucyIsImVycm9yMDE0IiwidXNlTm9kZUNvbm5lY3Rpb25zIiwidXNlTm9kZXNEYXRhIiwibm9kZXNEYXRhIiwiaXNBcnJheU9mSWRzIiwiX25vZGVJZHMiLCJ1c2VJbnRlcm5hbE5vZGUiLCJMaW5lUGF0dGVybiIsImxpbmVXaWR0aCIsInZhcmlhbnQiLCJEb3RQYXR0ZXJuIiwiQmFja2dyb3VuZFZhcmlhbnQiLCJkZWZhdWx0U2l6ZSIsIkRvdHMiLCJMaW5lcyIsIkNyb3NzIiwic2VsZWN0b3IkMyIsInBhdHRlcm5JZCIsIkJhY2tncm91bmRDb21wb25lbnQiLCJnYXAiLCJiZ0NvbG9yIiwicGF0dGVybkNsYXNzTmFtZSIsInBhdHRlcm5TaXplIiwiaXNEb3RzIiwiaXNDcm9zcyIsImdhcFhZIiwic2NhbGVkR2FwIiwic2NhbGVkU2l6ZSIsIm9mZnNldFhZIiwicGF0dGVybkRpbWVuc2lvbnMiLCJzY2FsZWRPZmZzZXQiLCJfcGF0dGVybklkIiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsIkJhY2tncm91bmQiLCJQbHVzSWNvbiIsInhtbG5zIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwic2VsZWN0b3IkMiIsImlzSW50ZXJhY3RpdmUiLCJtaW5ab29tUmVhY2hlZCIsIm1heFpvb21SZWFjaGVkIiwiQ29udHJvbHNDb21wb25lbnQiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFZpZXciLCJvbkludGVyYWN0aXZlQ2hhbmdlIiwib3JpZW50YXRpb24iLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsIm9yaWVudGF0aW9uQ2xhc3MiLCJ0aXRsZSIsIkNvbnRyb2xzIiwiTWluaU1hcE5vZGVDb21wb25lbnQiLCJzdHJva2VDb2xvciIsInNoYXBlUmVuZGVyaW5nIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRDb2xvciIsIk1pbmlNYXBOb2RlIiwic2VsZWN0b3JOb2RlSWRzIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50Iiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsImNocm9tZSIsIk5vZGVDb21wb25lbnRXcmFwcGVyIiwiTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lciIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsImZpbHRlckhpZGRlbiIsInNlbGVjdG9yJDEiLCJ2aWV3QkIiLCJib3VuZGluZ1JlY3QiLCJmbG93V2lkdGgiLCJmbG93SGVpZ2h0IiwiQVJJQV9MQUJFTF9LRVkiLCJNaW5pTWFwQ29tcG9uZW50IiwibWFza0NvbG9yIiwibWFza1N0cm9rZUNvbG9yIiwibWFza1N0cm9rZVdpZHRoIiwicGFubmFibGUiLCJ6b29tYWJsZSIsImludmVyc2VQYW4iLCJ6b29tU3RlcCIsIm9mZnNldFNjYWxlIiwic3ZnIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwidmlld1NjYWxlIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImxhYmVsbGVkQnkiLCJ2aWV3U2NhbGVSZWYiLCJtaW5pbWFwSW5zdGFuY2UiLCJnZXRWaWV3U2NhbGUiLCJvblN2Z0NsaWNrIiwicG9pbnRlciIsIm9uU3ZnTm9kZUNsaWNrIiwiX2FyaWFMYWJlbCIsImZpbGxSdWxlIiwiTWluaU1hcCIsInNjYWxlU2VsZWN0b3IiLCJjYWxjdWxhdGVTY2FsZSIsImRlZmF1bHRQb3NpdGlvbnMiLCJMaW5lIiwiUmVzaXplQ29udHJvbCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJtYXhIZWlnaHQiLCJrZWVwQXNwZWN0UmF0aW8iLCJyZXNpemVEaXJlY3Rpb24iLCJhdXRvU2NhbGUiLCJzaG91bGRSZXNpemUiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemUiLCJvblJlc2l6ZUVuZCIsImNvbnRleHROb2RlSWQiLCJyZXNpemVDb250cm9sUmVmIiwiaXNIYW5kbGVDb250cm9sIiwic2NhbGUiLCJyZXNpemVyIiwiY29udHJvbFBvc2l0aW9uIiwicGFuZURvbU5vZGUiLCJjaGlsZENoYW5nZXMiLCJvcmlnaW4iLCJjaGlsZCIsInBvc2l0aW9uQ2hhbmdlIiwiZGltZW5zaW9uQ2hhbmdlIiwiY2hpbGRDaGFuZ2UiLCJib3VuZGFyaWVzIiwicG9zaXRpb25DbGFzc05hbWVzIiwiTm9kZVJlc2l6ZUNvbnRyb2wiLCJOb2RlUmVzaXplciIsImlzVmlzaWJsZSIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZVN0eWxlIiwibGluZUNsYXNzTmFtZSIsImxpbmVTdHlsZSIsIk5vZGVUb29sYmFyUG9ydGFsIiwid3JhcHBlclJlZiIsIm5vZGVFcXVhbGl0eUZuIiwibm9kZXNFcXVhbGl0eUZuIiwic3RvcmVTZWxlY3RvciIsInNlbGVjdGVkTm9kZXNDb3VudCIsIk5vZGVUb29sYmFyIiwiYWxpZ24iLCJpbnRlcm5hbE5vZGVzIiwibm9kZXNBcnJheSIsImFjYyIsInRyaW0iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d393e6a432f7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2hybi9EZXNrdG9wL2dhc2FibGVfbWNwL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3Qvc3R5bGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZDM5M2U2YTQzMmY3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shallow),\n/* harmony export */   shallow: () => (/* binding */ shallow$1)\n/* harmony export */ });\nfunction shallow$1(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar shallow = (objA, objB) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.\"\n    );\n  }\n  return shallow$1(objA, objB);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vc2hhbGxvdy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsiL1VzZXJzL2hybi9EZXNrdG9wL2dhc2FibGVfbWNwL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9zaGFsbG93Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzaGFsbG93JDEob2JqQSwgb2JqQikge1xuICBpZiAoT2JqZWN0LmlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqQSBpbnN0YW5jZW9mIE1hcCAmJiBvYmpCIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgaWYgKG9iakEuc2l6ZSAhPT0gb2JqQi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqQSkge1xuICAgICAgaWYgKCFPYmplY3QuaXModmFsdWUsIG9iakIuZ2V0KGtleSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9iakEgaW5zdGFuY2VvZiBTZXQgJiYgb2JqQiBpbnN0YW5jZW9mIFNldCkge1xuICAgIGlmIChvYmpBLnNpemUgIT09IG9iakIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqQSkge1xuICAgICAgaWYgKCFvYmpCLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmpCKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXlBIG9mIGtleXNBKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5QSkgfHwgIU9iamVjdC5pcyhvYmpBW2tleUFdLCBvYmpCW2tleUFdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHNoYWxsb3cgPSAob2JqQSwgb2JqQikgPT4ge1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBEZWZhdWx0IGV4cG9ydCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdydgLlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvdyQxKG9iakEsIG9iakIpO1xufTtcblxuZXhwb3J0IHsgc2hhbGxvdyBhcyBkZWZhdWx0LCBzaGFsbG93JDEgYXMgc2hhbGxvdyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWithEqualityFn: () => (/* binding */ createWithEqualityFn),\n/* harmony export */   useStoreWithEqualityFn: () => (/* binding */ useStoreWithEqualityFn)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/vanilla */ \"(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs\");\n\n\n\n\nconst { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_0__;\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__;\nconst identity = (arg) => arg;\nfunction useStoreWithEqualityFn(api, selector = identity, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn) => {\n  const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__.createStore)(createState);\n  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);\n  Object.assign(useBoundStoreWithEqualityFn, api);\n  return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdHJhZGl0aW9uYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlDO0FBQ3VEO0FBQzFDOztBQUU5QyxRQUFRLGdCQUFnQixFQUFFLGtDQUFZO0FBQ3RDLFFBQVEsbUNBQW1DLEVBQUUsMEVBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2hybi9EZXNrdG9wL2dhc2FibGVfbWNwL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS90cmFkaXRpb25hbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0RXhwb3J0cyBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzIGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYSc7XG5cbmNvbnN0IHsgdXNlRGVidWdWYWx1ZSB9ID0gUmVhY3RFeHBvcnRzO1xuY29uc3QgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9ID0gdXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzO1xuY29uc3QgaWRlbnRpdHkgPSAoYXJnKSA9PiBhcmc7XG5mdW5jdGlvbiB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuKGFwaSwgc2VsZWN0b3IgPSBpZGVudGl0eSwgZXF1YWxpdHlGbikge1xuICBjb25zdCBzbGljZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIGFwaS5zdWJzY3JpYmUsXG4gICAgYXBpLmdldFN0YXRlLFxuICAgIGFwaS5nZXRTZXJ2ZXJTdGF0ZSB8fCBhcGkuZ2V0SW5pdGlhbFN0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIGVxdWFsaXR5Rm5cbiAgKTtcbiAgdXNlRGVidWdWYWx1ZShzbGljZSk7XG4gIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGNyZWF0ZVdpdGhFcXVhbGl0eUZuSW1wbCA9IChjcmVhdGVTdGF0ZSwgZGVmYXVsdEVxdWFsaXR5Rm4pID0+IHtcbiAgY29uc3QgYXBpID0gY3JlYXRlU3RvcmUoY3JlYXRlU3RhdGUpO1xuICBjb25zdCB1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm4gPSAoc2VsZWN0b3IsIGVxdWFsaXR5Rm4gPSBkZWZhdWx0RXF1YWxpdHlGbikgPT4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihhcGksIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgT2JqZWN0LmFzc2lnbih1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm4sIGFwaSk7XG4gIHJldHVybiB1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm47XG59O1xuY29uc3QgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gPSAoY3JlYXRlU3RhdGUsIGRlZmF1bHRFcXVhbGl0eUZuKSA9PiBjcmVhdGVTdGF0ZSA/IGNyZWF0ZVdpdGhFcXVhbGl0eUZuSW1wbChjcmVhdGVTdGF0ZSwgZGVmYXVsdEVxdWFsaXR5Rm4pIDogY3JlYXRlV2l0aEVxdWFsaXR5Rm5JbXBsO1xuXG5leHBvcnQgeyBjcmVhdGVXaXRoRXF1YWxpdHlGbiwgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   \"default\": () => (/* binding */ vanilla)\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFMkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ocm4vRGVza3RvcC9nYXNhYmxlX21jcC9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3JlYXRlU3RvcmVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKCFPYmplY3QuaXMobmV4dFN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gKHJlcGxhY2UgIT0gbnVsbCA/IHJlcGxhY2UgOiB0eXBlb2YgbmV4dFN0YXRlICE9PSBcIm9iamVjdFwiIHx8IG5leHRTdGF0ZSA9PT0gbnVsbCkgPyBuZXh0U3RhdGUgOiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoc3RhdGUsIHByZXZpb3VzU3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFN0YXRlID0gKCkgPT4gc3RhdGU7XG4gIGNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGluaXRpYWxTdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gKGxpc3RlbmVyKSA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9O1xuICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltERVBSRUNBVEVEXSBUaGUgYGRlc3Ryb3lgIG1ldGhvZCB3aWxsIGJlIHVuc3VwcG9ydGVkIGluIGEgZnV0dXJlIHZlcnNpb24uIEluc3RlYWQgdXNlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHN1YnNjcmliZS4gRXZlcnl0aGluZyB3aWxsIGJlIGdhcmJhZ2UtY29sbGVjdGVkIGlmIHN0b3JlIGlzIGdhcmJhZ2UtY29sbGVjdGVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfTtcbiAgY29uc3QgYXBpID0geyBzZXRTdGF0ZSwgZ2V0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgc3Vic2NyaWJlLCBkZXN0cm95IH07XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHN0YXRlID0gY3JlYXRlU3RhdGUoc2V0U3RhdGUsIGdldFN0YXRlLCBhcGkpO1xuICByZXR1cm4gYXBpO1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKGNyZWF0ZVN0YXRlKSA9PiBjcmVhdGVTdGF0ZSA/IGNyZWF0ZVN0b3JlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVTdG9yZUltcGw7XG52YXIgdmFuaWxsYSA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBEZWZhdWx0IGV4cG9ydCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBpbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYScuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgdmFuaWxsYSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   defaultAriaLabelConfig: () => (/* binding */ defaultAriaLabelConfig),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   mergeAriaLabelConfig: () => (/* binding */ mergeAriaLabelConfig),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/zoom.js\");\n\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n    'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n    // Control elements\n    'controls.ariaLabel': 'Control Panel',\n    'controls.zoomIn.ariaLabel': 'Zoom In',\n    'controls.zoomOut.ariaLabel': 'Zoom Out',\n    'controls.fitView.ariaLabel': 'Fit View',\n    'controls.interactive.ariaLabel': 'Toggle Interactivity',\n    // Mini map\n    'minimap.ariaLabel': 'Mini Map',\n    // Handle\n    'handle.ariaLabel': 'Handle',\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate,\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return { ...defaultAriaLabelConfig, ...(partial || {}) };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false, }) {\n    if (zIndex !== undefined) {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? 1000 : 0;\n    const nodeZ = Math.max(sourceNode.parentId || (elevateOnSelect && sourceNode.selected) ? sourceNode.internals.z : 0, targetNode.parentId || (elevateOnSelect && targetNode.selected) ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === 'x') {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? (sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition);\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        }\n        else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? (sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n        stepPosition,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction parseHandles(userNode, internalNode) {\n    if (!userNode.handles) {\n        return !userNode.measured ? undefined : internalNode?.internals.handleBounds;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of userNode.handles) {\n        const handleBounds = {\n            id: handle.id,\n            width: handle.width ?? 1,\n            height: handle.height ?? 1,\n            nodeId: userNode.id,\n            x: handle.x,\n            y: handle.y,\n            position: handle.position,\n            type: handle.type,\n        };\n        if (handle.type === 'source') {\n            source.push(handleBounds);\n        }\n        else if (handle.type === 'target') {\n            target.push(handleBounds);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    let nodesInitialized = nodes.length > 0;\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: parseHandles(userNode, internalNode),\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({ dragItems, snapGrid, x, y, }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y,\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid\n                ? calculateSnapOffset({\n                    dragItems,\n                    snapGrid,\n                    x,\n                    y,\n                })\n                : null;\n            for (const [id, dragItem] of dragItems) {\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */\n                if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset\n                        ? {\n                            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                            y: Math.round(nextPosition.y + multiDragSnapOffset.y),\n                        }\n                        : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            dragEvent = event.sourceEvent;\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                // Calculate distance in client coordinates for consistent drag threshold behavior across zoom levels\n                const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                const x = currentMousePosition.x - mousePosition.x;\n                const y = currentMousePosition.y - mousePosition.y;\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, { nodeId, handleId, handleType });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        // Prevent multi-touch aborting connection\n        if ('touches' in event && event.touches.length > 0) {\n            return;\n        }\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            if (event.ctrlKey) {\n                event.preventDefault(); // stop native page zoom for pinch zooming\n            }\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        const isWheelEvent = event.type === 'wheel';\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // we want to disable pinch-zooming while making a connection\n        if (connectionInProgress && !isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (!isWheelEvent || (panOnScroll && isWheelEvent && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && isWheelEvent) {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || isWheelEvent) && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n            connectionInProgress,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        // we only want to trigger onResizeEnd if onResize was actually called\n        let resizeDetected = false;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!resizeDirection || resizeDirection === 'horizontal') ? width : prevValues.width;\n                change.height =\n                    isHeightChange && (!resizeDirection || resizeDirection === 'vertical') ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            resizeDetected = true;\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            if (!resizeDetected) {\n                return;\n            }\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n            resizeDetected = false;\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2dCO0FBQ2E7QUFDRTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQiw0QkFBNEIsVUFBVSxxQkFBcUIsRUFBRSxPQUFPLEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRCxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMmdEIiwic291cmNlcyI6WyIvVXNlcnMvaHJuL0Rlc2t0b3AvZ2FzYWJsZV9tY3Avbm9kZV9tb2R1bGVzL0B4eWZsb3cvc3lzdGVtL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IHNlbGVjdCwgcG9pbnRlciB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyB6b29tLCB6b29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gfSBmcm9tICdkMy16b29tJztcbmltcG9ydCB7IGludGVycG9sYXRlWm9vbSwgaW50ZXJwb2xhdGUgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5cbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XG4gICAgZXJyb3IwMDE6ICgpID0+ICdbUmVhY3QgRmxvd106IFNlZW1zIGxpa2UgeW91IGhhdmUgbm90IHVzZWQgenVzdGFuZCBwcm92aWRlciBhcyBhbiBhbmNlc3Rvci4gSGVscDogaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2Vycm9yIzAwMScsXG4gICAgZXJyb3IwMDI6ICgpID0+IFwiSXQgbG9va3MgbGlrZSB5b3UndmUgY3JlYXRlZCBhIG5ldyBub2RlVHlwZXMgb3IgZWRnZVR5cGVzIG9iamVjdC4gSWYgdGhpcyB3YXNuJ3Qgb24gcHVycG9zZSBwbGVhc2UgZGVmaW5lIHRoZSBub2RlVHlwZXMvZWRnZVR5cGVzIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudCBvciBtZW1vaXplIHRoZW0uXCIsXG4gICAgZXJyb3IwMDM6IChub2RlVHlwZSkgPT4gYE5vZGUgdHlwZSBcIiR7bm9kZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMDQ6ICgpID0+ICdUaGUgUmVhY3QgRmxvdyBwYXJlbnQgY29udGFpbmVyIG5lZWRzIGEgd2lkdGggYW5kIGEgaGVpZ2h0IHRvIHJlbmRlciB0aGUgZ3JhcGguJyxcbiAgICBlcnJvcjAwNTogKCkgPT4gJ09ubHkgY2hpbGQgbm9kZXMgY2FuIHVzZSBhIHBhcmVudCBleHRlbnQuJyxcbiAgICBlcnJvcjAwNjogKCkgPT4gXCJDYW4ndCBjcmVhdGUgZWRnZS4gQW4gZWRnZSBuZWVkcyBhIHNvdXJjZSBhbmQgYSB0YXJnZXQuXCIsXG4gICAgZXJyb3IwMDc6IChpZCkgPT4gYFRoZSBvbGQgZWRnZSB3aXRoIGlkPSR7aWR9IGRvZXMgbm90IGV4aXN0LmAsXG4gICAgZXJyb3IwMDk6ICh0eXBlKSA9PiBgTWFya2VyIHR5cGUgXCIke3R5cGV9XCIgZG9lc24ndCBleGlzdC5gLFxuICAgIGVycm9yMDA4OiAoaGFuZGxlVHlwZSwgeyBpZCwgc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGUgfSkgPT4gYENvdWxkbid0IGNyZWF0ZSBlZGdlIGZvciAke2hhbmRsZVR5cGV9IGhhbmRsZSBpZDogXCIke2hhbmRsZVR5cGUgPT09ICdzb3VyY2UnID8gc291cmNlSGFuZGxlIDogdGFyZ2V0SGFuZGxlfVwiLCBlZGdlIGlkOiAke2lkfS5gLFxuICAgIGVycm9yMDEwOiAoKSA9PiAnSGFuZGxlOiBObyBub2RlIGlkIGZvdW5kLiBNYWtlIHN1cmUgdG8gb25seSB1c2UgYSBIYW5kbGUgaW5zaWRlIGEgY3VzdG9tIE5vZGUuJyxcbiAgICBlcnJvcjAxMTogKGVkZ2VUeXBlKSA9PiBgRWRnZSB0eXBlIFwiJHtlZGdlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAxMjogKGlkKSA9PiBgTm9kZSB3aXRoIGlkIFwiJHtpZH1cIiBkb2VzIG5vdCBleGlzdCwgaXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIG5vZGUgaXMgZGVsZXRlZCBiZWZvcmUgdGhlIFwib25Ob2RlQ2xpY2tcIiBoYW5kbGVyIGlzIGNhbGxlZC5gLFxuICAgIGVycm9yMDEzOiAobGliID0gJ3JlYWN0JykgPT4gYEl0IHNlZW1zIHRoYXQgeW91IGhhdmVuJ3QgbG9hZGVkIHRoZSBzdHlsZXMuIFBsZWFzZSBpbXBvcnQgJ0B4eWZsb3cvJHtsaWJ9L2Rpc3Qvc3R5bGUuY3NzJyBvciBiYXNlLmNzcyB0byBtYWtlIHN1cmUgZXZlcnl0aGluZyBpcyB3b3JraW5nIHByb3Blcmx5LmAsXG4gICAgZXJyb3IwMTQ6ICgpID0+ICd1c2VOb2RlQ29ubmVjdGlvbnM6IE5vIG5vZGUgSUQgZm91bmQuIENhbGwgdXNlTm9kZUNvbm5lY3Rpb25zIGluc2lkZSBhIGN1c3RvbSBOb2RlIG9yIHByb3ZpZGUgYSBub2RlIElELicsXG4gICAgZXJyb3IwMTU6ICgpID0+ICdJdCBzZWVtcyB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGRyYWcgYSBub2RlIHRoYXQgaXMgbm90IGluaXRpYWxpemVkLiBQbGVhc2UgdXNlIG9uTm9kZXNDaGFuZ2UgYXMgZXhwbGFpbmVkIGluIHRoZSBkb2NzLicsXG59O1xuY29uc3QgaW5maW5pdGVFeHRlbnQgPSBbXG4gICAgW051bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXSxcbiAgICBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLFxuXTtcbmNvbnN0IGVsZW1lbnRTZWxlY3Rpb25LZXlzID0gWydFbnRlcicsICcgJywgJ0VzY2FwZSddO1xuY29uc3QgZGVmYXVsdEFyaWFMYWJlbENvbmZpZyA9IHtcbiAgICAnbm9kZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCc6ICdQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLiBQcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IGFuZCBlc2NhcGUgdG8gY2FuY2VsLicsXG4gICAgJ25vZGUuYTExeURlc2NyaXB0aW9uLmtleWJvYXJkRGlzYWJsZWQnOiAnUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGEgbm9kZS4gWW91IGNhbiB0aGVuIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBub2RlIGFyb3VuZC4gUHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBhbmQgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgICdub2RlLmExMXlEZXNjcmlwdGlvbi5hcmlhTGl2ZU1lc3NhZ2UnOiAoeyBkaXJlY3Rpb24sIHgsIHkgfSkgPT4gYE1vdmVkIHNlbGVjdGVkIG5vZGUgJHtkaXJlY3Rpb259LiBOZXcgcG9zaXRpb24sIHg6ICR7eH0sIHk6ICR7eX1gLFxuICAgICdlZGdlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0JzogJ1ByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhbiBlZGdlLiBZb3UgY2FuIHRoZW4gcHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBvciBlc2NhcGUgdG8gY2FuY2VsLicsXG4gICAgLy8gQ29udHJvbCBlbGVtZW50c1xuICAgICdjb250cm9scy5hcmlhTGFiZWwnOiAnQ29udHJvbCBQYW5lbCcsXG4gICAgJ2NvbnRyb2xzLnpvb21Jbi5hcmlhTGFiZWwnOiAnWm9vbSBJbicsXG4gICAgJ2NvbnRyb2xzLnpvb21PdXQuYXJpYUxhYmVsJzogJ1pvb20gT3V0JyxcbiAgICAnY29udHJvbHMuZml0Vmlldy5hcmlhTGFiZWwnOiAnRml0IFZpZXcnLFxuICAgICdjb250cm9scy5pbnRlcmFjdGl2ZS5hcmlhTGFiZWwnOiAnVG9nZ2xlIEludGVyYWN0aXZpdHknLFxuICAgIC8vIE1pbmkgbWFwXG4gICAgJ21pbmltYXAuYXJpYUxhYmVsJzogJ01pbmkgTWFwJyxcbiAgICAvLyBIYW5kbGVcbiAgICAnaGFuZGxlLmFyaWFMYWJlbCc6ICdIYW5kbGUnLFxufTtcblxuLyoqXG4gKiBUaGUgYENvbm5lY3Rpb25Nb2RlYCBpcyB1c2VkIHRvIHNldCB0aGUgbW9kZSBvZiBjb25uZWN0aW9uIGJldHdlZW4gbm9kZXMuXG4gKiBUaGUgYFN0cmljdGAgbW9kZSBpcyB0aGUgZGVmYXVsdCBvbmUgYW5kIG9ubHkgYWxsb3dzIHNvdXJjZSB0byB0YXJnZXQgZWRnZXMuXG4gKiBgTG9vc2VgIG1vZGUgYWxsb3dzIHNvdXJjZSB0byBzb3VyY2UgYW5kIHRhcmdldCB0byB0YXJnZXQgZWRnZXMgYXMgd2VsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBDb25uZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk1vZGUpIHtcbiAgICBDb25uZWN0aW9uTW9kZVtcIlN0cmljdFwiXSA9IFwic3RyaWN0XCI7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJMb29zZVwiXSA9IFwibG9vc2VcIjtcbn0pKENvbm5lY3Rpb25Nb2RlIHx8IChDb25uZWN0aW9uTW9kZSA9IHt9KSk7XG4vKipcbiAqIFRoaXMgZW51bSBpcyB1c2VkIHRvIHNldCB0aGUgZGlmZmVyZW50IG1vZGVzIG9mIHBhbm5pbmcgdGhlIHZpZXdwb3J0IHdoZW4gdGhlXG4gKiB1c2VyIHNjcm9sbHMuIFRoZSBgRnJlZWAgbW9kZSBhbGxvd3MgdGhlIHVzZXIgdG8gcGFuIGluIGFueSBkaXJlY3Rpb24gYnkgc2Nyb2xsaW5nXG4gKiB3aXRoIGEgZGV2aWNlIGxpa2UgYSB0cmFja3BhZC4gVGhlIGBWZXJ0aWNhbGAgYW5kIGBIb3Jpem9udGFsYCBtb2RlcyByZXN0cmljdFxuICogc2Nyb2xsIHBhbm5pbmcgdG8gb25seSB0aGUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBheGlzLCByZXNwZWN0aXZlbHkuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUGFuT25TY3JvbGxNb2RlO1xuKGZ1bmN0aW9uIChQYW5PblNjcm9sbE1vZGUpIHtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJGcmVlXCJdID0gXCJmcmVlXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiSG9yaXpvbnRhbFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoUGFuT25TY3JvbGxNb2RlIHx8IChQYW5PblNjcm9sbE1vZGUgPSB7fSkpO1xudmFyIFNlbGVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKFNlbGVjdGlvbk1vZGUpIHtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiUGFydGlhbFwiXSA9IFwicGFydGlhbFwiO1xuICAgIFNlbGVjdGlvbk1vZGVbXCJGdWxsXCJdID0gXCJmdWxsXCI7XG59KShTZWxlY3Rpb25Nb2RlIHx8IChTZWxlY3Rpb25Nb2RlID0ge30pKTtcbmNvbnN0IGluaXRpYWxDb25uZWN0aW9uID0ge1xuICAgIGluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IG51bGwsXG4gICAgZnJvbTogbnVsbCxcbiAgICBmcm9tSGFuZGxlOiBudWxsLFxuICAgIGZyb21Qb3NpdGlvbjogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0bzogbnVsbCxcbiAgICB0b0hhbmRsZTogbnVsbCxcbiAgICB0b1Bvc2l0aW9uOiBudWxsLFxuICAgIHRvTm9kZTogbnVsbCxcbn07XG5cbi8qKlxuICogSWYgeW91IHNldCB0aGUgYGNvbm5lY3Rpb25MaW5lVHlwZWAgcHJvcCBvbiB5b3VyIFtgPFJlYWN0RmxvdyAvPmBdKC9hcGktcmVmZXJlbmNlL3JlYWN0LWZsb3cjY29ubmVjdGlvbi1jb25uZWN0aW9uTGluZVR5cGUpXG4gKmNvbXBvbmVudCwgaXQgd2lsbCBkaWN0YXRlIHRoZSBzdHlsZSBvZiBjb25uZWN0aW9uIGxpbmUgcmVuZGVyZWQgd2hlbiBjcmVhdGluZ1xuICpuZXcgZWRnZXMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEByZW1hcmtzIElmIHlvdSBjaG9vc2UgdG8gcmVuZGVyIGEgY3VzdG9tIGNvbm5lY3Rpb24gbGluZSBjb21wb25lbnQsIHRoaXMgdmFsdWUgd2lsbCBiZVxuICpwYXNzZWQgdG8geW91ciBjb21wb25lbnQgYXMgcGFydCBvZiBpdHMgW2BDb25uZWN0aW9uTGluZUNvbXBvbmVudFByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvY29ubmVjdGlvbi1saW5lLWNvbXBvbmVudC1wcm9wcykuXG4gKi9cbnZhciBDb25uZWN0aW9uTGluZVR5cGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25MaW5lVHlwZSkge1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIkJlemllclwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0cmFpZ2h0XCJdID0gXCJzdHJhaWdodFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0ZXBcIl0gPSBcInN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTbW9vdGhTdGVwXCJdID0gXCJzbW9vdGhzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU2ltcGxlQmV6aWVyXCJdID0gXCJzaW1wbGViZXppZXJcIjtcbn0pKENvbm5lY3Rpb25MaW5lVHlwZSB8fCAoQ29ubmVjdGlvbkxpbmVUeXBlID0ge30pKTtcbi8qKlxuICogRWRnZXMgbWF5IG9wdGlvbmFsbHkgaGF2ZSBhIG1hcmtlciBvbiBlaXRoZXIgZW5kLiBUaGUgTWFya2VyVHlwZSB0eXBlIGVudW1lcmF0ZXNcbiAqIHRoZSBvcHRpb25zIGF2YWlsYWJsZSB0byB5b3Ugd2hlbiBjb25maWd1cmluZyBhIGdpdmVuIG1hcmtlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNYXJrZXJUeXBlO1xuKGZ1bmN0aW9uIChNYXJrZXJUeXBlKSB7XG4gICAgTWFya2VyVHlwZVtcIkFycm93XCJdID0gXCJhcnJvd1wiO1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd0Nsb3NlZFwiXSA9IFwiYXJyb3djbG9zZWRcIjtcbn0pKE1hcmtlclR5cGUgfHwgKE1hcmtlclR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIFdoaWxlIFtgUGFuZWxQb3NpdGlvbmBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL3BhbmVsLXBvc2l0aW9uKSBjYW4gYmUgdXNlZCB0byBwbGFjZSBhXG4gKiBjb21wb25lbnQgaW4gdGhlIGNvcm5lcnMgb2YgYSBjb250YWluZXIsIHRoZSBgUG9zaXRpb25gIGVudW0gaXMgbGVzcyBwcmVjaXNlIGFuZCB1c2VkXG4gKiBwcmltYXJpbHkgaW4gcmVsYXRpb24gdG8gZWRnZXMgYW5kIGhhbmRsZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgUG9zaXRpb25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgUG9zaXRpb25bXCJUb3BcIl0gPSBcInRvcFwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgUG9zaXRpb25bXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbmNvbnN0IG9wcG9zaXRlUG9zaXRpb24gPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiBQb3NpdGlvbi5SaWdodCxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiBQb3NpdGlvbi5MZWZ0LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiBQb3NpdGlvbi5Cb3R0b20sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IFBvc2l0aW9uLlRvcCxcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwoYSwgYikge1xuICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhIHx8ICFiIHx8IGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhLnNpemUgJiYgIWIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdlIGNhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgY29ubmVjdGlvbnMgaW4gYSB0aGF0IGFyZSBub3QgaW4gYlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKGEsIGIsIGNiKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBbXTtcbiAgICBhLmZvckVhY2goKGNvbm5lY3Rpb24sIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWI/LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBkaWZmLnB1c2goY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlmZi5sZW5ndGgpIHtcbiAgICAgICAgY2IoZGlmZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQgPT09IG51bGwgPyBudWxsIDogaXNWYWxpZCA/ICd2YWxpZCcgOiAnaW52YWxpZCc7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gRWRnZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gRWRnZVxuICovXG5jb25zdCBpc0VkZ2VCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAnc291cmNlJyBpbiBlbGVtZW50ICYmICd0YXJnZXQnIGluIGVsZW1lbnQ7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGEgTm9kZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIE5vZGUgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gTm9kZVxuICovXG5jb25zdCBpc05vZGVCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAncG9zaXRpb24nIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuY29uc3QgaXNJbnRlcm5hbE5vZGVCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAnaW50ZXJuYWxzJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gdGVsbCB5b3Ugd2hhdCBub2RlcywgaWYgYW55LCBhcmUgY29ubmVjdGVkIHRvIHRoZSBnaXZlbiBub2RlXG4gKiBhcyB0aGUgX3RhcmdldF8gb2YgYW4gZWRnZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgbm9kZXMgZnJvbS5cbiAqIEBwYXJhbSBub2RlcyAtIFRoZSBhcnJheSBvZiBhbGwgbm9kZXMuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBhcmUgY29ubmVjdGVkIG92ZXIgZWRnZXMgd2hlcmUgdGhlIHNvdXJjZSBpcyB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqaW1wb3J0IHsgZ2V0T3V0Z29lcnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW107XG4gKmNvbnN0IGVkZ2VzID0gW107XG4gKlxuICpjb25zdCBvdXRnb2VycyA9IGdldE91dGdvZXJzKFxuICogIHsgaWQ6ICcxJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCBkYXRhOiB7IGxhYmVsOiAnbm9kZScgfSB9LFxuICogIG5vZGVzLFxuICogIGVkZ2VzLFxuICopO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0T3V0Z29lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgb3V0Z29lcklkcyA9IG5ldyBTZXQoKTtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIGlmIChlZGdlLnNvdXJjZSA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgb3V0Z29lcklkcy5hZGQoZWRnZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gb3V0Z29lcklkcy5oYXMobi5pZCkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gdGVsbCB5b3Ugd2hhdCBub2RlcywgaWYgYW55LCBhcmUgY29ubmVjdGVkIHRvIHRoZSBnaXZlbiBub2RlXG4gKiBhcyB0aGUgX3NvdXJjZV8gb2YgYW4gZWRnZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgbm9kZXMgZnJvbS5cbiAqIEBwYXJhbSBub2RlcyAtIFRoZSBhcnJheSBvZiBhbGwgbm9kZXMuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBhcmUgY29ubmVjdGVkIG92ZXIgZWRnZXMgd2hlcmUgdGhlIHRhcmdldCBpcyB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqaW1wb3J0IHsgZ2V0SW5jb21lcnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW107XG4gKmNvbnN0IGVkZ2VzID0gW107XG4gKlxuICpjb25zdCBpbmNvbWVycyA9IGdldEluY29tZXJzKFxuICogIHsgaWQ6ICcxJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCBkYXRhOiB7IGxhYmVsOiAnbm9kZScgfSB9LFxuICogIG5vZGVzLFxuICogIGVkZ2VzLFxuICopO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0SW5jb21lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgaW5jb21lcnNJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS50YXJnZXQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIGluY29tZXJzSWRzLmFkZChlZGdlLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChuKSA9PiBpbmNvbWVyc0lkcy5oYXMobi5pZCkpO1xufTtcbmNvbnN0IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4gPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICBjb25zdCBvZmZzZXRYID0gd2lkdGggKiBvcmlnaW5bMF07XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGhlaWdodCAqIG9yaWdpblsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBub2RlLnBvc2l0aW9uLnggLSBvZmZzZXRYLFxuICAgICAgICB5OiBub2RlLnBvc2l0aW9uLnkgLSBvZmZzZXRZLFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgdGhlIGdpdmVuIG5vZGVzIGluIGFuIGFycmF5LiBUaGlzIGNhblxuICogYmUgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBbYGdldFZpZXdwb3J0Rm9yQm91bmRzYF0oL2FwaS1yZWZlcmVuY2UvdXRpbHMvZ2V0LXZpZXdwb3J0LWZvci1ib3VuZHMpXG4gKiB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZXMgaW4gYSB2aWV3cG9ydC5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGgge0BsaW5rIGdldFZpZXdwb3J0Rm9yQm91bmRzfSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZXMgaW4gYSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBub2RlcyAtIE5vZGVzIHRvIGNhbGN1bGF0ZSB0aGUgYm91bmRzIGZvci5cbiAqIEByZXR1cm5zIEJvdW5kaW5nIGJveCBlbmNsb3NpbmcgYWxsIG5vZGVzLlxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkIGBnZXRSZWN0T2ZOb2Rlc2BcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgZ2V0Tm9kZXNCb3VuZHMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW1xuICogIHtcbiAqICAgIGlkOiAnYScsXG4gKiAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYScgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqICB7XG4gKiAgICBpZDogJ2InLFxuICogICAgcG9zaXRpb246IHsgeDogMTAwLCB5OiAxMDAgfSxcbiAqICAgIGRhdGE6IHsgbGFiZWw6ICdiJyB9LFxuICogICAgd2lkdGg6IDUwLFxuICogICAgaGVpZ2h0OiAyNSxcbiAqICB9LFxuICpdO1xuICpcbiAqY29uc3QgYm91bmRzID0gZ2V0Tm9kZXNCb3VuZHMobm9kZXMpO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0Tm9kZXNCb3VuZHMgPSAobm9kZXMsIHBhcmFtcyA9IHsgbm9kZU9yaWdpbjogWzAsIDBdIH0pID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIXBhcmFtcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIHVzZSBgZ2V0Tm9kZXNCb3VuZHNgIGZyb20gYHVzZVJlYWN0Rmxvd2AvYHVzZVN2ZWx0ZUZsb3dgIGhvb2sgdG8gZW5zdXJlIGNvcnJlY3QgdmFsdWVzIGZvciBzdWIgZmxvd3MuIElmIG5vdCBwb3NzaWJsZSwgeW91IGhhdmUgdG8gcHJvdmlkZSBhIG5vZGVMb29rdXAgdG8gc3VwcG9ydCBzdWIgZmxvd3MuJyk7XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbiAgICBjb25zdCBib3ggPSBub2Rlcy5yZWR1Y2UoKGN1cnJCb3gsIG5vZGVPcklkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzSWQgPSB0eXBlb2Ygbm9kZU9ySWQgPT09ICdzdHJpbmcnO1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSAhcGFyYW1zLm5vZGVMb29rdXAgJiYgIWlzSWQgPyBub2RlT3JJZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGlzSWRcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZClcbiAgICAgICAgICAgICAgICA6ICFpc0ludGVybmFsTm9kZUJhc2Uobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zLm5vZGVMb29rdXAuZ2V0KG5vZGVPcklkLmlkKVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVPcklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVCb3ggPSBjdXJyZW50Tm9kZSA/IG5vZGVUb0JveChjdXJyZW50Tm9kZSwgcGFyYW1zLm5vZGVPcmlnaW4pIDogeyB4OiAwLCB5OiAwLCB4MjogMCwgeTI6IDAgfTtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kc09mQm94ZXMoY3VyckJveCwgbm9kZUJveCk7XG4gICAgfSwgeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfSk7XG4gICAgcmV0dXJuIGJveFRvUmVjdChib3gpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBhIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGFsbCBnaXZlbiBub2RlcyBpbiBhbiBhcnJheVxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGdldEludGVybmFsTm9kZXNCb3VuZHMgPSAobm9kZUxvb2t1cCwgcGFyYW1zID0ge30pID0+IHtcbiAgICBpZiAobm9kZUxvb2t1cC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgbGV0IGJveCA9IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbXMuZmlsdGVyID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmZpbHRlcihub2RlKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUJveCA9IG5vZGVUb0JveChub2RlKTtcbiAgICAgICAgICAgIGJveCA9IGdldEJvdW5kc09mQm94ZXMoYm94LCBub2RlQm94KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG5jb25zdCBnZXROb2Rlc0luc2lkZSA9IChub2RlcywgcmVjdCwgW3R4LCB0eSwgdFNjYWxlXSA9IFswLCAwLCAxXSwgcGFydGlhbGx5ID0gZmFsc2UsIFxuLy8gc2V0IGV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgaWYgeW91IHdhbnQgdG8gcGF5IGF0dGVudGlvbiB0byB0aGUgbm9kZXMgXCJzZWxlY3RhYmxlXCIgYXR0cmlidXRlXG5leGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBwYW5lUmVjdCA9IHtcbiAgICAgICAgLi4ucG9pbnRUb1JlbmRlcmVyUG9pbnQocmVjdCwgW3R4LCB0eSwgdFNjYWxlXSksXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gdFNjYWxlLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gdFNjYWxlLFxuICAgIH07XG4gICAgY29uc3QgdmlzaWJsZU5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVhc3VyZWQsIHNlbGVjdGFibGUgPSB0cnVlLCBoaWRkZW4gPSBmYWxzZSB9ID0gbm9kZTtcbiAgICAgICAgaWYgKChleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzICYmICFzZWxlY3RhYmxlKSB8fCBoaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbWVhc3VyZWQud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBudWxsO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG51bGw7XG4gICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShwYW5lUmVjdCwgbm9kZVRvUmVjdChub2RlKSk7XG4gICAgICAgIGNvbnN0IGFyZWEgPSAod2lkdGggPz8gMCkgKiAoaGVpZ2h0ID8/IDApO1xuICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgIGNvbnN0IGZvcmNlSW5pdGlhbFJlbmRlciA9ICFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGZvcmNlSW5pdGlhbFJlbmRlciB8fCBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhO1xuICAgICAgICBpZiAoaXNWaXNpYmxlIHx8IG5vZGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZpc2libGVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlTm9kZXM7XG59O1xuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZmlsdGVycyBhbiBhcnJheSBvZiBlZGdlcywga2VlcGluZyBvbmx5IHRob3NlIHdoZXJlIGVpdGhlciB0aGUgc291cmNlIG9yIHRhcmdldFxuICogbm9kZSBpcyBwcmVzZW50IGluIHRoZSBnaXZlbiBhcnJheSBvZiBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlcyAtIE5vZGVzIHlvdSB3YW50IHRvIGdldCB0aGUgY29ubmVjdGVkIGVkZ2VzIGZvci5cbiAqIEBwYXJhbSBlZGdlcyAtIEFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFycmF5IG9mIGVkZ2VzIHRoYXQgY29ubmVjdCBhbnkgb2YgdGhlIGdpdmVuIG5vZGVzIHdpdGggZWFjaCBvdGhlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgZ2V0Q29ubmVjdGVkRWRnZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW1xuICogIHsgaWQ6ICdhJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9IH0sXG4gKiAgeyBpZDogJ2InLCBwb3NpdGlvbjogeyB4OiAxMDAsIHk6IDAgfSB9LFxuICpdO1xuICpcbiAqY29uc3QgZWRnZXMgPSBbXG4gKiAgeyBpZDogJ2EtPmMnLCBzb3VyY2U6ICdhJywgdGFyZ2V0OiAnYycgfSxcbiAqICB7IGlkOiAnYy0+ZCcsIHNvdXJjZTogJ2MnLCB0YXJnZXQ6ICdkJyB9LFxuICpdO1xuICpcbiAqY29uc3QgY29ubmVjdGVkRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlcyhub2RlcywgZWRnZXMpO1xuICogLy8gPT4gW3sgaWQ6ICdhLT5jJywgc291cmNlOiAnYScsIHRhcmdldDogJ2MnIH1dXG4gKmBgYFxuICovXG5jb25zdCBnZXRDb25uZWN0ZWRFZGdlcyA9IChub2RlcywgZWRnZXMpID0+IHtcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldCgpO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZUlkcy5hZGQobm9kZS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gbm9kZUlkcy5oYXMoZWRnZS5zb3VyY2UpIHx8IG5vZGVJZHMuaGFzKGVkZ2UudGFyZ2V0KSk7XG59O1xuZnVuY3Rpb24gZ2V0Rml0Vmlld05vZGVzKG5vZGVMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaXRWaWV3Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb3B0aW9uTm9kZUlkcyA9IG9wdGlvbnM/Lm5vZGVzID8gbmV3IFNldChvcHRpb25zLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpIDogbnVsbDtcbiAgICBub2RlTG9va3VwLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gbi5tZWFzdXJlZC53aWR0aCAmJiBuLm1lYXN1cmVkLmhlaWdodCAmJiAob3B0aW9ucz8uaW5jbHVkZUhpZGRlbk5vZGVzIHx8ICFuLmhpZGRlbik7XG4gICAgICAgIGlmIChpc1Zpc2libGUgJiYgKCFvcHRpb25Ob2RlSWRzIHx8IG9wdGlvbk5vZGVJZHMuaGFzKG4uaWQpKSkge1xuICAgICAgICAgICAgZml0Vmlld05vZGVzLnNldChuLmlkLCBuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaXRWaWV3Tm9kZXM7XG59XG5hc3luYyBmdW5jdGlvbiBmaXRWaWV3cG9ydCh7IG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCBwYW5ab29tLCBtaW5ab29tLCBtYXhab29tIH0sIG9wdGlvbnMpIHtcbiAgICBpZiAobm9kZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBub2Rlc1RvRml0ID0gZ2V0Rml0Vmlld05vZGVzKG5vZGVzLCBvcHRpb25zKTtcbiAgICBjb25zdCBib3VuZHMgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVzVG9GaXQpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zPy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnM/Lm1heFpvb20gPz8gbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQodmlld3BvcnQsIHtcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiBvcHRpb25zPy5lYXNlLFxuICAgICAgICBpbnRlcnBvbGF0ZTogb3B0aW9ucz8uaW50ZXJwb2xhdGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBuZXh0IHBvc2l0aW9uIG9mIGEgbm9kZSwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgbm9kZSdzIGV4dGVudCwgcGFyZW50IG5vZGUsIGFuZCBvcmlnaW4uXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVOb2RlUG9zaXRpb24oeyBub2RlSWQsIG5leHRQb3NpdGlvbiwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiA9IFswLCAwXSwgbm9kZUV4dGVudCwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudElkID8gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA6IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgbGV0IGV4dGVudCA9IG5vZGUuZXh0ZW50IHx8IG5vZGVFeHRlbnQ7XG4gICAgaWYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyAmJiAhbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBvbkVycm9yPy4oJzAwNScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA1J10oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHBhcmVudE5vZGUubWVhc3VyZWQud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRIZWlnaHQgPSBwYXJlbnROb2RlLm1lYXN1cmVkLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChwYXJlbnRXaWR0aCAmJiBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYLCBwYXJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW3BhcmVudFggKyBwYXJlbnRXaWR0aCwgcGFyZW50WSArIHBhcmVudEhlaWdodF0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnROb2RlICYmIGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkpIHtcbiAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgW25vZGUuZXh0ZW50WzBdWzBdICsgcGFyZW50WCwgbm9kZS5leHRlbnRbMF1bMV0gKyBwYXJlbnRZXSxcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFsxXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzFdWzFdICsgcGFyZW50WV0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSBpc0Nvb3JkaW5hdGVFeHRlbnQoZXh0ZW50KVxuICAgICAgICA/IGNsYW1wUG9zaXRpb24obmV4dFBvc2l0aW9uLCBleHRlbnQsIG5vZGUubWVhc3VyZWQpXG4gICAgICAgIDogbmV4dFBvc2l0aW9uO1xuICAgIGlmIChub2RlLm1lYXN1cmVkLndpZHRoID09PSB1bmRlZmluZWQgfHwgbm9kZS5tZWFzdXJlZC5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAxNScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDE1J10oKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NpdGlvbkFic29sdXRlLnggLSBwYXJlbnRYICsgKG5vZGUubWVhc3VyZWQud2lkdGggPz8gMCkgKiBvcmlnaW5bMF0sXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnkgLSBwYXJlbnRZICsgKG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdLFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgIH07XG59XG4vKipcbiAqIFBhc3MgaW4gbm9kZXMgJiBlZGdlcyB0byBkZWxldGUsIGdldCBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzIHRoYXQgYWN0dWFsbHkgY2FuIGJlIGRlbGV0ZWRcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhcmFtLm5vZGVzVG9SZW1vdmUgLSBUaGUgbm9kZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0uZWRnZXNUb1JlbW92ZSAtIFRoZSBlZGdlcyB0byByZW1vdmVcbiAqIEBwYXJhbSBwYXJhbS5ub2RlcyAtIEFsbCBub2Rlc1xuICogQHBhcmFtIHBhcmFtLmVkZ2VzIC0gQWxsIGVkZ2VzXG4gKiBAcGFyYW0gcGFyYW0ub25CZWZvcmVEZWxldGUgLSBDYWxsYmFjayB0byBjaGVjayB3aGljaCBub2RlcyBhbmQgZWRnZXMgY2FuIGJlIGRlbGV0ZWRcbiAqIEByZXR1cm5zIG5vZGVzOiBub2RlcyB0aGF0IGNhbiBiZSBkZWxldGVkLCBlZGdlczogZWRnZXMgdGhhdCBjYW4gYmUgZGVsZXRlZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRFbGVtZW50c1RvUmVtb3ZlKHsgbm9kZXNUb1JlbW92ZSA9IFtdLCBlZGdlc1RvUmVtb3ZlID0gW10sIG5vZGVzLCBlZGdlcywgb25CZWZvcmVEZWxldGUsIH0pIHtcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldChub2Rlc1RvUmVtb3ZlLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICAgIGNvbnN0IG1hdGNoaW5nTm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUuZGVsZXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IG5vZGVJZHMuaGFzKG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBwYXJlbnRIaXQgPSAhaXNJbmNsdWRlZCAmJiBub2RlLnBhcmVudElkICYmIG1hdGNoaW5nTm9kZXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZS5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChpc0luY2x1ZGVkIHx8IHBhcmVudEhpdCkge1xuICAgICAgICAgICAgbWF0Y2hpbmdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VJZHMgPSBuZXcgU2V0KGVkZ2VzVG9SZW1vdmUubWFwKChlZGdlKSA9PiBlZGdlLmlkKSk7XG4gICAgY29uc3QgZGVsZXRhYmxlRWRnZXMgPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UuZGVsZXRhYmxlICE9PSBmYWxzZSk7XG4gICAgY29uc3QgY29ubmVjdGVkRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlcyhtYXRjaGluZ05vZGVzLCBkZWxldGFibGVFZGdlcyk7XG4gICAgY29uc3QgbWF0Y2hpbmdFZGdlcyA9IGNvbm5lY3RlZEVkZ2VzO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBkZWxldGFibGVFZGdlcykge1xuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gZWRnZUlkcy5oYXMoZWRnZS5pZCk7XG4gICAgICAgIGlmIChpc0luY2x1ZGVkICYmICFtYXRjaGluZ0VkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGVkZ2UuaWQpKSB7XG4gICAgICAgICAgICBtYXRjaGluZ0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvbkJlZm9yZURlbGV0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb25CZWZvcmVEZWxldGVSZXN1bHQgPSBhd2FpdCBvbkJlZm9yZURlbGV0ZSh7XG4gICAgICAgIG5vZGVzOiBtYXRjaGluZ05vZGVzLFxuICAgICAgICBlZGdlczogbWF0Y2hpbmdFZGdlcyxcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9uQmVmb3JlRGVsZXRlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlRGVsZXRlUmVzdWx0ID8geyBlZGdlczogbWF0Y2hpbmdFZGdlcywgbm9kZXM6IG1hdGNoaW5nTm9kZXMgfSA6IHsgZWRnZXM6IFtdLCBub2RlczogW10gfTtcbiAgICB9XG4gICAgcmV0dXJuIG9uQmVmb3JlRGVsZXRlUmVzdWx0O1xufVxuXG5jb25zdCBjbGFtcCA9ICh2YWwsIG1pbiA9IDAsIG1heCA9IDEpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbmNvbnN0IGNsYW1wUG9zaXRpb24gPSAocG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSwgZXh0ZW50LCBkaW1lbnNpb25zKSA9PiAoe1xuICAgIHg6IGNsYW1wKHBvc2l0aW9uLngsIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzBdIC0gKGRpbWVuc2lvbnM/LndpZHRoID8/IDApKSxcbiAgICB5OiBjbGFtcChwb3NpdGlvbi55LCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVsxXSAtIChkaW1lbnNpb25zPy5oZWlnaHQgPz8gMCkpLFxufSk7XG5mdW5jdGlvbiBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoY2hpbGRQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7IHdpZHRoOiBwYXJlbnRXaWR0aCwgaGVpZ2h0OiBwYXJlbnRIZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKHBhcmVudCk7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgcmV0dXJuIGNsYW1wUG9zaXRpb24oY2hpbGRQb3NpdGlvbiwgW1xuICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgIF0sIGNoaWxkRGltZW5zaW9ucyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmcgd2hlbiB0aGUgbW91c2UgaXMgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhc1xuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmFsdWUgLSBPbmUgZGltZW5zaW9uYWwgcG9pdGlvbiBvZiB0aGUgbW91c2UgKHggb3IgeSlcbiAqIEBwYXJhbSBtaW4gLSBNaW5pbWFsIHBvc2l0aW9uIG9uIGNhbnZhcyBiZWZvcmUgcGFubmluZyBzdGFydHNcbiAqIEBwYXJhbSBtYXggLSBNYXhpbWFsIHBvc2l0aW9uIG9uIGNhbnZhcyBiZWZvcmUgcGFubmluZyBzdGFydHNcbiAqIEByZXR1cm5zIC0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVsb2NpdHkgb2YgcGFubmluZ1xuICovXG5jb25zdCBjYWxjQXV0b1BhblZlbG9jaXR5ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtaW4pLCAxLCBtaW4pIC8gbWluO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gLWNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWF4KSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgY2FsY0F1dG9QYW4gPSAocG9zLCBib3VuZHMsIHNwZWVkID0gMTUsIGRpc3RhbmNlID0gNDApID0+IHtcbiAgICBjb25zdCB4TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy54LCBkaXN0YW5jZSwgYm91bmRzLndpZHRoIC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgY29uc3QgeU1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueSwgZGlzdGFuY2UsIGJvdW5kcy5oZWlnaHQgLSBkaXN0YW5jZSkgKiBzcGVlZDtcbiAgICByZXR1cm4gW3hNb3ZlbWVudCwgeU1vdmVtZW50XTtcbn07XG5jb25zdCBnZXRCb3VuZHNPZkJveGVzID0gKGJveDEsIGJveDIpID0+ICh7XG4gICAgeDogTWF0aC5taW4oYm94MS54LCBib3gyLngpLFxuICAgIHk6IE1hdGgubWluKGJveDEueSwgYm94Mi55KSxcbiAgICB4MjogTWF0aC5tYXgoYm94MS54MiwgYm94Mi54MiksXG4gICAgeTI6IE1hdGgubWF4KGJveDEueTIsIGJveDIueTIpLFxufSk7XG5jb25zdCByZWN0VG9Cb3ggPSAoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG59KTtcbmNvbnN0IGJveFRvUmVjdCA9ICh7IHgsIHksIHgyLCB5MiB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogeDIgLSB4LFxuICAgIGhlaWdodDogeTIgLSB5LFxufSk7XG5jb25zdCBub2RlVG9SZWN0ID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGlzSW50ZXJuYWxOb2RlQmFzZShub2RlKVxuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgOiBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwLFxuICAgIH07XG59O1xuY29uc3Qgbm9kZVRvQm94ID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGlzSW50ZXJuYWxOb2RlQmFzZShub2RlKVxuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgOiBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHgyOiB4ICsgKG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCksXG4gICAgICAgIHkyOiB5ICsgKG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCksXG4gICAgfTtcbn07XG5jb25zdCBnZXRCb3VuZHNPZlJlY3RzID0gKHJlY3QxLCByZWN0MikgPT4gYm94VG9SZWN0KGdldEJvdW5kc09mQm94ZXMocmVjdFRvQm94KHJlY3QxKSwgcmVjdFRvQm94KHJlY3QyKSkpO1xuY29uc3QgZ2V0T3ZlcmxhcHBpbmdBcmVhID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIGNvbnN0IHhPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdEEueCArIHJlY3RBLndpZHRoLCByZWN0Qi54ICsgcmVjdEIud2lkdGgpIC0gTWF0aC5tYXgocmVjdEEueCwgcmVjdEIueCkpO1xuICAgIGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdEEueSArIHJlY3RBLmhlaWdodCwgcmVjdEIueSArIHJlY3RCLmhlaWdodCkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KSk7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh4T3ZlcmxhcCAqIHlPdmVybGFwKTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgaXNSZWN0T2JqZWN0ID0gKG9iaikgPT4gaXNOdW1lcmljKG9iai53aWR0aCkgJiYgaXNOdW1lcmljKG9iai5oZWlnaHQpICYmIGlzTnVtZXJpYyhvYmoueCkgJiYgaXNOdW1lcmljKG9iai55KTtcbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBpc051bWVyaWMgPSAobikgPT4gIWlzTmFOKG4pICYmIGlzRmluaXRlKG4pO1xuLy8gdXNlZCBmb3IgYTExeSBrZXkgYm9hcmQgY29udHJvbHMgZm9yIG5vZGVzIGFuZCBlZGdlc1xuY29uc3QgZGV2V2FybiA9IChpZCwgbWVzc2FnZSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtSZWFjdCBGbG93XTogJHttZXNzYWdlfSBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjJHtpZH1gKTtcbiAgICB9XG59O1xuY29uc3Qgc25hcFBvc2l0aW9uID0gKHBvc2l0aW9uLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHNuYXBHcmlkWzBdICogTWF0aC5yb3VuZChwb3NpdGlvbi54IC8gc25hcEdyaWRbMF0pLFxuICAgICAgICB5OiBzbmFwR3JpZFsxXSAqIE1hdGgucm91bmQocG9zaXRpb24ueSAvIHNuYXBHcmlkWzFdKSxcbiAgICB9O1xufTtcbmNvbnN0IHBvaW50VG9SZW5kZXJlclBvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdLCBzbmFwVG9HcmlkID0gZmFsc2UsIHNuYXBHcmlkID0gWzEsIDFdKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6ICh4IC0gdHgpIC8gdFNjYWxlLFxuICAgICAgICB5OiAoeSAtIHR5KSAvIHRTY2FsZSxcbiAgICB9O1xuICAgIHJldHVybiBzbmFwVG9HcmlkID8gc25hcFBvc2l0aW9uKHBvc2l0aW9uLCBzbmFwR3JpZCkgOiBwb3NpdGlvbjtcbn07XG5jb25zdCByZW5kZXJlclBvaW50VG9Qb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKiB0U2NhbGUgKyB0eCxcbiAgICAgICAgeTogeSAqIHRTY2FsZSArIHR5LFxuICAgIH07XG59O1xuLyoqXG4gKiBQYXJzZXMgYSBzaW5nbGUgcGFkZGluZyB2YWx1ZSB0byBhIG51bWJlclxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB2aWV3cG9ydCAtIFdpZHRoIG9yIGhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIGluIHBpeGVsc1xuICovXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmcocGFkZGluZywgdmlld3BvcnQpIHtcbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh2aWV3cG9ydCAtIHZpZXdwb3J0IC8gKDEgKyBwYWRkaW5nKSkgKiAwLjUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdzdHJpbmcnICYmIHBhZGRpbmcuZW5kc1dpdGgoJ3B4JykpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ZhbHVlID0gcGFyc2VGbG9hdChwYWRkaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFkZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocGFkZGluZ1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdzdHJpbmcnICYmIHBhZGRpbmcuZW5kc1dpdGgoJyUnKSkge1xuICAgICAgICBjb25zdCBwYWRkaW5nVmFsdWUgPSBwYXJzZUZsb2F0KHBhZGRpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYWRkaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2aWV3cG9ydCAqIHBhZGRpbmdWYWx1ZSAqIDAuMDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoYFtSZWFjdCBGbG93XSBUaGUgcGFkZGluZyB2YWx1ZSBcIiR7cGFkZGluZ31cIiBpcyBpbnZhbGlkLiBQbGVhc2UgcHJvdmlkZSBhIG51bWJlciBvciBhIHN0cmluZyB3aXRoIGEgdmFsaWQgdW5pdCAocHggb3IgJSkuYCk7XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcGFkZGluZ3MgdG8gYW4gb2JqZWN0IHdpdGggdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB4IGFuZCB5IHBhZGRpbmdzXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyB0byBwYXJzZVxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHBhZGRpbmdzIGluIHBpeGVsc1xuICovXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmdzKHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLCB3aWR0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHBhZGRpbmdZLFxuICAgICAgICAgICAgcmlnaHQ6IHBhZGRpbmdYLFxuICAgICAgICAgICAgYm90dG9tOiBwYWRkaW5nWSxcbiAgICAgICAgICAgIGxlZnQ6IHBhZGRpbmdYLFxuICAgICAgICAgICAgeDogcGFkZGluZ1ggKiAyLFxuICAgICAgICAgICAgeTogcGFkZGluZ1kgKiAyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLnRvcCA/PyBwYWRkaW5nLnkgPz8gMCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcuYm90dG9tID8/IHBhZGRpbmcueSA/PyAwLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBsZWZ0ID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcubGVmdCA/PyBwYWRkaW5nLnggPz8gMCwgd2lkdGgpO1xuICAgICAgICBjb25zdCByaWdodCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLnJpZ2h0ID8/IHBhZGRpbmcueCA/PyAwLCB3aWR0aCk7XG4gICAgICAgIHJldHVybiB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgeDogbGVmdCArIHJpZ2h0LCB5OiB0b3AgKyBib3R0b20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCB4OiAwLCB5OiAwIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHJlc3VsdGluZyBwYWRkaW5ncyBpZiB0aGUgbmV3IHZpZXdwb3J0IGlzIGFwcGxpZWRcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGJvdW5kcyAtIEJvdW5kcyB0byBmaXQgaW5zaWRlIHZpZXdwb3J0XG4gKiBAcGFyYW0geCAtIFggcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0geSAtIFkgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gem9vbSAtIFpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgbWluaW11bSBwYWRkaW5nIHJlcXVpcmVkIHRvIGZpdCB0aGUgYm91bmRzIGluc2lkZSB0aGUgdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQXBwbGllZFBhZGRpbmdzKGJvdW5kcywgeCwgeSwgem9vbSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHsgeDogbGVmdCwgeTogdG9wIH0gPSByZW5kZXJlclBvaW50VG9Qb2ludChib3VuZHMsIFt4LCB5LCB6b29tXSk7XG4gICAgY29uc3QgeyB4OiBib3VuZFJpZ2h0LCB5OiBib3VuZEJvdHRvbSB9ID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoeyB4OiBib3VuZHMueCArIGJvdW5kcy53aWR0aCwgeTogYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IH0sIFt4LCB5LCB6b29tXSk7XG4gICAgY29uc3QgcmlnaHQgPSB3aWR0aCAtIGJvdW5kUmlnaHQ7XG4gICAgY29uc3QgYm90dG9tID0gaGVpZ2h0IC0gYm91bmRCb3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5mbG9vcihsZWZ0KSxcbiAgICAgICAgdG9wOiBNYXRoLmZsb29yKHRvcCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLmZsb29yKHJpZ2h0KSxcbiAgICAgICAgYm90dG9tOiBNYXRoLmZsb29yKGJvdHRvbSksXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHZpZXdwb3J0IHRoYXQgZW5jbG9zZXMgdGhlIGdpdmVuIGJvdW5kcyB3aXRoIHBhZGRpbmcuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBZb3UgY2FuIGRldGVybWluZSBib3VuZHMgb2Ygbm9kZXMgd2l0aCB7QGxpbmsgZ2V0Tm9kZXNCb3VuZHN9IGFuZCB7QGxpbmsgZ2V0Qm91bmRzT2ZSZWN0c31cbiAqIEBwYXJhbSBib3VuZHMgLSBCb3VuZHMgdG8gZml0IGluc2lkZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBoZWlnaHQgIC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBtaW5ab29tIC0gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSByZXN1bHRpbmcgdmlld3BvcnQuXG4gKiBAcGFyYW0gbWF4Wm9vbSAtIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0LlxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIGFyb3VuZCB0aGUgYm91bmRzLlxuICogQHJldHVybnMgQSB0cmFuc2Zvcm1lZCB7QGxpbmsgVmlld3BvcnR9IHRoYXQgZW5jbG9zZXMgdGhlIGdpdmVuIGJvdW5kcyB3aGljaCB5b3UgY2FuIHBhc3MgdG8gZS5nLiB7QGxpbmsgc2V0Vmlld3BvcnR9LlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoXG4gKiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwfSxcbiAqIDEyMDAsIDgwMCwgMC41LCAyKTtcbiAqL1xuY29uc3QgZ2V0Vmlld3BvcnRGb3JCb3VuZHMgPSAoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYWRkaW5nKSA9PiB7XG4gICAgLy8gRmlyc3Qgd2UgcmVzb2x2ZSBhbGwgdGhlIHBhZGRpbmdzIHRvIGFjdHVhbCBwaXhlbCB2YWx1ZXNcbiAgICBjb25zdCBwID0gcGFyc2VQYWRkaW5ncyhwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB4Wm9vbSA9ICh3aWR0aCAtIHAueCkgLyBib3VuZHMud2lkdGg7XG4gICAgY29uc3QgeVpvb20gPSAoaGVpZ2h0IC0gcC55KSAvIGJvdW5kcy5oZWlnaHQ7XG4gICAgLy8gV2UgY2FsY3VsYXRlIHRoZSBuZXcgeCwgeSwgem9vbSBmb3IgYSBjZW50ZXJlZCB2aWV3XG4gICAgY29uc3Qgem9vbSA9IE1hdGgubWluKHhab29tLCB5Wm9vbSk7XG4gICAgY29uc3QgY2xhbXBlZFpvb20gPSBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJYID0gYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclkgPSBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IHggPSB3aWR0aCAvIDIgLSBib3VuZHNDZW50ZXJYICogY2xhbXBlZFpvb207XG4gICAgY29uc3QgeSA9IGhlaWdodCAvIDIgLSBib3VuZHNDZW50ZXJZICogY2xhbXBlZFpvb207XG4gICAgLy8gVGhlbiB3ZSBjYWxjdWxhdGUgdGhlIG1pbmltdW0gcGFkZGluZywgdG8gcmVzcGVjdCBhc3ltbWV0cmljIHBhZGRpbmdzXG4gICAgY29uc3QgbmV3UGFkZGluZyA9IGNhbGN1bGF0ZUFwcGxpZWRQYWRkaW5ncyhib3VuZHMsIHgsIHksIGNsYW1wZWRab29tLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhbiBvZmZzZXQgaWYgdGhlIG5ld1BhZGRpbmcgaXMgc21hbGxlciB0aGFuIHRoZSByZXF1aXJlZCBwYWRkaW5nXG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihuZXdQYWRkaW5nLmxlZnQgLSBwLmxlZnQsIDApLFxuICAgICAgICB0b3A6IE1hdGgubWluKG5ld1BhZGRpbmcudG9wIC0gcC50b3AsIDApLFxuICAgICAgICByaWdodDogTWF0aC5taW4obmV3UGFkZGluZy5yaWdodCAtIHAucmlnaHQsIDApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKG5ld1BhZGRpbmcuYm90dG9tIC0gcC5ib3R0b20sIDApLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIG9mZnNldC5sZWZ0ICsgb2Zmc2V0LnJpZ2h0LFxuICAgICAgICB5OiB5IC0gb2Zmc2V0LnRvcCArIG9mZnNldC5ib3R0b20sXG4gICAgICAgIHpvb206IGNsYW1wZWRab29tLFxuICAgIH07XG59O1xuY29uc3QgaXNNYWNPcyA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvcj8udXNlckFnZW50Py5pbmRleE9mKCdNYWMnKSA+PSAwO1xuZnVuY3Rpb24gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBleHRlbnQgIT09IHVuZGVmaW5lZCAmJiBleHRlbnQgIT09IG51bGwgJiYgZXh0ZW50ICE9PSAncGFyZW50Jztcbn1cbmZ1bmN0aW9uIGdldE5vZGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSkge1xuICAgIHJldHVybiAoKG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGgpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQpICE9PSB1bmRlZmluZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGNoaWxkIHBvc2l0aW9uIHRvIGFib3NsdXRlIHBvc2l0aW9uXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcG9zaXRpb25cbiAqIEBwYXJhbSBwYXJlbnRJZFxuICogQHBhcmFtIG5vZGVMb29rdXBcbiAqIEBwYXJhbSBub2RlT3JpZ2luXG4gKiBAcmV0dXJucyBhbiBpbnRlcm5hbCBub2RlIHdpdGggYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHBvc2l0aW9uLCBkaW1lbnNpb25zID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sIHBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKSB7XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IHsgLi4ucG9zaXRpb24gfTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjb25zdCBvcmlnaW4gPSBwYXJlbnQub3JpZ2luIHx8IG5vZGVPcmlnaW47XG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUueCArPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAtIChkaW1lbnNpb25zLndpZHRoID8/IDApICogb3JpZ2luWzBdO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnkgKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgLSAoZGltZW5zaW9ucy5oZWlnaHQgPz8gMCkgKiBvcmlnaW5bMV07XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbkFic29sdXRlO1xufVxuZnVuY3Rpb24gYXJlU2V0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgICAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFBvbHlmaWxsIGZvciBQcm9taXNlLndpdGhSZXNvbHZlcnMgdW50aWwgd2UgY2FuIHVzZSBpdCBpbiBhbGwgYnJvd3NlcnNcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB3aXRoUmVzb2x2ZXJzKCkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG5mdW5jdGlvbiBtZXJnZUFyaWFMYWJlbENvbmZpZyhwYXJ0aWFsKSB7XG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgLi4uKHBhcnRpYWwgfHwge30pIH07XG59XG5cbmZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihldmVudCwgeyBzbmFwR3JpZCA9IFswLCAwXSwgc25hcFRvR3JpZCA9IGZhbHNlLCB0cmFuc2Zvcm0sIGNvbnRhaW5lckJvdW5kcyB9KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBwb2ludGVyUG9zID0gcG9pbnRUb1JlbmRlcmVyUG9pbnQoeyB4OiB4IC0gKGNvbnRhaW5lckJvdW5kcz8ubGVmdCA/PyAwKSwgeTogeSAtIChjb250YWluZXJCb3VuZHM/LnRvcCA/PyAwKSB9LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHsgeDogeFNuYXBwZWQsIHk6IHlTbmFwcGVkIH0gPSBzbmFwVG9HcmlkID8gc25hcFBvc2l0aW9uKHBvaW50ZXJQb3MsIHNuYXBHcmlkKSA6IHBvaW50ZXJQb3M7XG4gICAgLy8gd2UgbmVlZCB0aGUgc25hcHBlZCBwb3NpdGlvbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHNraXAgdW5uZWNlc3NhcnkgZHJhZyBldmVudHNcbiAgICByZXR1cm4ge1xuICAgICAgICB4U25hcHBlZCxcbiAgICAgICAgeVNuYXBwZWQsXG4gICAgICAgIC4uLnBvaW50ZXJQb3MsXG4gICAgfTtcbn1cbmNvbnN0IGdldERpbWVuc2lvbnMgPSAobm9kZSkgPT4gKHtcbiAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0LFxufSk7XG5jb25zdCBnZXRIb3N0Rm9yRWxlbWVudCA9IChlbGVtZW50KSA9PiBlbGVtZW50Py5nZXRSb290Tm9kZT8uKCkgfHwgd2luZG93Py5kb2N1bWVudDtcbmNvbnN0IGlucHV0VGFncyA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ107XG5mdW5jdGlvbiBpc0lucHV0RE9NTm9kZShldmVudCkge1xuICAgIC8vIHVzaW5nIGNvbXBvc2VkIHBhdGggZm9yIGhhbmRsaW5nIHNoYWRvdyBkb21cbiAgICBjb25zdCB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWRQYXRoPy4oKT8uWzBdIHx8IGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKHRhcmdldD8ubm9kZVR5cGUgIT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0lucHV0ID0gaW5wdXRUYWdzLmluY2x1ZGVzKHRhcmdldC5ub2RlTmFtZSkgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgLy8gd2hlbiBhbiBpbnB1dCBmaWVsZCBpcyBmb2N1c2VkIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBkZWxldGlvbiBvciBtb3ZlbWVudCBvZiBub2Rlc1xuICAgIHJldHVybiBpc0lucHV0IHx8ICEhdGFyZ2V0LmNsb3Nlc3QoJy5ub2tleScpO1xufVxuY29uc3QgaXNNb3VzZUV2ZW50ID0gKGV2ZW50KSA9PiAnY2xpZW50WCcgaW4gZXZlbnQ7XG5jb25zdCBnZXRFdmVudFBvc2l0aW9uID0gKGV2ZW50LCBib3VuZHMpID0+IHtcbiAgICBjb25zdCBpc01vdXNlID0gaXNNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBldnRYID0gaXNNb3VzZSA/IGV2ZW50LmNsaWVudFggOiBldmVudC50b3VjaGVzPy5bMF0uY2xpZW50WDtcbiAgICBjb25zdCBldnRZID0gaXNNb3VzZSA/IGV2ZW50LmNsaWVudFkgOiBldmVudC50b3VjaGVzPy5bMF0uY2xpZW50WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldnRYIC0gKGJvdW5kcz8ubGVmdCA/PyAwKSxcbiAgICAgICAgeTogZXZ0WSAtIChib3VuZHM/LnRvcCA/PyAwKSxcbiAgICB9O1xufTtcbi8qXG4gKiBUaGUgaGFuZGxlIGJvdW5kcyBhcmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgbm9kZSBlbGVtZW50LlxuICogV2Ugc3RvcmUgdGhlbSBpbiB0aGUgaW50ZXJuYWxzIG9iamVjdCBvZiB0aGUgbm9kZSBpbiBvcmRlciB0byBhdm9pZFxuICogdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMuXG4gKi9cbmNvbnN0IGdldEhhbmRsZUJvdW5kcyA9ICh0eXBlLCBub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZUlkKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlcyA9IG5vZGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3R5cGV9YCk7XG4gICAgaWYgKCFoYW5kbGVzIHx8ICFoYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaGFuZGxlcykubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogaGFuZGxlLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVwb3MnKSxcbiAgICAgICAgICAgIHg6IChoYW5kbGVCb3VuZHMubGVmdCAtIG5vZGVCb3VuZHMubGVmdCkgLyB6b29tLFxuICAgICAgICAgICAgeTogKGhhbmRsZUJvdW5kcy50b3AgLSBub2RlQm91bmRzLnRvcCkgLyB6b29tLFxuICAgICAgICAgICAgLi4uZ2V0RGltZW5zaW9ucyhoYW5kbGUpLFxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0QmV6aWVyRWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWSwgdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZLCB9KSB7XG4gICAgLypcbiAgICAgKiBjdWJpYyBiZXppZXIgdD0wLjUgbWlkIHBvaW50LCBub3QgdGhlIGFjdHVhbCBtaWQgcG9pbnQsIGJ1dCBlYXN5IHRvIGNhbGN1bGF0ZVxuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3NTE2MTAxL2hvdy10by1maW5kLWRpc3RhbmNlLW1pZC1wb2ludC1vZi1iZXppZXItY3VydmVcbiAgICAgKi9cbiAgICBjb25zdCBjZW50ZXJYID0gc291cmNlWCAqIDAuMTI1ICsgc291cmNlQ29udHJvbFggKiAwLjM3NSArIHRhcmdldENvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRYICogMC4xMjU7XG4gICAgY29uc3QgY2VudGVyWSA9IHNvdXJjZVkgKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0WSAqIDAuMTI1O1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmFicyhjZW50ZXJYIC0gc291cmNlWCk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguYWJzKGNlbnRlclkgLSBzb3VyY2VZKTtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIG9mZnNldFgsIG9mZnNldFldO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJvbE9mZnNldChkaXN0YW5jZSwgY3VydmF0dXJlKSB7XG4gICAgaWYgKGRpc3RhbmNlID49IDApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGRpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmF0dXJlICogMjUgKiBNYXRoLnNxcnQoLWRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiwgYyB9KSB7XG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDEgLSB4MiwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgyIC0geDEsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkxIC0geTIsIGMpXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTIgLSB5MSwgYyldO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGBnZXRCZXppZXJQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBiZXppZXIgZWRnZVxuICpiZXR3ZWVuIHR3byBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgYGxhYmVsWGAgYW5kIGBsYWJlbFlgIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aClcbiAqIGFuZCBgb2Zmc2V0WGAsIGBvZmZzZXRZYCBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsLlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKn0pO1xuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG9cbiAqd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY3VydmF0dXJlID0gMC4yNSwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5cbi8vIHRoaXMgaXMgdXNlZCBmb3Igc3RyYWlnaHQgZWRnZXMgYW5kIHNpbXBsZSBzbW9vdGhzdGVwIGVkZ2VzIChMVFIsIFJUTCwgQlRULCBUVEIpXG5mdW5jdGlvbiBnZXRFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IHhPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRYIC0gc291cmNlWCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclggPSB0YXJnZXRYIDwgc291cmNlWCA/IHRhcmdldFggKyB4T2Zmc2V0IDogdGFyZ2V0WCAtIHhPZmZzZXQ7XG4gICAgY29uc3QgeU9mZnNldCA9IE1hdGguYWJzKHRhcmdldFkgLSBzb3VyY2VZKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHRhcmdldFkgPCBzb3VyY2VZID8gdGFyZ2V0WSArIHlPZmZzZXQgOiB0YXJnZXRZIC0geU9mZnNldDtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIHhPZmZzZXQsIHlPZmZzZXRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6LWluZGV4IGZvciBhbiBlZGdlIGJhc2VkIG9uIHRoZSBub2RlIGl0IGNvbm5lY3RzIGFuZCB3aGV0aGVyIGl0IGlzIHNlbGVjdGVkLlxuICogQnkgZGVmYXVsdCwgZWRnZXMgYXJlIHJlbmRlcmVkIGJlbG93IG5vZGVzLiBUaGlzIGJlaGF2aW91ciBpcyBkaWZmZXJlbnQgZm9yIGVkZ2VzIHRoYXQgYXJlXG4gKiBjb25uZWN0ZWQgdG8gbm9kZXMgd2l0aCBhIHBhcmVudCwgYXMgdGhleSBhcmUgcmVuZGVyZWQgYWJvdmUgdGhlIHBhcmVudCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgoeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlLCBzZWxlY3RlZCA9IGZhbHNlLCB6SW5kZXgsIGVsZXZhdGVPblNlbGVjdCA9IGZhbHNlLCB9KSB7XG4gICAgaWYgKHpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB6SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VaID0gZWxldmF0ZU9uU2VsZWN0ICYmIHNlbGVjdGVkID8gMTAwMCA6IDA7XG4gICAgY29uc3Qgbm9kZVogPSBNYXRoLm1heChzb3VyY2VOb2RlLnBhcmVudElkIHx8IChlbGV2YXRlT25TZWxlY3QgJiYgc291cmNlTm9kZS5zZWxlY3RlZCkgPyBzb3VyY2VOb2RlLmludGVybmFscy56IDogMCwgdGFyZ2V0Tm9kZS5wYXJlbnRJZCB8fCAoZWxldmF0ZU9uU2VsZWN0ICYmIHRhcmdldE5vZGUuc2VsZWN0ZWQpID8gdGFyZ2V0Tm9kZS5pbnRlcm5hbHMueiA6IDApO1xuICAgIHJldHVybiBlZGdlWiArIG5vZGVaO1xufVxuZnVuY3Rpb24gaXNFZGdlVmlzaWJsZSh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgZWRnZUJveCA9IGdldEJvdW5kc09mQm94ZXMobm9kZVRvQm94KHNvdXJjZU5vZGUpLCBub2RlVG9Cb3godGFyZ2V0Tm9kZSkpO1xuICAgIGlmIChlZGdlQm94LnggPT09IGVkZ2VCb3gueDIpIHtcbiAgICAgICAgZWRnZUJveC54MiArPSAxO1xuICAgIH1cbiAgICBpZiAoZWRnZUJveC55ID09PSBlZGdlQm94LnkyKSB7XG4gICAgICAgIGVkZ2VCb3gueTIgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld1JlY3QgPSB7XG4gICAgICAgIHg6IC10cmFuc2Zvcm1bMF0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC10cmFuc2Zvcm1bMV0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiB3aWR0aCAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyB0cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0T3ZlcmxhcHBpbmdBcmVhKHZpZXdSZWN0LCBib3hUb1JlY3QoZWRnZUJveCkpID4gMDtcbn1cbmNvbnN0IGdldEVkZ2VJZCA9ICh7IHNvdXJjZSwgc291cmNlSGFuZGxlLCB0YXJnZXQsIHRhcmdldEhhbmRsZSB9KSA9PiBgeHktZWRnZV9fJHtzb3VyY2V9JHtzb3VyY2VIYW5kbGUgfHwgJyd9LSR7dGFyZ2V0fSR7dGFyZ2V0SGFuZGxlIHx8ICcnfWA7XG5jb25zdCBjb25uZWN0aW9uRXhpc3RzID0gKGVkZ2UsIGVkZ2VzKSA9PiB7XG4gICAgcmV0dXJuIGVkZ2VzLnNvbWUoKGVsKSA9PiBlbC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmXG4gICAgICAgIGVsLnRhcmdldCA9PT0gZWRnZS50YXJnZXQgJiZcbiAgICAgICAgKGVsLnNvdXJjZUhhbmRsZSA9PT0gZWRnZS5zb3VyY2VIYW5kbGUgfHwgKCFlbC5zb3VyY2VIYW5kbGUgJiYgIWVkZ2Uuc291cmNlSGFuZGxlKSkgJiZcbiAgICAgICAgKGVsLnRhcmdldEhhbmRsZSA9PT0gZWRnZS50YXJnZXRIYW5kbGUgfHwgKCFlbC50YXJnZXRIYW5kbGUgJiYgIWVkZ2UudGFyZ2V0SGFuZGxlKSkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IEVkZ2UgdG8gYW4gYXJyYXkgb2YgZWRnZXMuIEl0IGFsc28gcGVyZm9ybXMgc29tZSB2YWxpZGF0aW9uIHRvIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgYWRkIGFuIGludmFsaWQgZWRnZSBvciBkdXBsaWNhdGUgYW4gZXhpc3Rpbmcgb25lLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGVkZ2VQYXJhbXMgLSBFaXRoZXIgYW4gYEVkZ2VgIG9yIGEgYENvbm5lY3Rpb25gIHlvdSB3YW50IHRvIGFkZC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIGVkZ2VzIHdpdGggdGhlIG5ldyBlZGdlIGFkZGVkLlxuICpcbiAqIEByZW1hcmtzIElmIGFuIGVkZ2Ugd2l0aCB0aGUgc2FtZSBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgYWxyZWFkeSBleGlzdHMgKGFuZCB0aGUgc2FtZVxuICpgdGFyZ2V0SGFuZGxlYCBhbmQgYHNvdXJjZUhhbmRsZWAgaWYgdGhvc2UgYXJlIHNldCksIHRoZW4gdGhpcyB1dGlsIHdvbid0IGFkZFxuICphIG5ldyBlZGdlIGV2ZW4gaWYgdGhlIGBpZGAgcHJvcGVydHkgaXMgZGlmZmVyZW50LlxuICpcbiAqL1xuY29uc3QgYWRkRWRnZSA9IChlZGdlUGFyYW1zLCBlZGdlcykgPT4ge1xuICAgIGlmICghZWRnZVBhcmFtcy5zb3VyY2UgfHwgIWVkZ2VQYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgbGV0IGVkZ2U7XG4gICAgaWYgKGlzRWRnZUJhc2UoZWRnZVBhcmFtcykpIHtcbiAgICAgICAgZWRnZSA9IHsgLi4uZWRnZVBhcmFtcyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRnZSA9IHtcbiAgICAgICAgICAgIC4uLmVkZ2VQYXJhbXMsXG4gICAgICAgICAgICBpZDogZ2V0RWRnZUlkKGVkZ2VQYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbkV4aXN0cyhlZGdlLCBlZGdlcykpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2VIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2Uuc291cmNlSGFuZGxlO1xuICAgIH1cbiAgICBpZiAoZWRnZS50YXJnZXRIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2UudGFyZ2V0SGFuZGxlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXMuY29uY2F0KGVkZ2UpO1xufTtcbi8qKlxuICogQSBoYW5keSB1dGlsaXR5IHRvIHVwZGF0ZSBhbiBleGlzdGluZyBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKSB3aXRoIG5ldyBwcm9wZXJ0aWVzLlxuICpUaGlzIHNlYXJjaGVzIHlvdXIgZWRnZSBhcnJheSBmb3IgYW4gZWRnZSB3aXRoIGEgbWF0Y2hpbmcgYGlkYCBhbmQgdXBkYXRlcyBpdHNcbiAqcHJvcGVydGllcyB3aXRoIHRoZSBjb25uZWN0aW9uIHlvdSBwcm92aWRlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9sZEVkZ2UgLSBUaGUgZWRnZSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gKiBAcGFyYW0gbmV3Q29ubmVjdGlvbiAtIFRoZSBuZXcgY29ubmVjdGlvbiB5b3Ugd2FudCB0byB1cGRhdGUgdGhlIGVkZ2Ugd2l0aC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGVkZ2VzIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICpjb25zdCBvblJlY29ubmVjdCA9IHVzZUNhbGxiYWNrKFxuICogIChvbGRFZGdlOiBFZGdlLCBuZXdDb25uZWN0aW9uOiBDb25uZWN0aW9uKSA9PiBzZXRFZGdlcygoZWxzKSA9PiByZWNvbm5lY3RFZGdlKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVscykpLFtdKTtcbiAqYGBgXG4gKi9cbmNvbnN0IHJlY29ubmVjdEVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZS5pZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzdHJhaWdodCBsaW5lIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtgTSAke3NvdXJjZVh9LCR7c291cmNlWX1MICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuY29uc3QgaGFuZGxlRGlyZWN0aW9ucyA9IHtcbiAgICBbUG9zaXRpb24uTGVmdF06IHsgeDogLTEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiB7IHg6IDEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uVG9wXTogeyB4OiAwLCB5OiAtMSB9LFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiB7IHg6IDAsIHk6IDEgfSxcbn07XG5jb25zdCBnZXREaXJlY3Rpb24gPSAoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIH0pID0+IHtcbiAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQgfHwgc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UueCA8IHRhcmdldC54ID8geyB4OiAxLCB5OiAwIH0gOiB7IHg6IC0xLCB5OiAwIH07XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UueSA8IHRhcmdldC55ID8geyB4OiAwLCB5OiAxIH0gOiB7IHg6IDAsIHk6IC0xIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KE1hdGgucG93KGIueCAtIGEueCwgMikgKyBNYXRoLnBvdyhiLnkgLSBhLnksIDIpKTtcbi8qXG4gKiBXaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGFuIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nIGJlaGF2aW91clxuICogSXQncyBub3QgYXMgZ29vZCBhcyBhIHJlYWwgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcsIGJ1dCBpdCdzIGZhc3RlciBhbmQgZ29vZCBlbm91Z2ggYXMgYSBkZWZhdWx0IGZvciBzdGVwIGFuZCBzbW9vdGggc3RlcCBlZGdlc1xuICovXG5mdW5jdGlvbiBnZXRQb2ludHMoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjZW50ZXIsIG9mZnNldCwgc3RlcFBvc2l0aW9uLCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbLCAsIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbCwgc28gc3RlcFBvc2l0aW9uIGFmZmVjdHMgWCBjb29yZGluYXRlXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgKHRhcmdldEdhcHBlZC54IC0gc291cmNlR2FwcGVkLngpICogc3RlcFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyB0YXJnZXRHYXBwZWQueSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgdmVydGljYWwsIHNvIHN0ZXBQb3NpdGlvbiBhZmZlY3RzIFkgY29vcmRpbmF0ZSAgXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgdGFyZ2V0R2FwcGVkLngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyAodGFyZ2V0R2FwcGVkLnkgLSBzb3VyY2VHYXBwZWQueSkgKiBzdGVwUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIC0tLT5cbiAgICAgICAgICogICAgfFxuICAgICAgICAgKiA+LS0tXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiBzb3VyY2VHYXBwZWQueSB9LFxuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiB0YXJnZXRHYXBwZWQueSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqICAtLS1cbiAgICAgICAgICogIHxcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogc291cmNlR2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyB2ZXJ0aWNhbFNwbGl0IDogaG9yaXpvbnRhbFNwbGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IGhvcml6b250YWxTcGxpdCA6IHZlcnRpY2FsU3BsaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNvdXJjZVRhcmdldCBtZWFucyB3ZSB0YWtlIHggZnJvbSBzb3VyY2UgYW5kIHkgZnJvbSB0YXJnZXQsIHRhcmdldFNvdXJjZSBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgY29uc3Qgc291cmNlVGFyZ2V0ID0gW3sgeDogc291cmNlR2FwcGVkLngsIHk6IHRhcmdldEdhcHBlZC55IH1dO1xuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBbeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogc291cmNlR2FwcGVkLnkgfV07XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlcyBlZGdlcyB3aXRoIHNhbWUgaGFuZGxlIHBvc2l0aW9uc1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnggPT09IGN1cnJEaXIgPyB0YXJnZXRTb3VyY2UgOiBzb3VyY2VUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueSA9PT0gY3VyckRpciA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoc291cmNlW2RpckFjY2Vzc29yXSAtIHRhcmdldFtkaXJBY2Nlc3Nvcl0pO1xuICAgICAgICAgICAgLy8gaWYgYW4gZWRnZSBnb2VzIGZyb20gcmlnaHQgdG8gcmlnaHQgZm9yIGV4YW1wbGUgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikgYW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZS54IGFuZCB0YXJnZXQueCBpcyBsZXNzIHRoYW4gdGhlIG9mZnNldCwgdGhlIGFkZGVkIHBvaW50IGFuZCB0aGUgZ2FwcGVkIHNvdXJjZS90YXJnZXQgd2lsbCBvdmVybGFwLiBUaGlzIGxlYWRzIHRvIGEgd2VpcmQgZWRnZSBwYXRoLiBUbyBhdm9pZCB0aGlzIHdlIGFkZCBhIGdhcE9mZnNldCB0byB0aGUgc291cmNlL3RhcmdldFxuICAgICAgICAgICAgaWYgKGRpZmYgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwT2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0IC0gMSwgb2Zmc2V0IC0gZGlmZik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlR2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9IChzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JdID4gc291cmNlW2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiB0YXJnZXRbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgYXJlIGNvbmRpdGlvbnMgZm9yIGhhbmRsaW5nIG1peGVkIGhhbmRsZSBwb3NpdGlvbnMgbGlrZSBSaWdodCAtPiBCb3R0b20gZm9yIGV4YW1wbGVcbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uICE9PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlyQWNjZXNzb3JPcHBvc2l0ZSA9IGRpckFjY2Vzc29yID09PSAneCcgPyAneScgOiAneCc7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWVEaXIgPSBzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSB0YXJnZXREaXJbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VHdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPiB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPCB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBmbGlwU291cmNlVGFyZ2V0ID0gKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pKSkgfHxcbiAgICAgICAgICAgICAgICAoc291cmNlRGlyW2RpckFjY2Vzc29yXSAhPT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykpKTtcbiAgICAgICAgICAgIGlmIChmbGlwU291cmNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VHYXBQb2ludCA9IHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCB0YXJnZXRHYXBQb2ludCA9IHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCBtYXhYRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpKTtcbiAgICAgICAgY29uc3QgbWF4WURpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueSAtIHBvaW50c1swXS55KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueSAtIHBvaW50c1swXS55KSk7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcGxhY2UgdGhlIGxhYmVsIG9uIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG1heFhEaXN0YW5jZSA+PSBtYXhZRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNlbnRlclggPSAoc291cmNlR2FwUG9pbnQueCArIHRhcmdldEdhcFBvaW50LngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBwb2ludHNbMF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbnRlclggPSBwb2ludHNbMF0ueDtcbiAgICAgICAgICAgIGNlbnRlclkgPSAoc291cmNlR2FwUG9pbnQueSArIHRhcmdldEdhcFBvaW50LnkpIC8gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXRoUG9pbnRzID0gW1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9LFxuICAgICAgICAuLi5wb2ludHMsXG4gICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9LFxuICAgICAgICB0YXJnZXQsXG4gICAgXTtcbiAgICByZXR1cm4gW3BhdGhQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV07XG59XG5mdW5jdGlvbiBnZXRCZW5kKGEsIGIsIGMsIHNpemUpIHtcbiAgICBjb25zdCBiZW5kU2l6ZSA9IE1hdGgubWluKGRpc3RhbmNlKGEsIGIpIC8gMiwgZGlzdGFuY2UoYiwgYykgLyAyLCBzaXplKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGI7XG4gICAgLy8gbm8gYmVuZFxuICAgIGlmICgoYS54ID09PSB4ICYmIHggPT09IGMueCkgfHwgKGEueSA9PT0geSAmJiB5ID09PSBjLnkpKSB7XG4gICAgICAgIHJldHVybiBgTCR7eH0gJHt5fWA7XG4gICAgfVxuICAgIC8vIGZpcnN0IHNlZ21lbnQgaXMgaG9yaXpvbnRhbFxuICAgIGlmIChhLnkgPT09IHkpIHtcbiAgICAgICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIGBMICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fVEgJHt4fSwke3l9ICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfWA7XG4gICAgfVxuICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAxIDogLTE7XG4gICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IC0xIDogMTtcbiAgICByZXR1cm4gYEwgJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9USAke3h9LCR7eX0gJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9YDtcbn1cbi8qKlxuICogVGhlIGBnZXRTbW9vdGhTdGVwUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc3RlcHBlZCBwYXRoXG4gKiBiZXR3ZWVuIHR3byBub2Rlcy4gVGhlIGBib3JkZXJSYWRpdXNgIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGNob29zZSBob3cgcm91bmRlZFxuICogdGhlIGNvcm5lcnMgb2YgdGhvc2Ugc3RlcHMgYXJlLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICogIH0pO1xuICogYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoU3RlcFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGJvcmRlclJhZGl1cyA9IDUsIGNlbnRlclgsIGNlbnRlclksIG9mZnNldCA9IDIwLCBzdGVwUG9zaXRpb24gPSAwLjUsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgc3RlcFBvc2l0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvKlxuICAgICAqIHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3BcbiAgICAgKiB3ZSBzZXQgdGhlIHggYW55IHkgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgYmFzZWQgb24gdGhlIG5vZGVzIHBvc2l0aW9uXG4gICAgICovXG4gICAgbGV0IHBvcyA9IFtcbiAgICAgICAgKG5vZGVSZWN0LnggKyBub2RlUmVjdC53aWR0aCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCxcbiAgICAgICAgbm9kZVJlY3QueSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55IC0gb2Zmc2V0LFxuICAgIF07XG4gICAgLy8gYW5kIHRoYW4gc2hpZnQgaXQgYmFzZWQgb24gdGhlIGFsaWdubWVudC4gVGhlIHNoaWZ0IHZhbHVlcyBhcmUgaW4gJS5cbiAgICBsZXQgc2hpZnQgPSBbLTEwMCAqIGFsaWdubWVudE9mZnNldCwgLTEwMF07XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGgpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQgKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc2hpZnQgPSBbMCwgLTEwMCAqIGFsaWdubWVudE9mZnNldF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICBwb3NbMV0gPSAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSArIG9mZnNldDtcbiAgICAgICAgICAgIHNoaWZ0WzFdID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbm9kZVJlY3QueCAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54IC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWy0xMDAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgdHJhbnNsYXRlKCR7c2hpZnRbMF19JSwgJHtzaGlmdFsxXX0lKWA7XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5vZGVPcmlnaW46IFswLCAwXSxcbiAgICBub2RlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICBkZWZhdWx0czoge30sXG59O1xuY29uc3QgYWRvcHRVc2VyTm9kZXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICBjaGVja0VxdWFsaXR5OiB0cnVlLFxufTtcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhiYXNlLCBpbmNvbWluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluY29taW5nKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHR5cGVjYXN0IGlzIHNhZmUgaGVyZSwgYmVjYXVzZSB3ZSBjaGVjayBmb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGluY29taW5nW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxvb2t1cC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyhub2RlKSk7XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gY2xhbXBlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VIYW5kbGVzKHVzZXJOb2RlLCBpbnRlcm5hbE5vZGUpIHtcbiAgICBpZiAoIXVzZXJOb2RlLmhhbmRsZXMpIHtcbiAgICAgICAgcmV0dXJuICF1c2VyTm9kZS5tZWFzdXJlZCA/IHVuZGVmaW5lZCA6IGludGVybmFsTm9kZT8uaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gW107XG4gICAgY29uc3QgdGFyZ2V0ID0gW107XG4gICAgZm9yIChjb25zdCBoYW5kbGUgb2YgdXNlck5vZGUuaGFuZGxlcykge1xuICAgICAgICBjb25zdCBoYW5kbGVCb3VuZHMgPSB7XG4gICAgICAgICAgICBpZDogaGFuZGxlLmlkLFxuICAgICAgICAgICAgd2lkdGg6IGhhbmRsZS53aWR0aCA/PyAxLFxuICAgICAgICAgICAgaGVpZ2h0OiBoYW5kbGUuaGVpZ2h0ID8/IDEsXG4gICAgICAgICAgICBub2RlSWQ6IHVzZXJOb2RlLmlkLFxuICAgICAgICAgICAgeDogaGFuZGxlLngsXG4gICAgICAgICAgICB5OiBoYW5kbGUueSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUucG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlOiBoYW5kbGUudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhbmRsZS50eXBlID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgc291cmNlLnB1c2goaGFuZGxlQm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGUudHlwZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGhhbmRsZUJvdW5kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgbm9kZXNJbml0aWFsaXplZCA9IG5vZGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdG1wTG9va3VwID0gbmV3IE1hcChub2RlTG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gX29wdGlvbnM/LmVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gMTAwMCA6IDA7XG4gICAgbm9kZUxvb2t1cC5jbGVhcigpO1xuICAgIHBhcmVudExvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgdXNlck5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbGV0IGludGVybmFsTm9kZSA9IHRtcExvb2t1cC5nZXQodXNlck5vZGUuaWQpO1xuICAgICAgICBpZiAoX29wdGlvbnMuY2hlY2tFcXVhbGl0eSAmJiB1c2VyTm9kZSA9PT0gaW50ZXJuYWxOb2RlPy5pbnRlcm5hbHMudXNlck5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbih1c2VyTm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQodXNlck5vZGUuZXh0ZW50KSA/IHVzZXJOb2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyh1c2VyTm9kZSkpO1xuICAgICAgICAgICAgaW50ZXJuYWxOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9vcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLnVzZXJOb2RlLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB1c2VyTm9kZS5tZWFzdXJlZD8ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdXNlck5vZGUubWVhc3VyZWQ/LmhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBjbGFtcGVkUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgcmUtaW5pdGlhbGl6ZXMgdGhlIG5vZGUgb3IgcmVtb3ZlcyBgbWVhc3VyZWRgIGZvciB3aGF0ZXZlciByZWFzb24sIHdlIHJlc2V0IHRoZSBoYW5kbGVCb3VuZHMgc28gdGhhdCB0aGUgbm9kZSBnZXRzIHJlLW1lYXN1cmVkXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogcGFyc2VIYW5kbGVzKHVzZXJOb2RlLCBpbnRlcm5hbE5vZGUpLFxuICAgICAgICAgICAgICAgICAgICB6OiBjYWxjdWxhdGVaKHVzZXJOb2RlLCBzZWxlY3RlZE5vZGVaKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlck5vZGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldCh1c2VyTm9kZS5pZCwgaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGludGVybmFsTm9kZS5tZWFzdXJlZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUubWVhc3VyZWQud2lkdGggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaW50ZXJuYWxOb2RlLm1lYXN1cmVkLmhlaWdodCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgIWludGVybmFsTm9kZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIG5vZGVzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlck5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShpbnRlcm5hbE5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzSW5pdGlhbGl6ZWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHBhcmVudExvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnRMb29rdXAuc2V0KG5vZGUucGFyZW50SWQsIG5ldyBNYXAoW1tub2RlLmlkLCBub2RlXV0pKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZXMgcG9zaXRpb25BYnNvbHV0ZSBhbmQgekluZGV4IG9mIGEgY2hpbGQgbm9kZSBhbmQgdGhlIHBhcmVudExvb2t1cC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFyZW50IG5vZGUgJHtwYXJlbnRJZH0gbm90IGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgcGFyZW50IG5vZGVzIGFyZSBpbiBmcm9udCBvZiB0aGVpciBjaGlsZCBub2RlcyBpbiB0aGUgbm9kZXMgYXJyYXkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlWiA9IGVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gMTAwMCA6IDA7XG4gICAgY29uc3QgeyB4LCB5LCB6IH0gPSBjYWxjdWxhdGVDaGlsZFhZWihub2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaKTtcbiAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHggIT09IHBvc2l0aW9uQWJzb2x1dGUueCB8fCB5ICE9PSBwb3NpdGlvbkFic29sdXRlLnk7XG4gICAgaWYgKHBvc2l0aW9uQ2hhbmdlZCB8fCB6ICE9PSBub2RlLmludGVybmFscy56KSB7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gbWFyayB0aGUgbm9kZSBhcyB1cGRhdGVkXG4gICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBwb3NpdGlvbkNoYW5nZWQgPyB7IHgsIHkgfSA6IHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVoobm9kZSwgc2VsZWN0ZWROb2RlWikge1xuICAgIHJldHVybiAoaXNOdW1lcmljKG5vZGUuekluZGV4KSA/IG5vZGUuekluZGV4IDogMCkgKyAobm9kZS5zZWxlY3RlZCA/IHNlbGVjdGVkTm9kZVogOiAwKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoaWxkWFlaKGNoaWxkTm9kZSwgcGFyZW50Tm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgc2VsZWN0ZWROb2RlWikge1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICBjb25zdCBjaGlsZERpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhjaGlsZE5vZGUpO1xuICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4oY2hpbGROb2RlLCBub2RlT3JpZ2luKTtcbiAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBpc0Nvb3JkaW5hdGVFeHRlbnQoY2hpbGROb2RlLmV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgY2hpbGROb2RlLmV4dGVudCwgY2hpbGREaW1lbnNpb25zKVxuICAgICAgICA6IHBvc2l0aW9uV2l0aE9yaWdpbjtcbiAgICBsZXQgYWJzb2x1dGVQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24oeyB4OiBwYXJlbnRYICsgY2xhbXBlZFBvc2l0aW9uLngsIHk6IHBhcmVudFkgKyBjbGFtcGVkUG9zaXRpb24ueSB9LCBub2RlRXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpO1xuICAgIGlmIChjaGlsZE5vZGUuZXh0ZW50ID09PSAncGFyZW50Jykge1xuICAgICAgICBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KGFic29sdXRlUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50Tm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkWiA9IGNhbGN1bGF0ZVooY2hpbGROb2RlLCBzZWxlY3RlZE5vZGVaKTtcbiAgICBjb25zdCBwYXJlbnRaID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMueiA/PyAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGFic29sdXRlUG9zaXRpb24ueCxcbiAgICAgICAgeTogYWJzb2x1dGVQb3NpdGlvbi55LFxuICAgICAgICB6OiBwYXJlbnRaID49IGNoaWxkWiA/IHBhcmVudFogKyAxIDogY2hpbGRaLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVFeHBhbmRQYXJlbnQoY2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBwYXJlbnRFeHBhbnNpb25zID0gbmV3IE1hcCgpO1xuICAgIC8vIGRldGVybWluZSB0aGUgZXhwYW5kZWQgcmVjdGFuZ2xlIHRoZSBjaGlsZCBub2RlcyB3b3VsZCB0YWtlIGZvciBlYWNoIHBhcmVudFxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQoY2hpbGQucGFyZW50SWQpO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudEV4cGFuc2lvbnMuZ2V0KGNoaWxkLnBhcmVudElkKT8uZXhwYW5kZWRSZWN0ID8/IG5vZGVUb1JlY3QocGFyZW50KTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRSZWN0ID0gZ2V0Qm91bmRzT2ZSZWN0cyhwYXJlbnRSZWN0LCBjaGlsZC5yZWN0KTtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5zZXQoY2hpbGQucGFyZW50SWQsIHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbnNpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuZm9yRWFjaCgoeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9LCBwYXJlbnRJZCkgPT4ge1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiAmIGRpbWVuc2lvbnMgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBwYXJlbnQgZXhwYW5kcyBpbiB3aWR0aCBhbmQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSBleHBhbmRlZFJlY3QueCA8IHBvc2l0aW9uQWJzb2x1dGUueCA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS54IC0gZXhwYW5kZWRSZWN0LngpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnkgPCBwb3NpdGlvbkFic29sdXRlLnkgPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueSAtIGV4cGFuZGVkUmVjdC55KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoLCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC53aWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoZGltZW5zaW9ucy5oZWlnaHQsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LmhlaWdodCkpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhDaGFuZ2UgPSAobmV3V2lkdGggLSBkaW1lbnNpb25zLndpZHRoKSAqIG9yaWdpblswXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodENoYW5nZSA9IChuZXdIZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodCkgKiBvcmlnaW5bMV07XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKHhDaGFuZ2UgPiAwIHx8IHlDaGFuZ2UgPiAwIHx8IHdpZHRoQ2hhbmdlIHx8IGhlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBhcmVudC5wb3NpdGlvbi54IC0geENoYW5nZSArIHdpZHRoQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcGFyZW50LnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgaGVpZ2h0Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2UgbW92ZSBhbGwgY2hpbGQgbm9kZXMgaW4gdGhlIG9wcHNpdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICogc28gdGhlIHgseSBjaGFuZ2VzIG9mIHRoZSBwYXJlbnQgZG8gbm90IG1vdmUgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcGFyZW50TG9va3VwLmdldChwYXJlbnRJZCk/LmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC5pZCA9PT0gY2hpbGROb2RlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGROb2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggKyB4Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGlsZE5vZGUucG9zaXRpb24ueSArIHlDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHBhcmVudCBub2RlIGlmIHRoZSBvcmlnaW4gaXMgbm90IFswLDBdXG4gICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IGV4cGFuZGVkUmVjdC53aWR0aCB8fCBkaW1lbnNpb25zLmhlaWdodCA8IGV4cGFuZGVkUmVjdC5oZWlnaHQgfHwgeENoYW5nZSB8fCB5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCArICh4Q2hhbmdlID8gb3JpZ2luWzBdICogeENoYW5nZSAtIHdpZHRoQ2hhbmdlIDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodCArICh5Q2hhbmdlID8gb3JpZ2luWzFdICogeUNoYW5nZSAtIGhlaWdodENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgZG9tTm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCkge1xuICAgIGNvbnN0IHZpZXdwb3J0Tm9kZSA9IGRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy54eWZsb3dfX3ZpZXdwb3J0Jyk7XG4gICAgbGV0IHVwZGF0ZWRJbnRlcm5hbHMgPSBmYWxzZTtcbiAgICBpZiAoIXZpZXdwb3J0Tm9kZSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbXSwgdXBkYXRlZEludGVybmFscyB9O1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3cG9ydE5vZGUpO1xuICAgIGNvbnN0IHsgbTIyOiB6b29tIH0gPSBuZXcgd2luZG93LkRPTU1hdHJpeFJlYWRPbmx5KHN0eWxlLnRyYW5zZm9ybSk7XG4gICAgLy8gaW4gdGhpcyBhcnJheSB3ZSBjb2xsZWN0IG5vZGVzLCB0aGF0IG1pZ2h0IHRyaWdnZXIgY2hhbmdlcyAobGlrZSBleHBhbmRpbmcgcGFyZW50KVxuICAgIGNvbnN0IHBhcmVudEV4cGFuZENoaWxkcmVuID0gW107XG4gICAgZm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQodXBkYXRlLmlkKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXBkYXRlZEludGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh1cGRhdGUubm9kZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2VkID0gbm9kZS5tZWFzdXJlZC53aWR0aCAhPT0gZGltZW5zaW9ucy53aWR0aCB8fCBub2RlLm1lYXN1cmVkLmhlaWdodCAhPT0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGRvVXBkYXRlID0gISEoZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgJiZcbiAgICAgICAgICAgIChkaW1lbnNpb25DaGFuZ2VkIHx8ICFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdXBkYXRlLmZvcmNlKSk7XG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUJvdW5kcyA9IHVwZGF0ZS5ub2RlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IG5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBsZXQgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBub2RlLmludGVybmFscztcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50Jykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQocG9zaXRpb25BYnNvbHV0ZSwgZGltZW5zaW9ucywgbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25BYnNvbHV0ZSwgZXh0ZW50LCBkaW1lbnNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlZDogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBnZXRIYW5kbGVCb3VuZHMoJ3NvdXJjZScsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldEhhbmRsZUJvdW5kcygndGFyZ2V0JywgdXBkYXRlLm5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIG5ld05vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZE5vZGUobmV3Tm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVkSW50ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFeHBhbmRDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiBub2RlVG9SZWN0KG5ld05vZGUsIG5vZGVPcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmVudEV4cGFuZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hhbmdlcyA9IGhhbmRsZUV4cGFuZFBhcmVudChwYXJlbnRFeHBhbmRDaGlsZHJlbiwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgIH1cbiAgICByZXR1cm4geyBjaGFuZ2VzLCB1cGRhdGVkSW50ZXJuYWxzIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYW5CeSh7IGRlbHRhLCBwYW5ab29tLCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCwgfSkge1xuICAgIGlmICghcGFuWm9vbSB8fCAoIWRlbHRhLnggJiYgIWRlbHRhLnkpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Vmlld3BvcnQgPSBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gKyBkZWx0YS54LFxuICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gKyBkZWx0YS55LFxuICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgfSwgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICBdLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IHRyYW5zZm9ybUNoYW5nZWQgPSAhIW5leHRWaWV3cG9ydCAmJlxuICAgICAgICAobmV4dFZpZXdwb3J0LnggIT09IHRyYW5zZm9ybVswXSB8fCBuZXh0Vmlld3BvcnQueSAhPT0gdHJhbnNmb3JtWzFdIHx8IG5leHRWaWV3cG9ydC5rICE9PSB0cmFuc2Zvcm1bMl0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJhbnNmb3JtQ2hhbmdlZCk7XG59XG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gYWRkcyB0aGUgY29ubmVjdGlvbiB0byB0aGUgY29ubmVjdGlvbkxvb2t1cFxuICogYXQgdGhlIGZvbGxvd2luZyBrZXlzOiBub2RlSWQtdHlwZS1oYW5kbGVJZCwgbm9kZUlkLXR5cGUgYW5kIG5vZGVJZFxuICogQHBhcmFtIHR5cGUgdHlwZSBvZiB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIGNvbm5lY3Rpb24gY29ubmVjdGlvbiB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbG9va3VwXG4gKiBAcGFyYW0gY29ubmVjdGlvbktleSBhdCB3aGljaCBrZXkgdGhlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGFkZGVkXG4gKiBAcGFyYW0gY29ubmVjdGlvbkxvb2t1cCByZWZlcmVuY2UgdG8gdGhlIGNvbm5lY3Rpb24gbG9va3VwXG4gKiBAcGFyYW0gbm9kZUlkIG5vZGVJZCBvZiB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIGhhbmRsZUlkIGhhbmRsZUlkIG9mIHRoZSBjb25uZWNpdG9uXG4gKi9cbmZ1bmN0aW9uIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCh0eXBlLCBjb25uZWN0aW9uLCBjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uTG9va3VwLCBub2RlSWQsIGhhbmRsZUlkKSB7XG4gICAgLypcbiAgICAgKiBXZSBhZGQgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbm5lY3Rpb25Mb29rdXAgYXQgdGhlIGZvbGxvd2luZyBrZXlzXG4gICAgICogMS4gbm9kZUlkLCAyLiBub2RlSWQtdHlwZSwgMy4gbm9kZUlkLXR5cGUtaGFuZGxlSWRcbiAgICAgKiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzLCB3ZSBhZGQgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGV4aXN0aW5nIG1hcFxuICAgICAqL1xuICAgIGxldCBrZXkgPSBub2RlSWQ7XG4gICAgY29uc3Qgbm9kZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgbm9kZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIGtleSA9IGAke25vZGVJZH0tJHt0eXBlfWA7XG4gICAgY29uc3QgdHlwZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgdHlwZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIGlmIChoYW5kbGVJZCkge1xuICAgICAgICBrZXkgPSBgJHtub2RlSWR9LSR7dHlwZX0tJHtoYW5kbGVJZH1gO1xuICAgICAgICBjb25zdCBoYW5kbGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCBoYW5kbGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIGVkZ2VzKSB7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5jbGVhcigpO1xuICAgIGVkZ2VMb29rdXAuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2U6IHNvdXJjZU5vZGUsIHRhcmdldDogdGFyZ2V0Tm9kZSwgc291cmNlSGFuZGxlID0gbnVsbCwgdGFyZ2V0SGFuZGxlID0gbnVsbCB9ID0gZWRnZTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHsgZWRnZUlkOiBlZGdlLmlkLCBzb3VyY2U6IHNvdXJjZU5vZGUsIHRhcmdldDogdGFyZ2V0Tm9kZSwgc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGUgfTtcbiAgICAgICAgY29uc3Qgc291cmNlS2V5ID0gYCR7c291cmNlTm9kZX0tJHtzb3VyY2VIYW5kbGV9LS0ke3RhcmdldE5vZGV9LSR7dGFyZ2V0SGFuZGxlfWA7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGAke3RhcmdldE5vZGV9LSR7dGFyZ2V0SGFuZGxlfS0tJHtzb3VyY2VOb2RlfS0ke3NvdXJjZUhhbmRsZX1gO1xuICAgICAgICBhZGRDb25uZWN0aW9uVG9Mb29rdXAoJ3NvdXJjZScsIGNvbm5lY3Rpb24sIHRhcmdldEtleSwgY29ubmVjdGlvbkxvb2t1cCwgc291cmNlTm9kZSwgc291cmNlSGFuZGxlKTtcbiAgICAgICAgYWRkQ29ubmVjdGlvblRvTG9va3VwKCd0YXJnZXQnLCBjb25uZWN0aW9uLCBzb3VyY2VLZXksIGNvbm5lY3Rpb25Mb29rdXAsIHRhcmdldE5vZGUsIHRhcmdldEhhbmRsZSk7XG4gICAgICAgIGVkZ2VMb29rdXAuc2V0KGVkZ2UuaWQsIGVkZ2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hhbGxvd05vZGVEYXRhKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgX2EgPSBBcnJheS5pc0FycmF5KGEpID8gYSA6IFthXTtcbiAgICBjb25zdCBfYiA9IEFycmF5LmlzQXJyYXkoYikgPyBiIDogW2JdO1xuICAgIGlmIChfYS5sZW5ndGggIT09IF9iLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKF9hW2ldLmlkICE9PSBfYltpXS5pZCB8fCBfYVtpXS50eXBlICE9PSBfYltpXS50eXBlIHx8ICFPYmplY3QuaXMoX2FbaV0uZGF0YSwgX2JbaV0uZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRTZWxlY3RlZChub2RlLCBub2RlTG9va3VwKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudElkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNQYXJlbnRTZWxlY3RlZChwYXJlbnROb2RlLCBub2RlTG9va3VwKTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdG9yKHRhcmdldCwgc2VsZWN0b3IsIGRvbU5vZGUpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChjdXJyZW50Py5tYXRjaGVzPy4oc2VsZWN0b3IpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBkb21Ob2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudD8ucGFyZW50RWxlbWVudDtcbiAgICB9IHdoaWxlIChjdXJyZW50KTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBsb29rcyBmb3IgYWxsIHNlbGVjdGVkIG5vZGVzIGFuZCBjcmVhdGVkIGEgTm9kZURyYWdJdGVtIGZvciBlYWNoIG9mIHRoZW1cbmZ1bmN0aW9uIGdldERyYWdJdGVtcyhub2RlTG9va3VwLCBub2Rlc0RyYWdnYWJsZSwgbW91c2VQb3MsIG5vZGVJZCkge1xuICAgIGNvbnN0IGRyYWdJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgbm9kZV0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAoKG5vZGUuc2VsZWN0ZWQgfHwgbm9kZS5pZCA9PT0gbm9kZUlkKSAmJlxuICAgICAgICAgICAgKCFub2RlLnBhcmVudElkIHx8ICFpc1BhcmVudFNlbGVjdGVkKG5vZGUsIG5vZGVMb29rdXApKSAmJlxuICAgICAgICAgICAgKG5vZGUuZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbm9kZS5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbXMuc2V0KGlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW50ZXJuYWxOb2RlLnBvc2l0aW9uIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbW91c2VQb3MueCAtIGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbW91c2VQb3MueSAtIGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBleHRlbnQ6IGludGVybmFsTm9kZS5leHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBpbnRlcm5hbE5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaW50ZXJuYWxOb2RlLm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kUGFyZW50OiBpbnRlcm5hbE5vZGUuZXhwYW5kUGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbnRlcm5hbE5vZGUubWVhc3VyZWQud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW50ZXJuYWxOb2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkcmFnSXRlbXM7XG59XG4vKlxuICogcmV0dXJucyB0d28gcGFyYW1zOlxuICogMS4gdGhlIGRyYWdnZWQgbm9kZSAob3IgdGhlIGZpcnN0IG9mIHRoZSBsaXN0LCBpZiB3ZSBhcmUgZHJhZ2dpbmcgYSBub2RlIHNlbGVjdGlvbilcbiAqIDIuIGFycmF5IG9mIHNlbGVjdGVkIG5vZGVzIChmb3IgbXVsdGkgc2VsZWN0aW9ucylcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHsgbm9kZUlkLCBkcmFnSXRlbXMsIG5vZGVMb29rdXAsIGRyYWdnaW5nID0gdHJ1ZSwgfSkge1xuICAgIGNvbnN0IG5vZGVzRnJvbURyYWdJdGVtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2YgZHJhZ0l0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk/LmludGVybmFscy51c2VyTm9kZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzRnJvbURyYWdJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkcmFnSXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBbbm9kZXNGcm9tRHJhZ0l0ZW1zWzBdLCBub2Rlc0Zyb21EcmFnSXRlbXNdO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgIHJldHVybiBbXG4gICAgICAgICFub2RlXG4gICAgICAgICAgICA/IG5vZGVzRnJvbURyYWdJdGVtc1swXVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW1zLmdldChub2RlSWQpPy5wb3NpdGlvbiB8fCBub2RlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgbm9kZXNGcm9tRHJhZ0l0ZW1zLFxuICAgIF07XG59XG4vKipcbiAqIElmIGEgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQgd2Ugd2FudCB0byBhcHBseSB0aGUgc2FtZSBzbmFwIG9mZnNldCB0byBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc25hcCBvZmZzZXQgYmFzZWQgb24gdGhlIGZpcnN0IG5vZGUgaW4gdGhlIHNlbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU25hcE9mZnNldCh7IGRyYWdJdGVtcywgc25hcEdyaWQsIHgsIHksIH0pIHtcbiAgICBjb25zdCByZWZEcmFnSXRlbSA9IGRyYWdJdGVtcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgaWYgKCFyZWZEcmFnSXRlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmUG9zID0ge1xuICAgICAgICB4OiB4IC0gcmVmRHJhZ0l0ZW0uZGlzdGFuY2UueCxcbiAgICAgICAgeTogeSAtIHJlZkRyYWdJdGVtLmRpc3RhbmNlLnksXG4gICAgfTtcbiAgICBjb25zdCByZWZQb3NTbmFwcGVkID0gc25hcFBvc2l0aW9uKHJlZlBvcywgc25hcEdyaWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJlZlBvc1NuYXBwZWQueCAtIHJlZlBvcy54LFxuICAgICAgICB5OiByZWZQb3NTbmFwcGVkLnkgLSByZWZQb3MueSxcbiAgICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gWFlEcmFnKHsgb25Ob2RlTW91c2VEb3duLCBnZXRTdG9yZUl0ZW1zLCBvbkRyYWdTdGFydCwgb25EcmFnLCBvbkRyYWdTdG9wLCB9KSB7XG4gICAgbGV0IGxhc3RQb3MgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBtb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG4gICAgbGV0IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGQzU2VsZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgYWJvcnREcmFnID0gZmFsc2U7IC8vIHByZXZlbnRzIHVuaW50ZW50aW9uYWwgZHJhZ2dpbmcgb24gbXVsdGl0b3VjaFxuICAgIGxldCBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgIC8vIHdlIHN0b3JlIHRoZSBsYXN0IGRyYWcgZXZlbnQgdG8gYmUgYWJsZSB0byB1c2UgaXQgaW4gdGhlIHVwZGF0ZSBmdW5jdGlvblxuICAgIGxldCBkcmFnRXZlbnQgPSBudWxsO1xuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlLCBpc1NlbGVjdGFibGUsIG5vZGVJZCwgbm9kZUNsaWNrRGlzdGFuY2UgPSAwLCB9KSB7XG4gICAgICAgIGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOb2Rlcyh7IHgsIHkgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHsgeCwgeSB9O1xuICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgaXNNdWx0aURyYWcgPSBkcmFnSXRlbXMuc2l6ZSA+IDE7XG4gICAgICAgICAgICBjb25zdCBub2Rlc0JveCA9IGlzTXVsdGlEcmFnICYmIG5vZGVFeHRlbnQgPyByZWN0VG9Cb3goZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhkcmFnSXRlbXMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBtdWx0aURyYWdTbmFwT2Zmc2V0ID0gaXNNdWx0aURyYWcgJiYgc25hcFRvR3JpZFxuICAgICAgICAgICAgICAgID8gY2FsY3VsYXRlU25hcE9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogaWYgdGhlIG5vZGUgaXMgbm90IGluIHRoZSBub2RlTG9va3VwIGFueW1vcmUsIGl0IHdhcyBwcm9iYWJseSBkZWxldGVkIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7IHg6IHggLSBkcmFnSXRlbS5kaXN0YW5jZS54LCB5OiB5IC0gZHJhZ0l0ZW0uZGlzdGFuY2UueSB9O1xuICAgICAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IG11bHRpRHJhZ1NuYXBPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnggKyBtdWx0aURyYWdTbmFwT2Zmc2V0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobmV4dFBvc2l0aW9uLnkgKyBtdWx0aURyYWdTbmFwT2Zmc2V0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc011bHRpRHJhZyAmJiBub2RlRXh0ZW50ICYmICFkcmFnSXRlbS5leHRlbnQgJiYgbm9kZXNCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBkcmFnSXRlbS5pbnRlcm5hbHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gcG9zaXRpb25BYnNvbHV0ZS54IC0gbm9kZXNCb3gueCArIG5vZGVFeHRlbnRbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gcG9zaXRpb25BYnNvbHV0ZS54ICsgZHJhZ0l0ZW0ubWVhc3VyZWQud2lkdGggLSBub2Rlc0JveC54MiArIG5vZGVFeHRlbnRbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gcG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gcG9zaXRpb25BYnNvbHV0ZS55ICsgZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0IC0gbm9kZXNCb3gueTIgKyBub2RlRXh0ZW50WzFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbeDEsIHkxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MiwgeTJdLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IGFkanVzdGVkTm9kZUV4dGVudCA/IGFkanVzdGVkTm9kZUV4dGVudCA6IG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBvbmx5IGZpcmUgYSBjaGFuZ2UgZXZlbnQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZVxuICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IGhhc0NoYW5nZSB8fCBkcmFnSXRlbS5wb3NpdGlvbi54ICE9PSBwb3NpdGlvbi54IHx8IGRyYWdJdGVtLnBvc2l0aW9uLnkgIT09IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IG5vZGVQb3NpdGlvbnNDaGFuZ2VkIHx8IGhhc0NoYW5nZTtcbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGRyYWdFdmVudCAmJiAob25EcmFnIHx8IG9uTm9kZURyYWcgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkRyYWc/LihkcmFnRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZz8uKGRyYWdFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGFuQnksIGF1dG9QYW5TcGVlZCwgYXV0b1Bhbk9uTm9kZURyYWcgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGlmICghYXV0b1Bhbk9uTm9kZURyYWcpIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3hNb3ZlbWVudCwgeU1vdmVtZW50XSA9IGNhbGNBdXRvUGFuKG1vdXNlUG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgICAgIGlmICh4TW92ZW1lbnQgIT09IDAgfHwgeU1vdmVtZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy54ID0gKGxhc3RQb3MueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnkgPSAobGFzdFBvcy55ID8/IDApIC0geU1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKGxhc3RQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBzZWxlY3ROb2Rlc09uRHJhZywgb25Ob2RlRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdGFydCwgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzU2VsZWN0YWJsZSkgJiYgIW11bHRpU2VsZWN0aW9uQWN0aXZlICYmIG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5nZXQobm9kZUlkKT8uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgc2VsZWN0Tm9kZXNPbkRyYWcgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duPy4obm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBkcmFnSXRlbXMgPSBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwICYmIChvbkRyYWdTdGFydCB8fCBvbk5vZGVEcmFnU3RhcnQgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQzRHJhZ0luc3RhbmNlID0gZHJhZygpXG4gICAgICAgICAgICAuY2xpY2tEaXN0YW5jZShub2RlQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGw7XG4gICAgICAgICAgICBhYm9ydERyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkcmFnRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgbW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uTm9kZURyYWcsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBub2RlTG9va3VwIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGRyYWdFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2htb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHx8XG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkZWxldGVzIGEgbm9kZSB3aGlsZSBkcmFnZ2luZywgd2UgbmVlZCB0byBhYm9ydCB0aGUgZHJhZyB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgICAgICAgICAgIChub2RlSWQgJiYgIW5vZGVMb29rdXAuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICAgICAgYWJvcnREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkICYmIGF1dG9QYW5Pbk5vZGVEcmFnICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgaW4gY2xpZW50IGNvb3JkaW5hdGVzIGZvciBjb25zaXN0ZW50IGRyYWcgdGhyZXNob2xkIGJlaGF2aW9yIGFjcm9zcyB6b29tIGxldmVsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gY3VycmVudE1vdXNlUG9zaXRpb24ueCAtIG1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gY3VycmVudE1vdXNlUG9zaXRpb24ueSAtIG1vdXNlUG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBub2RlRHJhZ1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWcoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgZXZlbnRzIHdpdGhvdXQgbW92ZW1lbnRcbiAgICAgICAgICAgIGlmICgobGFzdFBvcy54ICE9PSBwb2ludGVyUG9zLnhTbmFwcGVkIHx8IGxhc3RQb3MueSAhPT0gcG9pbnRlclBvcy55U25hcHBlZCkgJiYgZHJhZ0l0ZW1zICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgbW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZXMocG9pbnRlclBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCB8fCBhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnU3RvcCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlUG9zaXRpb25zQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKGRyYWdJdGVtcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25EcmFnU3RvcCB8fCBvbk5vZGVEcmFnU3RvcCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhZXZlbnQuYnV0dG9uICYmXG4gICAgICAgICAgICAgICAgKCFub0RyYWdDbGFzc05hbWUgfHwgIWhhc1NlbGVjdG9yKHRhcmdldCwgYC4ke25vRHJhZ0NsYXNzTmFtZX1gLCBkb21Ob2RlKSkgJiZcbiAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIGRvbU5vZGUpKTtcbiAgICAgICAgICAgIHJldHVybiBpc0RyYWdnYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLmNhbGwoZDNEcmFnSW5zdGFuY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1NlbGVjdGlvbj8ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgeDogcG9zaXRpb24ueCAtIGRpc3RhbmNlLFxuICAgICAgICB5OiBwb3NpdGlvbi55IC0gZGlzdGFuY2UsXG4gICAgICAgIHdpZHRoOiBkaXN0YW5jZSAqIDIsXG4gICAgICAgIGhlaWdodDogZGlzdGFuY2UgKiAyLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGdldE92ZXJsYXBwaW5nQXJlYShyZWN0LCBub2RlVG9SZWN0KG5vZGUpKSA+IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuLypcbiAqIHRoaXMgZGlzdGFuY2UgaXMgdXNlZCBmb3IgdGhlIGFyZWEgYXJvdW5kIHRoZSB1c2VyIHBvaW50ZXJcbiAqIHdoaWxlIGRvaW5nIGEgY29ubmVjdGlvbiBmb3IgZmluZGluZyB0aGUgY2xvc2VzdCBub2Rlc1xuICovXG5jb25zdCBBRERJVElPTkFMX0RJU1RBTkNFID0gMjUwO1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShwb3NpdGlvbiwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSkge1xuICAgIGxldCBjbG9zZXN0SGFuZGxlcyA9IFtdO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGNsb3NlTm9kZXMgPSBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBjb25uZWN0aW9uUmFkaXVzICsgQURESVRJT05BTF9ESVNUQU5DRSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGNsb3NlTm9kZXMpIHtcbiAgICAgICAgY29uc3QgYWxsSGFuZGxlcyA9IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGUgb2YgYWxsSGFuZGxlcykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhhbmRsZSBpcyB0aGUgc2FtZSBhcyB0aGUgZnJvbUhhbmRsZSB3ZSBza2lwIGl0XG4gICAgICAgICAgICBpZiAoZnJvbUhhbmRsZS5ub2RlSWQgPT09IGhhbmRsZS5ub2RlSWQgJiYgZnJvbUhhbmRsZS50eXBlID09PSBoYW5kbGUudHlwZSAmJiBmcm9tSGFuZGxlLmlkID09PSBoYW5kbGUuaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRldGVybWluZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgaGFuZGxlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHkgLSBwb3NpdGlvbi55LCAyKSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzID0gW3sgLi4uaGFuZGxlLCB4LCB5IH1dO1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgYXJlIG9uIHRoZSBzYW1lIGRpc3RhbmNlIHdlIGNvbGxlY3QgYWxsIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcy5wdXNoKHsgLi4uaGFuZGxlLCB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdEhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgb3ZlcmxheSBlYWNoIG90aGVyIHdlIHByZWZlciB0aGUgb3Bwb3NpdGUgaGFuZGxlXG4gICAgaWYgKGNsb3Nlc3RIYW5kbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgb3Bwb3NpdGVIYW5kbGVUeXBlID0gZnJvbUhhbmRsZS50eXBlID09PSAnc291cmNlJyA/ICd0YXJnZXQnIDogJ3NvdXJjZSc7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SGFuZGxlcy5maW5kKChoYW5kbGUpID0+IGhhbmRsZS50eXBlID09PSBvcHBvc2l0ZUhhbmRsZVR5cGUpID8/IGNsb3Nlc3RIYW5kbGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXNbMF07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHdpdGhBYnNvbHV0ZVBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXMgPSBjb25uZWN0aW9uTW9kZSA9PT0gJ3N0cmljdCdcbiAgICAgICAgPyBub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LltoYW5kbGVUeXBlXVxuICAgICAgICA6IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICBjb25zdCBoYW5kbGUgPSAoaGFuZGxlSWQgPyBoYW5kbGVzPy5maW5kKChoKSA9PiBoLmlkID09PSBoYW5kbGVJZCkgOiBoYW5kbGVzPy5bMF0pID8/IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZSAmJiB3aXRoQWJzb2x1dGVQb3NpdGlvblxuICAgICAgICA/IHsgLi4uaGFuZGxlLCAuLi5nZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSkgfVxuICAgICAgICA6IGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKSB7XG4gICAgaWYgKGVkZ2VVcGRhdGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gZWRnZVVwZGF0ZXJUeXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QuY29udGFpbnMoJ3RhcmdldCcpKSB7XG4gICAgICAgIHJldHVybiAndGFyZ2V0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3VyY2UnKSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNDb25uZWN0aW9uVmFsaWQoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzLCBpc0hhbmRsZVZhbGlkKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBudWxsO1xuICAgIGlmIChpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMgJiYgIWlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNWYWxpZDtcbn1cblxuY29uc3QgYWx3YXlzVmFsaWQgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgeyBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgaGFuZGxlSWQsIG5vZGVJZCwgZWRnZVVwZGF0ZXJUeXBlLCBpc1RhcmdldCwgZG9tTm9kZSwgbm9kZUxvb2t1cCwgbGliLCBhdXRvUGFuT25Db25uZWN0LCBmbG93SWQsIHBhbkJ5LCBjYW5jZWxDb25uZWN0aW9uLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0LCBvbkNvbm5lY3RFbmQsIGlzVmFsaWRDb25uZWN0aW9uID0gYWx3YXlzVmFsaWQsIG9uUmVjb25uZWN0RW5kLCB1cGRhdGVDb25uZWN0aW9uLCBnZXRUcmFuc2Zvcm0sIGdldEZyb21IYW5kbGUsIGF1dG9QYW5TcGVlZCwgZHJhZ1RocmVzaG9sZCA9IDEsIGhhbmRsZURvbU5vZGUsIH0pIHtcbiAgICAvLyB3aGVuIHh5ZmxvdyBpcyB1c2VkIGluc2lkZSBhIHNoYWRvdyByb290IHdlIGNhbid0IHVzZSBkb2N1bWVudFxuICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGNsb3Nlc3RIYW5kbGU7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZShlZGdlVXBkYXRlclR5cGUsIGhhbmRsZURvbU5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBjb25uZWN0aW9uU3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmICghY29udGFpbmVyQm91bmRzIHx8ICFoYW5kbGVUeXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJvbUhhbmRsZUludGVybmFsID0gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlKTtcbiAgICBpZiAoIWZyb21IYW5kbGVJbnRlcm5hbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgbGV0IGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdEhhbmRsZURvbU5vZGUgPSBudWxsO1xuICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgbW92aW5nIHRoZSBtb3VzZSBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzIHdoaWxlIGNvbm5lY3Rpbmcgd2UgbW92ZSB0aGUgY2FudmFzXG4gICAgZnVuY3Rpb24gYXV0b1BhbigpIHtcbiAgICAgICAgaWYgKCFhdXRvUGFuT25Db25uZWN0IHx8ICFjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbeCwgeV0gPSBjYWxjQXV0b1Bhbihwb3NpdGlvbiwgY29udGFpbmVyQm91bmRzLCBhdXRvUGFuU3BlZWQpO1xuICAgICAgICBwYW5CeSh7IHgsIHkgfSk7XG4gICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICB9XG4gICAgLy8gU3RheXMgdGhlIHNhbWUgZm9yIGFsbCBjb25zZWN1dGl2ZSBwb2ludGVybW92ZSBldmVudHNcbiAgICBjb25zdCBmcm9tSGFuZGxlID0ge1xuICAgICAgICAuLi5mcm9tSGFuZGxlSW50ZXJuYWwsXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgdHlwZTogaGFuZGxlVHlwZSxcbiAgICAgICAgcG9zaXRpb246IGZyb21IYW5kbGVJbnRlcm5hbC5wb3NpdGlvbixcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Ob2RlSW50ZXJuYWwgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgIGNvbnN0IGZyb20gPSBnZXRIYW5kbGVQb3NpdGlvbihmcm9tTm9kZUludGVybmFsLCBmcm9tSGFuZGxlLCBQb3NpdGlvbi5MZWZ0LCB0cnVlKTtcbiAgICBsZXQgcHJldmlvdXNDb25uZWN0aW9uID0ge1xuICAgICAgICBpblByb2dyZXNzOiB0cnVlLFxuICAgICAgICBpc1ZhbGlkOiBudWxsLFxuICAgICAgICBmcm9tLFxuICAgICAgICBmcm9tSGFuZGxlLFxuICAgICAgICBmcm9tUG9zaXRpb246IGZyb21IYW5kbGUucG9zaXRpb24sXG4gICAgICAgIGZyb21Ob2RlOiBmcm9tTm9kZUludGVybmFsLFxuICAgICAgICB0bzogcG9zaXRpb24sXG4gICAgICAgIHRvSGFuZGxlOiBudWxsLFxuICAgICAgICB0b1Bvc2l0aW9uOiBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21IYW5kbGUucG9zaXRpb25dLFxuICAgICAgICB0b05vZGU6IG51bGwsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBzdGFydENvbm5lY3Rpb24oKSB7XG4gICAgICAgIGNvbm5lY3Rpb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbihwcmV2aW91c0Nvbm5lY3Rpb24pO1xuICAgICAgICBvbkNvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGUgfSk7XG4gICAgfVxuICAgIGlmIChkcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Q29ubmVjdGlvbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICghY29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeDogZXZ0WCwgeTogZXZ0WSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgICAgICAgICBjb25zdCBkeCA9IGV2dFggLSB4O1xuICAgICAgICAgICAgY29uc3QgZHkgPSBldnRZIC0geTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDb25uZWN0aW9uU3RhcnRlZCA9IGR4ICogZHggKyBkeSAqIGR5ID4gZHJhZ1RocmVzaG9sZCAqIGRyYWdUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoIW5leHRDb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2V0RnJvbUhhbmRsZSgpIHx8ICFmcm9tSGFuZGxlKSB7XG4gICAgICAgICAgICBvblBvaW50ZXJVcChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgY2xvc2VzdEhhbmRsZSA9IGdldENsb3Nlc3RIYW5kbGUocG9pbnRUb1JlbmRlcmVyUG9pbnQocG9zaXRpb24sIHRyYW5zZm9ybSwgZmFsc2UsIFsxLCAxXSksIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpO1xuICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkKSB7XG4gICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXNWYWxpZEhhbmRsZShldmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiBjbG9zZXN0SGFuZGxlLFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBmcm9tTm9kZUlkOiBub2RlSWQsXG4gICAgICAgICAgICBmcm9tSGFuZGxlSWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGlzVGFyZ2V0ID8gJ3RhcmdldCcgOiAnc291cmNlJyxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdEhhbmRsZURvbU5vZGUgPSByZXN1bHQuaGFuZGxlRG9tTm9kZTtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlc3VsdC5jb25uZWN0aW9uO1xuICAgICAgICBpc1ZhbGlkID0gaXNDb25uZWN0aW9uVmFsaWQoISFjbG9zZXN0SGFuZGxlLCByZXN1bHQuaXNWYWxpZCk7XG4gICAgICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICAvLyBmcm9tIHN0YXlzIHRoZSBzYW1lXG4gICAgICAgICAgICAuLi5wcmV2aW91c0Nvbm5lY3Rpb24sXG4gICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgdG86IHJlc3VsdC50b0hhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IHJlc3VsdC50b0hhbmRsZS54LCB5OiByZXN1bHQudG9IYW5kbGUueSB9LCB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHRvSGFuZGxlOiByZXN1bHQudG9IYW5kbGUsXG4gICAgICAgICAgICB0b1Bvc2l0aW9uOiBpc1ZhbGlkICYmIHJlc3VsdC50b0hhbmRsZSA/IHJlc3VsdC50b0hhbmRsZS5wb3NpdGlvbiA6IG9wcG9zaXRlUG9zaXRpb25bZnJvbUhhbmRsZS5wb3NpdGlvbl0sXG4gICAgICAgICAgICB0b05vZGU6IHJlc3VsdC50b0hhbmRsZSA/IG5vZGVMb29rdXAuZ2V0KHJlc3VsdC50b0hhbmRsZS5ub2RlSWQpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgICogd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGFuIHVwZGF0ZSB3aGVuIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAqIGlzIHNuYXBwZWQgdG8gdGhlIHNhbWUgaGFuZGxlIGFzIGJlZm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzVmFsaWQgJiZcbiAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZSAmJlxuICAgICAgICAgICAgbmV3Q29ubmVjdGlvbi50b0hhbmRsZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUudHlwZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLm5vZGVJZCA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5pZCA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS5pZCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvLnggPT09IG5ld0Nvbm5lY3Rpb24udG8ueCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvLnkgPT09IG5ld0Nvbm5lY3Rpb24udG8ueSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24obmV3Q29ubmVjdGlvbik7XG4gICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgbXVsdGktdG91Y2ggYWJvcnRpbmcgY29ubmVjdGlvblxuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgaWYgKChjbG9zZXN0SGFuZGxlIHx8IHJlc3VsdEhhbmRsZURvbU5vZGUpICYmIGNvbm5lY3Rpb24gJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIG9uQ29ubmVjdD8uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGl0J3MgaW1wb3J0YW50IHRvIGdldCBhIGZyZXNoIHJlZmVyZW5jZSBmcm9tIHRoZSBzdG9yZSBoZXJlXG4gICAgICAgICAgICAgKiBpbiBvcmRlciB0byBnZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBvbkNvbm5lY3RFbmRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgeyBpblByb2dyZXNzLCAuLi5jb25uZWN0aW9uU3RhdGUgfSA9IHByZXZpb3VzQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29ubmVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b1Bvc2l0aW9uOiBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgPyBwcmV2aW91c0Nvbm5lY3Rpb24udG9Qb3NpdGlvbiA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25Db25uZWN0RW5kPy4oZXZlbnQsIGZpbmFsQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBvblJlY29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbigpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICByZXN1bHRIYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xufVxuLy8gY2hlY2tzIGlmICBhbmQgcmV0dXJucyBjb25uZWN0aW9uIGluIGZvbSBvZiBhbiBvYmplY3QgeyBzb3VyY2U6IDEyMywgdGFyZ2V0OiAzMTIgfVxuZnVuY3Rpb24gaXNWYWxpZEhhbmRsZShldmVudCwgeyBoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBmcm9tTm9kZUlkLCBmcm9tSGFuZGxlSWQsIGZyb21UeXBlLCBkb2MsIGxpYiwgZmxvd0lkLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBub2RlTG9va3VwLCB9KSB7XG4gICAgY29uc3QgaXNUYXJnZXQgPSBmcm9tVHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3QgaGFuZGxlRG9tTm9kZSA9IGhhbmRsZVxuICAgICAgICA/IGRvYy5xdWVyeVNlbGVjdG9yKGAuJHtsaWJ9LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtmbG93SWR9LSR7aGFuZGxlPy5ub2RlSWR9LSR7aGFuZGxlPy5pZH0tJHtoYW5kbGU/LnR5cGV9XCJdYClcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvKlxuICAgICAqIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgICAqIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZVRvQ2hlY2sgPSBoYW5kbGVCZWxvdz8uY2xhc3NMaXN0LmNvbnRhaW5zKGAke2xpYn0tZmxvd19faGFuZGxlYCkgPyBoYW5kbGVCZWxvdyA6IGhhbmRsZURvbU5vZGU7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVEb21Ob2RlOiBoYW5kbGVUb0NoZWNrLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvbjogbnVsbCxcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgfTtcbiAgICBpZiAoaGFuZGxlVG9DaGVjaykge1xuICAgICAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZSh1bmRlZmluZWQsIGhhbmRsZVRvQ2hlY2spO1xuICAgICAgICBjb25zdCBoYW5kbGVOb2RlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZScpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZUVuZCA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZWVuZCcpO1xuICAgICAgICBpZiAoIWhhbmRsZU5vZGVJZCB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgc291cmNlOiBpc1RhcmdldCA/IGhhbmRsZU5vZGVJZCA6IGZyb21Ob2RlSWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGlzVGFyZ2V0ID8gaGFuZGxlSWQgOiBmcm9tSGFuZGxlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0ID8gZnJvbU5vZGVJZCA6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogaXNUYXJnZXQgPyBmcm9tSGFuZGxlSWQgOiBoYW5kbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGUgJiYgY29ubmVjdGFibGVFbmQ7XG4gICAgICAgIC8vIGluIHN0cmljdCBtb2RlIHdlIGRvbid0IGFsbG93IHRhcmdldCB0byB0YXJnZXQgb3Igc291cmNlIHRvIHNvdXJjZSBjb25uZWN0aW9uc1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICA/IChpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAnc291cmNlJykgfHwgKCFpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAndGFyZ2V0JylcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU5vZGVJZCAhPT0gZnJvbU5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZUlkKTtcbiAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBpc1ZhbGlkICYmIGlzVmFsaWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICByZXN1bHQudG9IYW5kbGUgPSBnZXRIYW5kbGUoaGFuZGxlTm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgWFlIYW5kbGUgPSB7XG4gICAgb25Qb2ludGVyRG93bixcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkSGFuZGxlLFxufTtcblxuZnVuY3Rpb24gWFlNaW5pbWFwKHsgZG9tTm9kZSwgcGFuWm9vbSwgZ2V0VHJhbnNmb3JtLCBnZXRWaWV3U2NhbGUgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIHpvb21TdGVwID0gMSwgcGFubmFibGUgPSB0cnVlLCB6b29tYWJsZSA9IHRydWUsIGludmVyc2VQYW4gPSBmYWxzZSwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB6b29tSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgIT09ICd3aGVlbCcgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LnNvdXJjZUV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IC1ldmVudC5zb3VyY2VFdmVudC5kZWx0YVkgKlxuICAgICAgICAgICAgICAgIChldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqXG4gICAgICAgICAgICAgICAgem9vbVN0ZXA7XG4gICAgICAgICAgICBjb25zdCBuZXh0Wm9vbSA9IHRyYW5zZm9ybVsyXSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcGFuWm9vbS5zY2FsZVRvKG5leHRab29tKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBhblN0YXJ0ID0gWzAsIDBdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5TdGFydEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBwYW5TdGFydCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WCA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHBhbkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnbW91c2Vtb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAndG91Y2htb3ZlJykgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYW5DdXJyZW50ID0gW1xuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhbkRlbHRhID0gW3BhbkN1cnJlbnRbMF0gLSBwYW5TdGFydFswXSwgcGFuQ3VycmVudFsxXSAtIHBhblN0YXJ0WzFdXTtcbiAgICAgICAgICAgIHBhblN0YXJ0ID0gcGFuQ3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVTY2FsZSA9IGdldFZpZXdTY2FsZSgpICogTWF0aC5tYXgodHJhbnNmb3JtWzJdLCBNYXRoLmxvZyh0cmFuc2Zvcm1bMl0pKSAqIChpbnZlcnNlUGFuID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybVswXSAtIHBhbkRlbHRhWzBdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybVsxXSAtIHBhbkRlbHRhWzFdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgem9vbUFuZFBhbkhhbmRsZXIgPSB6b29tKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCBwYW5TdGFydEhhbmRsZXIpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAub24oJ3pvb20nLCBwYW5uYWJsZSA/IHBhbkhhbmRsZXIgOiBudWxsKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tLndoZWVsJywgem9vbWFibGUgPyB6b29tSGFuZGxlciA6IG51bGwpO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbCh6b29tQW5kUGFuSGFuZGxlciwge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJ3pvb20nLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBwb2ludGVyLFxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IHZpZXdDaGFuZ2VkID0gKHByZXZWaWV3cG9ydCwgZXZlbnRWaWV3cG9ydCkgPT4gcHJldlZpZXdwb3J0LnggIT09IGV2ZW50Vmlld3BvcnQueCB8fCBwcmV2Vmlld3BvcnQueSAhPT0gZXZlbnRWaWV3cG9ydC55IHx8IHByZXZWaWV3cG9ydC56b29tICE9PSBldmVudFZpZXdwb3J0Lms7XG5jb25zdCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0ID0gKHRyYW5zZm9ybSkgPT4gKHtcbiAgICB4OiB0cmFuc2Zvcm0ueCxcbiAgICB5OiB0cmFuc2Zvcm0ueSxcbiAgICB6b29tOiB0cmFuc2Zvcm0uayxcbn0pO1xuY29uc3Qgdmlld3BvcnRUb1RyYW5zZm9ybSA9ICh7IHgsIHksIHpvb20gfSkgPT4gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuLy8gdGFrZW4gZnJvbSBkMy1lYXNlOiBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZWFzZS9ibG9iL21haW4vc3JjL2N1YmljLmpzXG5jb25zdCBkZWZhdWx0RWFzZSA9ICh0KSA9PiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG5jb25zdCBnZXREM1RyYW5zaXRpb24gPSAoc2VsZWN0aW9uLCBkdXJhdGlvbiA9IDAsIGVhc2UgPSBkZWZhdWx0RWFzZSwgb25FbmQgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwO1xuICAgIGlmICghaGFzRHVyYXRpb24pIHtcbiAgICAgICAgb25FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gc2VsZWN0aW9uLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuZWFzZShlYXNlKS5vbignZW5kJywgb25FbmQpIDogc2VsZWN0aW9uO1xufTtcbmNvbnN0IHdoZWVsRGVsdGEgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBmYWN0b3IgPSBldmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIGZhY3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG5vV2hlZWxDbGFzc05hbWUsIGQzU2VsZWN0aW9uLCBkM1pvb20sIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgem9vbU9uUGluY2gsIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb20sIG9uUGFuWm9vbUVuZCwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gc3RvcCBuYXRpdmUgcGFnZSB6b29tIGZvciBwaW5jaCB6b29taW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpLmsgfHwgMTtcbiAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICogZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVsdGFOb3JtYWxpemUgPSBldmVudC5kZWx0YU1vZGUgPT09IDEgPyAyMCA6IDE7XG4gICAgICAgIGxldCBkZWx0YVggPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCA/IDAgOiBldmVudC5kZWx0YVggKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLkhvcml6b250YWwgPyAwIDogZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgIC8vIHRoaXMgZW5hYmxlcyB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2l0aCBzaGlmdCArIHNjcm9sbCBvbiB3aW5kb3dzXG4gICAgICAgIGlmICghaXNNYWNPcygpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykpO1xuICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICogd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICogYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmICghem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZykge1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucGFuU2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlWm9vbU9uU2Nyb2xsSGFuZGxlcih7IG5vV2hlZWxDbGFzc05hbWUsIHByZXZlbnRTY3JvbGxpbmcsIGQzWm9vbUhhbmRsZXIgfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGQpIHtcbiAgICAgICAgY29uc3QgaXNXaGVlbCA9IGV2ZW50LnR5cGUgPT09ICd3aGVlbCc7XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gZW5hYmxlIHBpbmNoIHpvb21pbmcgZXZlbiBpZiBwcmV2ZW50U2Nyb2xsaW5nIGlzIHNldCB0byBmYWxzZVxuICAgICAgICBjb25zdCBwcmV2ZW50Wm9vbSA9ICFwcmV2ZW50U2Nyb2xsaW5nICYmIGlzV2hlZWwgJiYgIWV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGNvbnN0IGhhc05vV2hlZWxDbGFzcyA9IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSk7XG4gICAgICAgIC8vIGlmIHVzZXIgaXMgcGluY2ggem9vbWluZyBhYm92ZSBhIG5vd2hlZWwgZWxlbWVudCwgd2UgZG9uJ3Qgd2FudCB0aGUgYnJvd3NlciB0byB6b29tXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGlzV2hlZWwgJiYgaGFzTm9XaGVlbENsYXNzKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50Wm9vbSB8fCBoYXNOb1doZWVsQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGQzWm9vbUhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCwgZCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21TdGFydEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21TdGFydCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaXQgaGVyZSwgYmVjYXVzZSBpdCdzIGFsd2F5cyAwIGluIHRoZSBcInpvb21cIiBldmVudFxuICAgICAgICB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID0gZXZlbnQuc291cmNlRXZlbnQ/LmJ1dHRvbiB8fCAwO1xuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IHRydWU7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8udHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbVN0YXJ0KSB7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIG9uUGFuZUNvbnRleHRNZW51LCBvblRyYW5zZm9ybUNoYW5nZSwgb25QYW5ab29tLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gISEob25QYW5lQ29udGV4dE1lbnUgJiYgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSk7XG4gICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQ/LnN5bmMpIHtcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlKFtldmVudC50cmFuc2Zvcm0ueCwgZXZlbnQudHJhbnNmb3JtLnksIGV2ZW50LnRyYW5zZm9ybS5rXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbSAmJiAhZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudC5zb3VyY2VFdmVudCwgdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbUVuZCwgb25QYW5lQ29udGV4dE1lbnUsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAob25QYW5lQ29udGV4dE1lbnUgJiZcbiAgICAgICAgICAgIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkgJiZcbiAgICAgICAgICAgICF6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uICYmXG4gICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUoZXZlbnQuc291cmNlRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgb25EcmFnZ2luZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIGlmIChvblBhblpvb21FbmQgJiYgdmlld0NoYW5nZWQoem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQsIGV2ZW50LnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnRpbWVySWQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNldFRpbWVvdXQgZm9yIHBhbk9uU2Nyb2xsIHRvIHN1cHJlc3MgbXVsdGlwbGUgZW5kIGV2ZW50cyBmaXJlZCBkdXJpbmcgc2Nyb2xsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCA/IDE1MCA6IDApO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKHsgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGxpYiwgY29ubmVjdGlvbkluUHJvZ3Jlc3MsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHpvb21TY3JvbGwgPSB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgfHwgem9vbU9uU2Nyb2xsO1xuICAgICAgICBjb25zdCBwaW5jaFpvb20gPSB6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5O1xuICAgICAgICBjb25zdCBpc1doZWVsRXZlbnQgPSBldmVudC50eXBlID09PSAnd2hlZWwnO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAxICYmXG4gICAgICAgICAgICBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyAmJlxuICAgICAgICAgICAgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19ub2RlYCkgfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBgJHtsaWJ9LWZsb3dfX2VkZ2VgKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFsbCBpbnRlcmFjdGlvbnMgYXJlIGRpc2FibGVkLCB3ZSBwcmV2ZW50IGFsbCB6b29tIGV2ZW50c1xuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAhem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXpvb21PbkRvdWJsZUNsaWNrICYmICF6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGR1cmluZyBhIHNlbGVjdGlvbiB3ZSBwcmV2ZW50IGFsbCBvdGhlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3YW50IHRvIGRpc2FibGUgcGluY2gtem9vbWluZyB3aGlsZSBtYWtpbmcgYSBjb25uZWN0aW9uXG4gICAgICAgIGlmIChjb25uZWN0aW9uSW5Qcm9ncmVzcyAmJiAhaXNXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vd2hlZWwgY2xhc3MsIHdlIHByZXZlbnQgem9vbWluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSAmJiBpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm9wYW4gY2xhc3MsIHdlIHByZXZlbnQgcGFubmluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1BhbkNsYXNzTmFtZSkgJiZcbiAgICAgICAgICAgICghaXNXaGVlbEV2ZW50IHx8IChwYW5PblNjcm9sbCAmJiBpc1doZWVsRXZlbnQgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5ICYmIGlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIGV2ZW50LnRvdWNoZXM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHlvdSBtYW5hZ2UgdG8gc3RhcnQgd2l0aCAyIHRvdWNoZXMsIHdlIHByZXZlbnQgbmF0aXZlIHpvb21cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHRoZXJlIGlzIG5vIHNjcm9sbCBoYW5kbGluZyBlbmFibGVkLCB3ZSBwcmV2ZW50IGFsbCB3aGVlbCBldmVudHNcbiAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG5vdCBtb3ZhYmxlLCB3ZSBwcmV2ZW50IGRyYWdnaW5nIGl0IHdpdGggbW91c2VzdGFydCBvciB0b3VjaHN0YXJ0XG4gICAgICAgIGlmICghcGFuT25EcmFnICYmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgb25seSBtb3ZhYmxlIHVzaW5nIGFsbG93ZWQgY2xpY2tzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgIXBhbk9uRHJhZy5pbmNsdWRlcyhldmVudC5idXR0b24pICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSBhbGxvdyByaWdodCBjbGlja3MgaWYgcGFuIG9uIGRyYWcgaXMgc2V0IHRvIHJpZ2h0IGNsaWNrXG4gICAgICAgIGNvbnN0IGJ1dHRvbkFsbG93ZWQgPSAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcyhldmVudC5idXR0b24pKSB8fCAhZXZlbnQuYnV0dG9uIHx8IGV2ZW50LmJ1dHRvbiA8PSAxO1xuICAgICAgICAvLyBkZWZhdWx0IGZpbHRlciBmb3IgZDMtem9vbVxuICAgICAgICByZXR1cm4gKCFldmVudC5jdHJsS2V5IHx8IGlzV2hlZWxFdmVudCkgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBYWVBhblpvb20oeyBkb21Ob2RlLCBtaW5ab29tLCBtYXhab29tLCBwYW5lQ2xpY2tEaXN0YW5jZSwgdHJhbnNsYXRlRXh0ZW50LCB2aWV3cG9ydCwgb25QYW5ab29tLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tRW5kLCBvbkRyYWdnaW5nQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgem9vbVBhblZhbHVlcyA9IHtcbiAgICAgICAgaXNab29taW5nT3JQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlZFJpZ2h0TW91c2VCdXR0b246IGZhbHNlLFxuICAgICAgICBwcmV2Vmlld3BvcnQ6IHsgeDogMCwgeTogMCwgem9vbTogMCB9LFxuICAgICAgICBtb3VzZUJ1dHRvbjogMCxcbiAgICAgICAgdGltZXJJZDogdW5kZWZpbmVkLFxuICAgICAgICBwYW5TY3JvbGxUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIGlzUGFuU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGJib3ggPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGQzWm9vbUluc3RhbmNlID0gem9vbSgpXG4gICAgICAgIC5jbGlja0Rpc3RhbmNlKCFpc051bWVyaWMocGFuZUNsaWNrRGlzdGFuY2UpIHx8IHBhbmVDbGlja0Rpc3RhbmNlIDwgMCA/IDAgOiBwYW5lQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgLnNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSlcbiAgICAgICAgLnRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpLmNhbGwoZDNab29tSW5zdGFuY2UpO1xuICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICB4OiB2aWV3cG9ydC54LFxuICAgICAgICB5OiB2aWV3cG9ydC55LFxuICAgICAgICB6b29tOiBjbGFtcCh2aWV3cG9ydC56b29tLCBtaW5ab29tLCBtYXhab29tKSxcbiAgICB9LCBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW2Jib3gud2lkdGgsIGJib3guaGVpZ2h0XSxcbiAgICBdLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IGQzWm9vbUhhbmRsZXIgPSBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScpO1xuICAgIGNvbnN0IGQzRGJsQ2xpY2tab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJyk7XG4gICAgZDNab29tSW5zdGFuY2Uud2hlZWxEZWx0YSh3aGVlbERlbHRhKTtcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0odHJhbnNmb3JtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LmludGVycG9sYXRlKG9wdGlvbnM/LmludGVycG9sYXRlID09PSAnbGluZWFyJyA/IGludGVycG9sYXRlIDogaW50ZXJwb2xhdGVab29tKS50cmFuc2Zvcm0oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgb3B0aW9ucz8uZWFzZSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblBhbmVDb250ZXh0TWVudSwgdXNlclNlbGVjdGlvbkFjdGl2ZSwgcGFuT25TY3JvbGwsIHBhbk9uRHJhZywgcGFuT25TY3JvbGxNb2RlLCBwYW5PblNjcm9sbFNwZWVkLCBwcmV2ZW50U2Nyb2xsaW5nLCB6b29tT25QaW5jaCwgem9vbU9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCBsaWIsIG9uVHJhbnNmb3JtQ2hhbmdlLCBjb25uZWN0aW9uSW5Qcm9ncmVzcywgfSkge1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSAmJiAhem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcpIHtcbiAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1Bhbk9uU2Nyb2xsID0gcGFuT25TY3JvbGwgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCAmJiAhdXNlclNlbGVjdGlvbkFjdGl2ZTtcbiAgICAgICAgY29uc3Qgd2hlZWxIYW5kbGVyID0gaXNQYW5PblNjcm9sbFxuICAgICAgICAgICAgPyBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBkM1pvb206IGQzWm9vbUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgICAgICAgICAgZDNab29tSGFuZGxlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIHdoZWVsSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBzdGFydFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignc3RhcnQnLCBzdGFydEhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gcGFuIHpvb21cbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21IYW5kbGVyID0gY3JlYXRlUGFuWm9vbUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51OiAhIW9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3pvb20nLCBwYW5ab29tSGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21FbmRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignZW5kJywgcGFuWm9vbUVuZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNyZWF0ZUZpbHRlcih7XG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgY29ubmVjdGlvbkluUHJvZ3Jlc3MsXG4gICAgICAgIH0pO1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2UgY2Fubm90IGFkZCB6b29tT25Eb3VibGVDbGljayB0byB0aGUgZmlsdGVyIGFib3ZlIGJlY2F1c2VcbiAgICAgICAgICogZG91YmxlIHRhcHBpbmcgb24gdG91Y2ggc2NyZWVucyBjaXJjdW12ZW50cyB0aGUgZmlsdGVyIGFuZFxuICAgICAgICAgKiBkYmxjbGljay56b29tIGlzIGZpcmVkIG9uIHRoZSBzZWxlY3Rpb24gZGlyZWN0bHlcbiAgICAgICAgICovXG4gICAgICAgIGlmICh6b29tT25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBkM0RibENsaWNrWm9vbUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHZpZXdwb3J0LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgIGNvbnN0IGNvbnRyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb21JbnN0YW5jZT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBpZiAoY29udHJhaW5lZFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKGNvbnRyYWluZWRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShjb250cmFpbmVkVHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0KHZpZXdwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKG5leHRUcmFuc2Zvcm0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUobmV4dFRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzeW5jVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0uayAhPT0gdmlld3BvcnQuem9vbSB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueCAhPT0gdmlld3BvcnQueCB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueSAhPT0gdmlld3BvcnQueSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zZm9ybShkM1NlbGVjdGlvbiwgbmV4dFRyYW5zZm9ybSwgbnVsbCwgeyBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0KCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBkM1NlbGVjdGlvbiA/IHpvb21UcmFuc2Zvcm0oZDNTZWxlY3Rpb24ubm9kZSgpKSA6IHsgeDogMCwgeTogMCwgazogMSB9O1xuICAgICAgICByZXR1cm4geyB4OiB0cmFuc2Zvcm0ueCwgeTogdHJhbnNmb3JtLnksIHpvb206IHRyYW5zZm9ybS5rIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8oem9vbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkuc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgem9vbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uaW50ZXJwb2xhdGUob3B0aW9ucz8uaW50ZXJwb2xhdGUgPT09ICdsaW5lYXInID8gaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVpvb20pLnNjYWxlQnkoZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgb3B0aW9ucz8uZWFzZSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIGZhY3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0U2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENsaWNrRGlzdGFuY2UoZGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWREaXN0YW5jZSA9ICFpc051bWVyaWMoZGlzdGFuY2UpIHx8IGRpc3RhbmNlIDwgMCA/IDAgOiBkaXN0YW5jZTtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LmNsaWNrRGlzdGFuY2UodmFsaWREaXN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgc2V0Vmlld3BvcnQsXG4gICAgICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQsXG4gICAgICAgIGdldFZpZXdwb3J0LFxuICAgICAgICBzY2FsZVRvLFxuICAgICAgICBzY2FsZUJ5LFxuICAgICAgICBzZXRTY2FsZUV4dGVudCxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBzeW5jVmlld3BvcnQsXG4gICAgICAgIHNldENsaWNrRGlzdGFuY2UsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGRldGVybWluZSB0aGUgdmFyaWFudCBvZiB0aGUgcmVzaXplIGNvbnRyb2xcbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZXNpemVDb250cm9sVmFyaWFudDtcbihmdW5jdGlvbiAoUmVzaXplQ29udHJvbFZhcmlhbnQpIHtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkhhbmRsZVwiXSA9IFwiaGFuZGxlXCI7XG59KShSZXNpemVDb250cm9sVmFyaWFudCB8fCAoUmVzaXplQ29udHJvbFZhcmlhbnQgPSB7fSkpO1xuY29uc3QgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TID0gWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcblxuLyoqXG4gKiBHZXQgYWxsIGNvbm5lY3RpbmcgZWRnZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIG5vZGVzXG4gKiBAcGFyYW0gd2lkdGggLSBuZXcgd2lkdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2V2lkdGggLSBwcmV2aW91cyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGhlaWdodCAtIG5ldyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2SGVpZ2h0IC0gcHJldmlvdXMgaGVpZ2h0IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gYWZmZWN0c1ggLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHggYXhpc1xuICogQHBhcmFtIGFmZmVjdHNZIC0gd2hldGhlciB0byBpbnZlcnQgdGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoZSB5IGF4aXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIHR3byBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByZXNpemUgZm9yIGVhY2ggYXhpcywgMCA9IG5vIGNoYW5nZSwgMSA9IGluY3JlYXNlLCAtMSA9IGRlY3JlYXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZURpcmVjdGlvbih7IHdpZHRoLCBwcmV2V2lkdGgsIGhlaWdodCwgcHJldkhlaWdodCwgYWZmZWN0c1gsIGFmZmVjdHNZLCB9KSB7XG4gICAgY29uc3QgZGVsdGFXaWR0aCA9IHdpZHRoIC0gcHJldldpZHRoO1xuICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID0gaGVpZ2h0IC0gcHJldkhlaWdodDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBbZGVsdGFXaWR0aCA+IDAgPyAxIDogZGVsdGFXaWR0aCA8IDAgPyAtMSA6IDAsIGRlbHRhSGVpZ2h0ID4gMCA/IDEgOiBkZWx0YUhlaWdodCA8IDAgPyAtMSA6IDBdO1xuICAgIGlmIChkZWx0YVdpZHRoICYmIGFmZmVjdHNYKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IGRpcmVjdGlvblswXSAqIC0xO1xuICAgIH1cbiAgICBpZiAoZGVsdGFIZWlnaHQgJiYgYWZmZWN0c1kpIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gZGlyZWN0aW9uWzFdICogLTE7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgY29udHJvbCBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIGRyYWdnZWQgdG8gZGltZW5zaW9ucyB0aGF0IGFyZSBiZWluZyByZXNpemVkXG4gKiBAcGFyYW0gY29udHJvbFBvc2l0aW9uIC0gcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgdGhhdCBpcyBiZWluZyBkcmFnZ2VkXG4gKiBAcmV0dXJucyBpc0hvcml6b250YWwsIGlzVmVydGljYWwsIGFmZmVjdHNYLCBhZmZlY3RzWSxcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3JpZ2h0JykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICBjb25zdCBhZmZlY3RzWCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIGNvbnN0IGFmZmVjdHNZID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0hvcml6b250YWwsXG4gICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgIGFmZmVjdHNYLFxuICAgICAgICBhZmZlY3RzWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJFeHRlbnRDbGFtcChsb3dlckV4dGVudCwgbG93ZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBsb3dlckJvdW5kIC0gbG93ZXJFeHRlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VXBwZXJFeHRlbnRDbGFtcCh1cHBlckV4dGVudCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCB1cHBlckV4dGVudCAtIHVwcGVyQm91bmQpO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZUNsYW1wKHNpemUsIG1pblNpemUsIG1heFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWluU2l6ZSAtIHNpemUsIHNpemUgLSBtYXhTaXplKTtcbn1cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyAhYiA6IGI7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgbmV3IHdpZHRoICYgaGVpZ2h0IGFuZCB4ICYgeSBvZiBub2RlIGFmdGVyIHJlc2l6ZSBiYXNlZCBvbiBwb2ludGVyIHBvc2l0aW9uXG4gKiBAZGVzY3JpcHRpb24gLSBCdWNrbGUgdXAsIHRoaXMgaXMgYSBjaHVua3kgb25lLi4uIElmIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgbmV3IGRpbWVuc2lvbnMgb2YgYSBub2RlIGFmdGVyIGEgcmVzaXplLFxuICogeW91IGhhdmUgdG8gYWNjb3VudCBmb3IgYWxsIHBvc3NpYmxlIHJlc3RyaWN0aW9uczogbWluL21heCB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUsIHRoZSBtYXhpbXVtIGV4dGVudCB0aGUgbm9kZSBpcyBhbGxvd2VkXG4gKiB0byBtb3ZlIGluIChpbiB0aGlzIGNhc2U6IHJlc2l6ZSBpbnRvKSBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgbm9kZSwgdGhlIG1pbmltYWwgZXh0ZW50IGRldGVybWluZWQgYnkgY2hpbGQgbm9kZXNcbiAqIHdpdGggZXhwYW5kUGFyZW50IG9yIGV4dGVudDogJ3BhcmVudCcgc2V0IGFuZCBvaCB5ZWFoLCB0aGVzZSB0aGluZ3MgYWxzbyBoYXZlIHRvIHdvcmsgd2l0aCBrZWVwQXNwZWN0UmF0aW8hXG4gKiBUaGUgd2F5IHRoaXMgaXMgZG9uZSBpcyBieSBkZXRlcm1pbmluZyBob3cgbXVjaCBlYWNoIG9mIHRoZXNlIHJlc3RyaWN0aW5nIGFjdHVhbGx5IHJlc3RyaWN0cyB0aGUgcmVzaXplIGFuZCB0aGVuIGFwcGx5aW5nIHRoZVxuICogc3Ryb25nZXN0IHJlc3RyaWN0aW9uLiBCZWNhdXNlIHRoZSByZXNpemUgYWZmZWN0cyB4LCB5IGFuZCB3aWR0aCwgaGVpZ2h0IGFuZCB3aWR0aCwgaGVpZ2h0IG9mIGEgb3Bwb3Npbmcgc2lkZSB3aXRoIGtlZXBBc3BlY3RSYXRpbyxcbiAqIHRoZSByZXNpemUgYW1vdW50IGlzIGFsd2F5cyBrZXB0IGluIGRpc3RYICYgZGlzdFkgYW1vdW50ICh0aGUgZGlzdGFuY2UgaW4gbW91c2UgbW92ZW1lbnQpXG4gKiBJbnN0ZWFkIG9mIGNsYW1waW5nIGVhY2ggdmFsdWUsIHdlIGZpcnN0IGNhbGN1bGF0ZSB0aGUgYmlnZ2VzdCAnY2xhbXAnIChmb3IgdGhlIGxhY2sgb2YgYSBiZXR0ZXIgbmFtZSkgYW5kIHRoZW4gYXBwbHkgaXQgdG8gYWxsIHZhbHVlcy5cbiAqIFRvIGNvbXBsaWNhdGUgdGhpbmdzIG5vZGVPcmlnaW4gaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCBhcyB3ZWxsLiBUaGlzIGlzIGRvbmUgYnkgb2Zmc2V0dGluZyB0aGUgbm9kZXMgYXMgaWYgdGhlaXIgb3JpZ2luIGlzIFswLCAwXSxcbiAqIHRoZW4gY2FsY3VsYXRpbmcgdGhlIHJlc3RyaWN0aW9ucyBhcyB1c3VhbFxuICogQHBhcmFtIHN0YXJ0VmFsdWVzIC0gc3RhcnRpbmcgdmFsdWVzIG9mIHJlc2l6ZVxuICogQHBhcmFtIGNvbnRyb2xEaXJlY3Rpb24gLSBkaW1lbnNpb25zIGFmZmVjdGVkIGJ5IHRoZSByZXNpemVcbiAqIEBwYXJhbSBwb2ludGVyUG9zaXRpb24gLSB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGNvcnJlY3RlZCBmb3Igc25hcHBpbmdcbiAqIEBwYXJhbSBib3VuZGFyaWVzIC0gbWluaW11bSBhbmQgbWF4aW11bSBkaW1lbnNpb25zIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ga2VlcEFzcGVjdFJhdGlvIC0gcHJldmVudCBjaGFuZ2VzIG9mIGFzcHJlY3QgcmF0aW9cbiAqIEByZXR1cm5zIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIG5vZGUgYWZ0ZXIgcmVzaXplXG4gKi9cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIGV4dGVudCwgY2hpbGRFeHRlbnQpIHtcbiAgICBsZXQgeyBhZmZlY3RzWCwgYWZmZWN0c1kgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgeyBpc0hvcml6b250YWwsIGlzVmVydGljYWwgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgaXNEaWFnb25hbCA9IGlzSG9yaXpvbnRhbCAmJiBpc1ZlcnRpY2FsO1xuICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBwb2ludGVyUG9zaXRpb247XG4gICAgY29uc3QgeyBtaW5XaWR0aCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWF4SGVpZ2h0IH0gPSBib3VuZGFyaWVzO1xuICAgIGNvbnN0IHsgeDogc3RhcnRYLCB5OiBzdGFydFksIHdpZHRoOiBzdGFydFdpZHRoLCBoZWlnaHQ6IHN0YXJ0SGVpZ2h0LCBhc3BlY3RSYXRpbyB9ID0gc3RhcnRWYWx1ZXM7XG4gICAgbGV0IGRpc3RYID0gTWF0aC5mbG9vcihpc0hvcml6b250YWwgPyB4U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJYIDogMCk7XG4gICAgbGV0IGRpc3RZID0gTWF0aC5mbG9vcihpc1ZlcnRpY2FsID8geVNuYXBwZWQgLSBzdGFydFZhbHVlcy5wb2ludGVyWSA6IDApO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKTtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRYID0gLW5vZGVPcmlnaW5bMF0gKiBzdGFydFdpZHRoO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFkgPSAtbm9kZU9yaWdpblsxXSAqIHN0YXJ0SGVpZ2h0O1xuICAgIC8vIENoZWNrIGlmIG1heFdpZHRoLCBtaW5XV2lkdGgsIG1heEhlaWdodCwgbWluSGVpZ2h0IGFyZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgbGV0IGNsYW1wWCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCwgbWluV2lkdGgsIG1heFdpZHRoKTtcbiAgICBsZXQgY2xhbXBZID0gZ2V0U2l6ZUNsYW1wKG5ld0hlaWdodCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgIC8vIENoZWNrIGlmIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgICBsZXQgeEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgbGV0IHlFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGlmIChhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgZGlzdFggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA+IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA8IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFkgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3SGVpZ2h0ICsgb3JpZ2luT2Zmc2V0WSwgZXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCwgY2hpbGRFeHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGgsIGNoaWxkRXh0ZW50WzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZmZWN0c1kgJiYgZGlzdFkgPiAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIGRpc3RZLCBjaGlsZEV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQsIGNoaWxkRXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFzcGVjdCByYXRpbyByZXNpemluZyBvZiB0aGUgb3RoZXIgc2lkZSBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWF4IGRpbWVuc2lvbnMgbWlnaHQgYmUgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgYXNwZWN0SGVpZ2h0Q2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3V2lkdGggLyBhc3BlY3RSYXRpbywgbWluSGVpZ2h0LCBtYXhIZWlnaHQpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEhlaWdodENsYW1wKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIChhZmZlY3RzWCA/IGRpc3RYIDogLWRpc3RYKSAvIGFzcGVjdFJhdGlvLCBleHRlbnRbMF1bMV0pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzBdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSB0aGluZyBmb3IgdmVydGljYWwgcmVzaXppbmdcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdFdpZHRoQ2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIG1pbldpZHRoLCBtYXhXaWR0aCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0V2lkdGhDbGFtcCk7XG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWSAmJiAhYWZmZWN0c1ggJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgKGFmZmVjdHNZID8gZGlzdFkgOiAtZGlzdFkpICogYXNwZWN0UmF0aW8gKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3RZID0gZGlzdFkgKyAoZGlzdFkgPCAwID8gY2xhbXBZIDogLWNsYW1wWSk7XG4gICAgZGlzdFggPSBkaXN0WCArIChkaXN0WCA8IDAgPyBjbGFtcFggOiAtY2xhbXBYKTtcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RYIDogZGlzdFgpIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9ICh4b3IoYWZmZWN0c1gsIGFmZmVjdHNZKSA/IC1kaXN0WSA6IGRpc3RZKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gZGlzdFggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBhZmZlY3RzWSA9IGFmZmVjdHNYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdFggPSBkaXN0WSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNYID0gYWZmZWN0c1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeCA9IGFmZmVjdHNYID8gc3RhcnRYICsgZGlzdFggOiBzdGFydFg7XG4gICAgY29uc3QgeSA9IGFmZmVjdHNZID8gc3RhcnRZICsgZGlzdFkgOiBzdGFydFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyAoYWZmZWN0c1ggPyAtZGlzdFggOiBkaXN0WCksXG4gICAgICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyAoYWZmZWN0c1kgPyAtZGlzdFkgOiBkaXN0WSksXG4gICAgICAgIHg6IG5vZGVPcmlnaW5bMF0gKiBkaXN0WCAqICghYWZmZWN0c1ggPyAxIDogLTEpICsgeCxcbiAgICAgICAgeTogbm9kZU9yaWdpblsxXSAqIGRpc3RZICogKCFhZmZlY3RzWSA/IDEgOiAtMSkgKyB5LFxuICAgIH07XG59XG5cbmNvbnN0IGluaXRQcmV2VmFsdWVzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB4OiAwLCB5OiAwIH07XG5jb25zdCBpbml0U3RhcnRWYWx1ZXMgPSB7XG4gICAgLi4uaW5pdFByZXZWYWx1ZXMsXG4gICAgcG9pbnRlclg6IDAsXG4gICAgcG9pbnRlclk6IDAsXG4gICAgYXNwZWN0UmF0aW86IDEsXG59O1xuZnVuY3Rpb24gbm9kZVRvUGFyZW50RXh0ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtub2RlLm1lYXN1cmVkLndpZHRoLCBub2RlLm1lYXN1cmVkLmhlaWdodF0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBwYXJlbnQsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCB4ID0gcGFyZW50LnBvc2l0aW9uLnggKyBjaGlsZC5wb3NpdGlvbi54O1xuICAgIGNvbnN0IHkgPSBwYXJlbnQucG9zaXRpb24ueSArIGNoaWxkLnBvc2l0aW9uLnk7XG4gICAgY29uc3Qgd2lkdGggPSBjaGlsZC5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGNoaWxkLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSBub2RlT3JpZ2luWzBdICogd2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IG5vZGVPcmlnaW5bMV0gKiBoZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW3ggLSBvcmlnaW5PZmZzZXRYLCB5IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgICAgIFt4ICsgd2lkdGggLSBvcmlnaW5PZmZzZXRYLCB5ICsgaGVpZ2h0IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIFhZUmVzaXplcih7IGRvbU5vZGUsIG5vZGVJZCwgZ2V0U3RvcmVJdGVtcywgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgY29udHJvbFBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIHJlc2l6ZURpcmVjdGlvbiwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCBzaG91bGRSZXNpemUsIH0pIHtcbiAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7IC4uLmluaXRQcmV2VmFsdWVzIH07XG4gICAgICAgIGxldCBzdGFydFZhbHVlcyA9IHsgLi4uaW5pdFN0YXJ0VmFsdWVzIH07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xEaXJlY3Rpb24gPSBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7IC8vIE5lZWRlZCB0byBmaXggZXhwYW5kUGFyZW50XG4gICAgICAgIGxldCBwYXJlbnRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHRyaWdnZXIgb25SZXNpemVFbmQgaWYgb25SZXNpemUgd2FzIGFjdHVhbGx5IGNhbGxlZFxuICAgICAgICBsZXQgcmVzaXplRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBkcmFnKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgcGFuZURvbU5vZGUgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gcGFuZURvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHhTbmFwcGVkLCB5U25hcHBlZCB9ID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcmV2VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCA/PyAwLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSA/PyAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIC4uLnByZXZWYWx1ZXMsXG4gICAgICAgICAgICAgICAgcG9pbnRlclg6IHhTbmFwcGVkLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJZOiB5U25hcHBlZCxcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogcHJldlZhbHVlcy53aWR0aCAvIHByZXZWYWx1ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnIHx8IG5vZGUuZXhwYW5kUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRFeHRlbnQgPSBwYXJlbnROb2RlICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyA/IG5vZGVUb1BhcmVudEV4dGVudChwYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBDb2xsZWN0IGFsbCBjaGlsZCBub2RlcyB0byBjb3JyZWN0IHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERldGVybWluZSBsYXJnZXN0IG1pbmltYWwgZXh0ZW50IHRoZSBwYXJlbnQgbm9kZSBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0b1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkSWQsIGNoaWxkXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudElkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4uY2hpbGQucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogY2hpbGQuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgY2hpbGQuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBub2RlVG9DaGlsZEV4dGVudChjaGlsZCwgbm9kZSwgY2hpbGQub3JpZ2luID8/IG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1pbihleHRlbnRbMF1bMF0sIGNoaWxkRXh0ZW50WzBdWzBdKSwgTWF0aC5taW4oZXh0ZW50WzBdWzFdLCBjaGlsZEV4dGVudFswXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5tYXgoZXh0ZW50WzFdWzBdLCBjaGlsZEV4dGVudFsxXVswXSksIE1hdGgubWF4KGV4dGVudFsxXVsxXSwgY2hpbGRFeHRlbnRbMV1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBleHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0Py4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4gfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHg6IHByZXZYLCB5OiBwcmV2WSwgd2lkdGg6IHByZXZXaWR0aCwgaGVpZ2h0OiBwcmV2SGVpZ2h0IH0gPSBwcmV2VmFsdWVzO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge307XG4gICAgICAgICAgICBjb25zdCBub2RlT3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gc3RvcmVOb2RlT3JpZ2luO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXREaW1lbnNpb25zQWZ0ZXJSZXNpemUoc3RhcnRWYWx1ZXMsIGNvbnRyb2xEaXJlY3Rpb24sIHBvaW50ZXJQb3NpdGlvbiwgYm91bmRhcmllcywga2VlcEFzcGVjdFJhdGlvLCBub2RlT3JpZ2luLCBwYXJlbnRFeHRlbnQsIGNoaWxkRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzV2lkdGhDaGFuZ2UgPSB3aWR0aCAhPT0gcHJldldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaXNIZWlnaHRDaGFuZ2UgPSBoZWlnaHQgIT09IHByZXZIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBpc1hQb3NDaGFuZ2UgPSB4ICE9PSBwcmV2WCAmJiBpc1dpZHRoQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgaXNZUG9zQ2hhbmdlID0geSAhPT0gcHJldlkgJiYgaXNIZWlnaHRDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWlzWFBvc0NoYW5nZSAmJiAhaXNZUG9zQ2hhbmdlICYmICFpc1dpZHRoQ2hhbmdlICYmICFpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1hQb3NDaGFuZ2UgfHwgaXNZUG9zQ2hhbmdlIHx8IG5vZGVPcmlnaW5bMF0gPT09IDEgfHwgbm9kZU9yaWdpblsxXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS54ID0gaXNYUG9zQ2hhbmdlID8geCA6IHByZXZWYWx1ZXMueDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueSA9IGlzWVBvc0NoYW5nZSA/IHkgOiBwcmV2VmFsdWVzLnk7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0gY2hhbmdlLng7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0gY2hhbmdlLnk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB3aGVuIHRvcC9sZWZ0IGNoYW5nZXMsIGNvcnJlY3QgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgICAqIHNvIHRoYXQgdGhleSBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0geCAtIHByZXZYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0geSAtIHByZXZZO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgbm9kZU9yaWdpblswXSAqICh3aWR0aCAtIHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgbm9kZU9yaWdpblsxXSAqIChoZWlnaHQgLSBwcmV2SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENoYW5nZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2lkdGhDaGFuZ2UgfHwgaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICBpc1dpZHRoQ2hhbmdlICYmICghcmVzaXplRGlyZWN0aW9uIHx8IHJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSA/IHdpZHRoIDogcHJldlZhbHVlcy53aWR0aDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaGVpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaXNIZWlnaHRDaGFuZ2UgJiYgKCFyZXNpemVEaXJlY3Rpb24gfHwgcmVzaXplRGlyZWN0aW9uID09PSAndmVydGljYWwnKSA/IGhlaWdodCA6IHByZXZWYWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMud2lkdGggPSBjaGFuZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy5oZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGV4cGFuZFBhcmVudCB3aGVuIHJlc2l6aW5nIGZyb20gdG9wL2xlZnRcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gbm9kZU9yaWdpblswXSAqIChjaGFuZ2Uud2lkdGggPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS54ICYmIGNoYW5nZS54IDwgeExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IHhMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueCA9IHN0YXJ0VmFsdWVzLnggLSAoY2hhbmdlLnggLSB4TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5TGltaXQgPSBub2RlT3JpZ2luWzFdICogKGNoYW5nZS5oZWlnaHQgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS55ICYmIGNoYW5nZS55IDwgeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IHlMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueSA9IHN0YXJ0VmFsdWVzLnkgLSAoY2hhbmdlLnkgLSB5TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFJlc2l6ZURpcmVjdGlvbih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZWYWx1ZXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWDogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWTogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHsgLi4ucHJldlZhbHVlcywgZGlyZWN0aW9uIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsUmVzaXplID0gc2hvdWxkUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgb25SZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2UsIGNoaWxkQ2hhbmdlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNpemVEZXRlY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uUmVzaXplRW5kPy4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgICAgIG9uRW5kPy4oeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgcmVzaXplRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGVjdGlvbi5jYWxsKGRyYWdIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgQ29ubmVjdGlvbkxpbmVUeXBlLCBDb25uZWN0aW9uTW9kZSwgTWFya2VyVHlwZSwgUGFuT25TY3JvbGxNb2RlLCBQb3NpdGlvbiwgUmVzaXplQ29udHJvbFZhcmlhbnQsIFNlbGVjdGlvbk1vZGUsIFhZRHJhZywgWFlIYW5kbGUsIFhZTWluaW1hcCwgWFlQYW5ab29tLCBYWVJlc2l6ZXIsIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgYWRkRWRnZSwgYWRvcHRVc2VyTm9kZXMsIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwsIGFyZVNldHNFcXVhbCwgYm94VG9SZWN0LCBjYWxjQXV0b1BhbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBjbGFtcCwgY2xhbXBQb3NpdGlvbiwgY2xhbXBQb3NpdGlvblRvUGFyZW50LCBjcmVhdGVNYXJrZXJJZHMsIGRlZmF1bHRBcmlhTGFiZWxDb25maWcsIGRldldhcm4sIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBlcnJvck1lc3NhZ2VzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGZpdFZpZXdwb3J0LCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRCb3VuZHNPZkJveGVzLCBnZXRCb3VuZHNPZlJlY3RzLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0Q29ubmVjdGlvblN0YXR1cywgZ2V0RGltZW5zaW9ucywgZ2V0RWRnZUNlbnRlciwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGVtZW50c1RvUmVtb3ZlLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldEV2ZW50UG9zaXRpb24sIGdldEhhbmRsZUJvdW5kcywgZ2V0SGFuZGxlUG9zaXRpb24sIGdldEhvc3RGb3JFbGVtZW50LCBnZXRJbmNvbWVycywgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgZ2V0TWFya2VySWQsIGdldE5vZGVEaW1lbnNpb25zLCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSwgZ2V0Tm9kZXNCb3VuZHMsIGdldE5vZGVzSW5zaWRlLCBnZXRPdXRnb2VycywgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXRQb2ludGVyUG9zaXRpb24sIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBoYW5kbGVFeHBhbmRQYXJlbnQsIGluZmluaXRlRXh0ZW50LCBpbml0aWFsQ29ubmVjdGlvbiwgaXNDb29yZGluYXRlRXh0ZW50LCBpc0VkZ2VCYXNlLCBpc0VkZ2VWaXNpYmxlLCBpc0lucHV0RE9NTm9kZSwgaXNJbnRlcm5hbE5vZGVCYXNlLCBpc01hY09zLCBpc01vdXNlRXZlbnQsIGlzTm9kZUJhc2UsIGlzTnVtZXJpYywgaXNSZWN0T2JqZWN0LCBtZXJnZUFyaWFMYWJlbENvbmZpZywgbm9kZUhhc0RpbWVuc2lvbnMsIG5vZGVUb0JveCwgbm9kZVRvUmVjdCwgb3Bwb3NpdGVQb3NpdGlvbiwgcGFuQnksIHBvaW50VG9SZW5kZXJlclBvaW50LCByZWNvbm5lY3RFZGdlLCByZWN0VG9Cb3gsIHJlbmRlcmVyUG9pbnRUb1BvaW50LCBzaGFsbG93Tm9kZURhdGEsIHNuYXBQb3NpdGlvbiwgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHdpdGhSZXNvbHZlcnMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ })

};
;